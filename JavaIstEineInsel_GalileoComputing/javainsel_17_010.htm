<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Galileo Computing :: Java ist auch eine Insel – 17.10 Persistente Objekte und Serialisierung</title>
<meta name="title" content="Galileo Computing :: Java ist auch eine Insel - 17.10 Persistente Objekte und Serialisierung">
<meta name="author" content="Christian Ullenboom ">
<meta name="publisher" content="Galileo Press 2011">
<meta name="copyright" content="Galileo Press 2011">
<meta name="Description" content="Java ist auch eine Insel - Das umfassende Handbuch – 17.10 Persistente Objekte und Serialisierung">
<meta name="audience" content="Alle">
<meta name="robots" content="INDEX,FOLLOW">
<meta http-equiv="content-language" content="de">
<link rel="stylesheet" type="text/css" href="common/galileo_open.css">
<link rel="prev" href=".htm">
<link rel="next" href=".htm"><script type="text/javascript"><!--
    function OpenWin(url,name,height,width)
    {
      var InfoWin = window.open(url,name,"directories=0,height="+height+",width=" + width + ",hotkeys=0,location=0,menubar=0,resizable=1,screenX=150,screenY=10,left=150,top=10,scrollbars=1,status=1,titlebar=0,toolbar=0");
      InfoWin.focus();
    }
    //--></script><link href="common/prettify.css" type="text/css" rel="stylesheet"><script type="text/javascript" src="common/prettify.js"></script></head>
<body vlink="#000099" link="#000099" alink="#000099" onload="prettyPrint()">
<table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#000066">
<tr>
<td height="74" valign="bottom" colspan="2"><a href="http://www.galileocomputing.de/katalog/openbook?GPP=opjiVIV"><img src="common/galileocomputing_openbook.gif" width="200" height="56" border="0" alt="Galileo Computing < openbook >" title="Galileo Computing < openbook >"></a></td>
<td width="80" height="74"><a href="http://www.galileocomputing.de/?GPP=opjiVIV"><img src="common/galileocomputing.gif" border="0" alt="Galileo Computing - Professionelle Bücher. Auch für Einsteiger." title="Galileo Computing - Professionelle Bücher. Auch für Einsteiger."></a></td>
</tr>
</table>
<div align="right"><a href="http://www.galileocomputing.de/?GPP=opjiVIV" class="navnav">Professionelle Bücher. Auch für Einsteiger.</a></div><br><table class="tbl" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="190" valign="top">
<table class="tbl1" border="0" cellpadding="3" cellspacing="0" width="190" align="left">
<tr>
<td class="tbl2"><a class="nav" href="index.htm#_top">Inhaltsverzeichnis</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_00_001.htm#mj58b119301920569a446c9c510503f310">Vorwort</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_01_001.htm#mja8fc5b7ad19fc7332bc66b09a8fda26e">1 Java ist auch eine Sprache</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_02_001.htm#mj313f67c98dc9ecaddfa2d8b80f057fd2">2 Sprachbeschreibung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_03_001.htm#mjcd3b5720e8605484942e3476a1075bdf">3 Klassen und Objekte</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_04_001.htm#mj71fbc84ad33a281b9352b0b19fae2fb2">4 Der Umgang mit Zeichenketten</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_05_001.htm#mj005cd8e604aefc3ae72b92880fcee5c6">5 Eigene Klassen schreiben</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_06_001.htm#mj6f6b47453043c38837bfc32154a97968">6 Exceptions</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_07_001.htm#mjc4a1f6f3499a02fb64fe89046739edca">7 Generics&lt;T&gt;</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_08_001.htm#mj46e914488628367f5dfc0a62c3a78a53">8 Äußere.innere Klassen</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_09_001.htm#mj94af2b90e8a2dad6c1ef67255f89a137">9 Besondere Klassen der Java SE</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_10_001.htm#mjcae20f50ffbc015d0b66861e7087af9b">10 Architektur, Design und angewandte Objektorientierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_11_001.htm#mj60bc6a007ae9b8657949f3e91d96df3d">11 Die Klassenbibliothek</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_12_001.htm#mj0ce00eb41aae2b084534019cf6edc3b6">12 Bits und Bytes und Mathematisches</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_13_001.htm#mj245f5f8d5a858b46462d64e9b9c0786b">13 Datenstrukturen und Algorithmen</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_14_001.htm#mj8c6f381221d805dd6fbe480731ac0c58">14 Threads und nebenläufige Programmierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_15_001.htm#mjbe3ed0989722396930966f95deeb2497">15 Raum und Zeit</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_16_001.htm#mj78bd405fb0de0cff099c06255fe36853">16 Dateien, Verzeichnisse und Dateizugriffe</a></td>
</tr>
<tr>
<td><a class="navh" href="javainsel_17_001.htm#mjb420b02f4ccf65226f7271e48cefa05d">17 Datenströme</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_18_001.htm#mjedab16f1a9cc168eda4a24416359e0b9">18 Die eXtensible Markup Language (XML)</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_19_001.htm#mjc8f47f7f51ac3795c46c4544f391b02e">19 Grafische Oberflächen mit Swing</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_20_001.htm#mj25cc7d47e476b8b1a183a10ee741dbaa">20 Grafikprogrammierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_21_001.htm#mjea7bcdd596c8bd25b078a00221a01a75">21 Netzwerkprogrammierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_22_001.htm#mjde622db61608a627262a27ecb377d675">22 Verteilte Programmierung mit RMI</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_23_001.htm#mj23bf599d65364bcd05d06a34cb5593bf">23 JavaServer Pages und Servlets</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_24_001.htm#mja621f3b4a74c7fa576b4a58b1614041e">24 Datenbankmanagement mit JDBC</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_25_001.htm#mja2e217bf5724cc65eba184a2af8b79cf">25 Reflection und Annotationen</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_26_001.htm#mjb47dd6e0a309b7e78cad68f6b5de9319">26 Dienstprogramme für die Java-Umgebung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_27_001.htm#mjf59db36d9280a70e0d3d196e9bf160f5">A Die Begleit-DVD</a></td>
</tr>
<tr>
<td><a class="navnav" href="stichwort.htm#_top">Stichwort</a></td>
</tr>
<tr>
<td><br><a href="http://download2.galileo-press.de/openbook/galileocomputing_javainsel9.zip" class="navnav"><strong>Download:</strong><br>- ZIP, ca. 20,5 MB</a></td>
</tr>
<tr>
<td><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV" class="navnav">Buch bestellen</a></td>
</tr>
<tr>
<td><a class="navnav" href="#kommentar">Ihre Meinung?</a><br><br></td>
</tr>
</table>
</td>
<td width="10"><img src="common/spacer10.gif" width="10" height="10" alt="Spacer"></td>
<td width="85%" valign="top" align="center"><div align="center">
<table width="98%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="javainsel_17_009.htm" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a href="http://www.galileocomputing.de/?GPP=opjiVIV" class="navnav">Galileo Computing /</a><a href="http://www.galileocomputing.de/katalog/openbook/?GPP=opjiVIV" class="navnav"> &lt;openbook&gt; /</a><a href="index.htm" class="navnav"> Java-Insel</a></div></td>
<td align="right" width="25%"><div align="right"><a href="javainsel_17_011.htm" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" valign="top"><table width="100%" border="0" cellpadding="10" cellspacing="0" class="box">
<tr>
<td colspan="2"><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV" class="buchtitel">Java ist auch eine Insel</a><span class="autor"> von Christian Ullenboom </span><br><span class="untertitel">Das umfassende Handbuch</span></td>
</tr>
<tr>
<td valign="top" width="211"><dl>
<dt><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV" class="navnav"><img src="common/9783836215060.gif" border="0" alt="Buch: Java ist auch eine Insel" title="Buch: Java ist auch eine Insel"></a></dt>
<dd><br><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV"><span class="autor"><strong>Java ist auch eine Insel</strong><br>geb., mit DVD<br>1482 S., 49,90 Euro<br>Galileo Computing<br>ISBN 978-3-8362-1506-0</span></a></dd>
</dl></td>
<td width="80%"><table border="0">
<tr>
<td valign="baseline"><img src="common/pfeil_u.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="3" class="kap"><strong><a href="javainsel_17_001.htm#mjb420b02f4ccf65226f7271e48cefa05d" class="navnav">17 Datenströme</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_17_001.htm#mj7a324cf69fbedec30392b88f514c1531" class="navnav">17.1 Stream-Klassen und Reader/Writer am Beispiel von Dateien</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_001.htm#mj87f7ea8c7b8051417049399df2c5782a" class="navnav">17.1.1 Mit dem FileWriter Texte in Dateien schreiben</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_001.htm#mj5716136ecff252fbd4596261b9080831" class="navnav">17.1.2 Zeichen mit der Klasse »FileReader« lesen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_001.htm#mjb01e1a0c69c28aad4f4d7eeee1de357d" class="navnav">17.1.3 Kopieren mit »FileOutputStream« und »FileInputStream«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_001.htm#mjbdc9ce90e6d512ae0291a2ed6232d72a" class="navnav">17.1.4 Das FileDescriptor-Objekt *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_17_002.htm#mj9a4cc18f2e2c6f801a5cc621aa15984f" class="navnav">17.2 Basisklassen für die Ein-/Ausgabe</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_002.htm#mj203b54d682c73aada147e1b57c01662f" class="navnav">17.2.1 Die abstrakten Basisklassen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_002.htm#mj7a1dda9729bd603bcadebc990609f10f" class="navnav">17.2.2 Übersicht über Ein-/Ausgabeklassen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_002.htm#mjd34b697cdf6ea75732127f6a06fc88b0" class="navnav">17.2.3 Die abstrakte Basisklasse »OutputStream«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_002.htm#mj2202e460fa14e6ecb6820f4ef86a77f8" class="navnav">17.2.4 Die Schnittstellen »Closeable« und »Flushable«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_002.htm#mj25199db178b60bddb59bd9defea22c22" class="navnav">17.2.5 Ein Datenschlucker *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_002.htm#mj534fca11b85556e6eec99b4fdd7a4553" class="navnav">17.2.6 Die abstrakte Basisklasse »InputStream«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_002.htm#mjc2905c008847dad671feaa7501f0d82f" class="navnav">17.2.7 Ressourcen aus dem Klassenpfad und aus Jar–Archiven laden</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_002.htm#mj8c65b2939c83b858ed311032513e29b4" class="navnav">17.2.8 Ströme mit SequenceInputStream zusammensetzen *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_002.htm#mjb3889bbefb776f81c16212ee860a5b81" class="navnav">17.2.9 Die abstrakte Basisklasse »Writer«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_002.htm#mj8bdb238857679cf8eede58d00850de6b" class="navnav">17.2.10 Die Schnittstelle »Appendable« *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_002.htm#mj923c62d6bac3e8a5c5b75c58df0b0bd3" class="navnav">17.2.11 Die abstrakte Basisklasse »Reader«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_17_003.htm#mjb6060f6cd569b28d5768b131b007f8c8" class="navnav">17.3 Formatierte Textausgaben</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_003.htm#mj3573ae904c53fd07e28b8d6dc4973fc8" class="navnav">17.3.1 Die Klassen »PrintWriter« und »PrintStream«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_003.htm#mjc6e7c16fc76cbc87e02a674ecb288cbf" class="navnav">17.3.2 »System.out«, »System.err« und »System.in«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_17_004.htm#mj52686ccc039a7d0b9fdf13da77f25534" class="navnav">17.4 Schreiben und Lesen aus Strings und Byte-Feldern</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_004.htm#mj97a3eda7509a5b9a017d7b03763042ee" class="navnav">17.4.1 Mit dem »StringWriter« ein String-Objekt füllen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_004.htm#mj94b85a8029a72b2ead03272e22027344" class="navnav">17.4.2 CharArrayWriter</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_004.htm#mj1fbd4214555249440ffa5a256c369d52" class="navnav">17.4.3 »StringReader« und »CharArrayReader«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_004.htm#mjb453ad9336694734eec75f9d0145cc03" class="navnav">17.4.4 Mit »ByteArrayOutputStream« in ein Byte-Feld schreiben</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_004.htm#mje1eff635da76d0cbd2c4c316ee940cfb" class="navnav">17.4.5 Mit »ByteArrayInputStream« aus einem Byte-Feld lesen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_17_005.htm#mjafc99f810e12c276ba2a4b6fc3c009c3" class="navnav">17.5 Datenströme filtern und verketten</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_005.htm#mj4466c357c7508a8eb1ceaaaa7a22f5ed" class="navnav">17.5.1 Streams als Filter verketten (verschalen)</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_005.htm#mj3a1085565ee3f519c058eb06e024f57a" class="navnav">17.5.2 Gepufferte Ausgaben mit »BufferedWriter«/»BufferedOutputStream«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_005.htm#mjd7529c220ef65a0b793a27365ea5de14" class="navnav">17.5.3 Gepufferte Eingaben mit »BufferedReader«/»BufferedInputStream«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_005.htm#mj019dc3443d19cfbdda730582336dc29d" class="navnav">17.5.4 »LineNumberReader« zählt automatisch Zeilen mit *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_005.htm#mj46d4c0c0873fbee2cbb4dbbf6aacfb92" class="navnav">17.5.5 Daten mit der Klasse »PushbackReader« zurücklegen *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_005.htm#mjeee25cb2d512bd9c6098a285327bb9de" class="navnav">17.5.6 DataOutputStream/DataInputStream *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_005.htm#mj5ca3c8f350c3026418585f4f6765a4a7" class="navnav">17.5.7 Basisklassen für Filter *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_005.htm#mj9f0672d3026eda914c090ee852a9042f" class="navnav">17.5.8 Die Basisklasse »FilterWriter« *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_005.htm#mjcf7a24a8d32eab395c95b5a1a055ee61" class="navnav">17.5.9 Ein LowerCaseWriter *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_005.htm#mj4744fe492703c6ebebb6a59fc1ecab41" class="navnav">17.5.10 Eingaben mit der Klasse »FilterReader« filtern *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_005.htm#mjbb86eafceec41ba0b8b469e325491f65" class="navnav">17.5.11 Anwendungen für »FilterReader« und »FilterWriter« *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_17_006.htm#mj23b9709abc382e2f5711eb2fa2afe62a" class="navnav">17.6 Vermittler zwischen Byte-Streams und Unicode-Strömen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_006.htm#mj3d46af3cebae8a6b48a1b86f51aa9a9a" class="navnav">17.6.1 Datenkonvertierung durch den »OutputStreamWriter«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_006.htm#mj144d7a0549a2ce1fab9915120fb31b22" class="navnav">17.6.2 Automatische Konvertierungen mit dem »InputStreamReader«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_17_007.htm#mjfe86e50114d12487bf98150109f0c80e" class="navnav">17.7 Kommunikation zwischen Threads mit Pipes *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_007.htm#mj5543b5920d0846d094719457aed5af2d" class="navnav">17.7.1 »PipedOutputStream« und »PipedInputStream«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_007.htm#mj59d39f069c9dee074ea833ee91cdb61d" class="navnav">17.7.2 »PipedWriter« und »PipedReader«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_17_008.htm#mjbbc77ec964ae1ebbe66c5eb2007a8b82" class="navnav">17.8 Datenkompression *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_008.htm#mj3a803e5a22241029d6675e5d613ea7e2" class="navnav">17.8.1 Java-Unterstützung beim Komprimieren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_008.htm#mj7fca467b6415e4b9fe73aee4c8e16a50" class="navnav">17.8.2 Datenströme komprimieren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_008.htm#mje0c8562dbd63f757609825045dddf21d" class="navnav">17.8.3 Zip-Archive</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_008.htm#mjd663fcaaa21f8f86000c0a811e58b9f1" class="navnav">17.8.4 Jar-Archive</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_17_009.htm#mj7b8d560bda25a4f29394a149b2c3d535" class="navnav">17.9 Prüfsummen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_009.htm#mje3d5968795a85089bfd586581f1b781a" class="navnav">17.9.1 Die Schnittstelle Checksum</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_009.htm#mj9cdca16397ae80dcd9d85adf2cf3cc2f" class="navnav">17.9.2 Die Klasse »CRC32«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_009.htm#mj50d1509644070e5a1d40daa4faa61fa9" class="navnav">17.9.3 Die Adler32-Klasse</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="#mjfbe8cb1105d7dfaf6adbc23f31c81b93" class="navh">17.10 Persistente Objekte und Serialisierung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj69bf799342565da382851751b8405c7a" class="navh">17.10.1 Objekte mit der Standard-Serialisierung speichern und lesen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj9d80b91a6c19f204a99e533d4b06d998" class="navh">17.10.2 Zwei einfache Anwendungen der Serialisierung *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj4cfaf8e1986ce009185bb267467eb491" class="navh">17.10.3 Die Schnittstelle »Serializable«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjcafe7062d212cfb4fcf71bb901c8099c" class="navh">17.10.4 Nicht serialisierbare Attribute aussparen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjd107c87fbdb86f55755ffc6b4039e012" class="navh">17.10.5 Das Abspeichern selbst in die Hand nehmen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjb643b06ff5b465827ea26c24669f7289" class="navh">17.10.6 Tiefe Objektkopien *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj263338363082753d9e0405edbfce3f51" class="navh">17.10.7 Versionenverwaltung und die SUID</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj07f5c3cb185628598b5c79a3729d9f9d" class="navh">17.10.8 Wie die »ArrayList« serialisiert *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjfcd0e0b26ebafe7b761d60df5980a4cd" class="navh">17.10.9 Probleme mit der Serialisierung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_17_011.htm#mj127a190a2c34664de897acc631316756" class="navnav">17.11 Alternative Datenaustauschformate</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_011.htm#mjf9ee0e42eb705d67748dc15d0336cb3f" class="navnav">17.11.1 Serialisieren in XML-Dateien</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_011.htm#mje0da83ef3a9c48ec1e3010dacb6e808f" class="navnav">17.11.2 XML-Serialisierung von JavaBeans mit JavaBeans Persistence *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_011.htm#mja49e87eb234ecf53ab600822784dddcb" class="navnav">17.11.3 Open-Source Bibliothek XStream *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_17_012.htm#mja2c8f5a4b1baf6bb787a020787e01cc9" class="navnav">17.12 Tokenizer *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_012.htm#mjd6c5137e5c1c6b9e9b82dbd43f2c974a" class="navnav">17.12.1 StreamTokenizer</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_17_013.htm#mj4a4cb19892fe3082f19af7d71ff8b2e5" class="navnav">17.13 Zum Weiterlesen</a></strong></td>
</tr>
</table><br></td>
</tr>
</table>
<table width="100%" cellpadding="20" cellspacing="0" border="0" bgcolor="#eeeeee">
<tr>
<td><div class="main"><a id="mjfbe8cb1105d7dfaf6adbc23f31c81b93" name="mjfbe8cb1105d7dfaf6adbc23f31c81b93"></a><a name="t21"></a><a name="t2t31"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div>
<h2 class="t2"><span class="cfett">17.10</span> Persistente Objekte und Serialisierung  <a href="#t2t32"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><img src="common/15x15leer.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></h2>
<p>Objekte liegen zwar immer nur zur Laufzeit vor, doch auch nach dem Beenden der virtuellen Maschine soll ihre Struktur nicht verloren gehen. Gewünscht ist ein Mechanismus, der die Objektstruktur und Variablenbelegung zu einer bestimmten Zeit sicher (persistent) macht und an anderer Stelle wieder hervorholt und die Objektstruktur und Variablenbelegung restauriert. Im gespeicherten Datenformat müssen alle Informationen wie Objekttyp und Variablentyp enthalten sein, um später das richtige Wiederherstellen zu ermöglichen. Da Objekte oftmals weitere Objekte einschließen, müssen auch diese Unterobjekte gesichert werden (schreibe ich eine Liste mit Bestellungen, so ist die Liste ohne die referenzierten Objekte sinnlos). Genau dieser Mechanismus wird auch dann angewendet, wenn Objekte über das Netzwerk schwirren. [Die Rede ist hier von RMI.
]  Die persistenten Objekte sichern also neben ihren eigenen Informationen auch die Unterobjekte &#8211; also die von der betrachtenden Stelle aus erreichbaren. Beim Speichern wird rekursiv ein Objektbaum durchlaufen, um eine vollständige Datenstruktur zu erhalten. Der doppelte Zugriff auf ein Objekt wird hier ebenso beachtet wie der Fall, dass zyklische Abhängigkeiten auftreten. Jedes Objekt bekommt dabei ein Handle, sodass es im Datenstrom nur einmal kodiert wird.</p>
<p>Unter Java SE lassen sich Objekte über verschiedene Ansätze automatisch persistent abbilden und speichern:</p>
<ul class="gp">
<li><span class="cfett">Standardserialisierung</span>: Die Objektstruktur und Zustände werden in einem binären Format gesichert. Das Verfahren wird auch <span class="ckursiv">Java Object Serialization</span> <span class="ckursiv">(JOS</span><span class="ckursiv">)</span> genannt &#8211; der Punkt, mit dem wir uns im Folgenden beschäftigen wollen. Die Standardserialisierung ist sehr wichtig bei entfernten Methodenaurufen und weniger, um Dinge über einen langen Zeitraum abzuspeichern und dann irgendwann einmal wieder aus dem Schrank zu holen.</li>
</ul>
<ul class="gp">
<li><span class="cfett">XML-Serialisierung über JavaBeans Persistence</span>: JavaBeans &#8211; und nur solche &#8211; können wir in einem XML-Format sichern. Eine Lösung ist die <span class="ckursiv">JavaBeans Persistence</span> <span class="ckursiv">(JBP</span><span class="ckursiv">)</span>, die ursprünglich für Swing gedacht war. Denn wenn der Zustand einer grafischen Oberfläche mit JOS binär persistiert wird, sind Änderungen an den Internas der Swing-API nicht so einfach möglich, da das Binärformat der JOS sehr eng mit dem Objektmodell verbunden ist. Das heißt, Objekte lassen sich mitunter nicht mehr aus dem Binärdokument rekonstruieren. JBP entkoppelt das, indem nur über Setter/Getter kommunziert wird und nicht auf internen Referenzen, die ein Implementierungsdetail sind, was sich jederzeit ändern kann. Heutzutage spielt JBP in der Praxis kaum eine Rolle.</li>
</ul>
<ul class="gp">
<li><span class="cfett">XML-Abbildung über JAXB</span>: Mit <span class="ckursiv">JAXB</span> steht eine zweite API zum Abbilden der Objektstruktur auf XML-Dokumente bereit. JAXB ist Teil der Standardbibliothek ab Version 6 und wird in Kapitel 18, »Die eXtensible Markup Language (XML)«, erklärt. Sie ist eine sehr wichtige Technologie, insbesondere für Web-Service-Aufrufe.</li>
</ul>
<p>Die drei Möglichkeiten JOS, JBP und JAXB sind in Java SE schon eingebaut. Die Standard-serialisierung erzeugt ein binäres Format und ist sehr stark auf Java ausgerichtet, sodass andere Systeme nicht viel mit den Daten anfangen können. XML ist als Format praktisch, da es auch von anderen Systemen verarbeitet werden kann. Ein anderes kompaktes Binärformat, welches auch Interoperabilität erlaubt, ist <span class="ckursiv">Protocol Buffers</span> (<span class="ckursiv">http://code.google.com/p/protobuf/</span>) von Google; das Unternehmen setzt es intern ein, wenn unterschiedliche Anwendungen Daten austauschen sollen.</p>
<p>Etwas weiter gedacht lassen sich auch Objekte in relationalen Datenbanken speichern, was sich <span class="ckursiv">Objekt-relationales Mapping</span> <span class="ckursiv">(OR-Mapping</span><span class="ckursiv">)</span> nennt. Das ist sehr anspruchsvoll, da die Objektmodelle und Tabellen so ganz anders sind. Die Java SE bietet zum OR-Mapping keine Unterstütztung an, doch mit zusätzlichen Frameworks, wie der <span class="ckursiv">JPA</span> <span class="ckursiv">(Java Persistence API</span><span class="ckursiv">)</span>, ist das zu schaffen. Auch von Hand können die Objekte über JDBC in die Datenbank gebracht werden, was aber nicht zeitgemäß ist.</p><a id="mj69bf799342565da382851751b8405c7a" name="mj69bf799342565da382851751b8405c7a"></a><a name="t31"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t32"></a><h3 class="t3"><span class="cfett">17.10.1</span> Objekte mit der Standard-Serialisierung speichern und lesen  <a href="#t2t33"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t31"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Die Standard-Serialisierung bietet eine einfache Möglichkeit, Objekte persistent zu machen und später wiederherzustellen. Dabei werden die Objektzustände (keine statischen!) in einen Byte-Strom geschrieben (Serialisierung), woraus sie später wieder zu einem Objekt rekonstruiert werden können (Deserialisierung). Im Zentrum stehen zwei Klassen und ihre (De-)Serialisierungs-Methode:</p>
<ul class="gp">
<li><span class="cfett">Serialisierung</span>: Die Klasse <span class="clisting">ObjectOutputStream</span> und die Methode <span class="clisting">writeObject()</span>. Während der Serialisierung geht <span class="clisting">ObjectOutputStream</span> die Zustände und Objektverweise rekursiv ab und schreibt die Zustände Schritt für Schritt in einen Ausgabestrom.</li>
</ul>
<ul class="gp">
<li><span class="cfett">Deserialisierung</span>: Zum Lesen der serialisierten Objektzustände dient die Klasse <span class="clisting">ObjectInputStream</span>. Ihre Methode <span class="clisting">readObject()</span> findet den Typ des serialisierten Objekts und baut daraus zur Laufzeit das Zielobjekt auf.</li>
</ul>
<h4 class="t4">ObjectOutputStream</h4>
<p>An einem Beispiel lässt sich gut erkennen, wie ein <span class="clisting">ObjectOutputStream</span> einen String und das aktuelle Tagesdatum in einen <span class="clisting">OutputStream</span> speichert. Um die Daten in eine Datei zu holen, ist der <span class="clisting">OutputStream</span> ein <span class="clisting">FileOutputStream</span> für eine Datei <span class="ckursiv">datum.ser</span>. Der Dateiname wird meist so gewählt, dass er mit <span class="ckursiv">.ser</span> endet:</p>
<p class="tabunter"><strong>Listing 17.26    </strong>com/tutego/insel/io/ser/SerializeAndDeserializeDate.java, serialize()</p>
<div class="listing"><pre class="prettyprint">OutputStream fos = null;

try
{
  fos = new FileOutputStream( filename );
 <span class="cfett"> ObjectOutputStream o = new ObjectOutputStream( fos );</span>
 <span class="cfett"> o.writeObject( "Today" );</span>
 <span class="cfett"> o.writeObject( new Date() );</span>
}
catch ( IOException e ) { System.err.println( e ); }
finally { try { fos.close(); } catch ( Exception e ) { e.printStackTrace(); } }</pre></div>
<p>Allen Anfang bildet wie üblich ein <span class="clisting">OutputStream</span>, der die Zustände der Objekte und Meta-Informationen aufnimmt. In unserem Fall ist das der <span class="clisting">FileOutputStream</span>. Die Verbindung zwischen der Datei und dem Objektstrom durch die Klasse <span class="clisting">ObjectOutputStream</span> geschieht über den Konstruktor, der einen <span class="clisting">OutputStream</span> annimmt. <span class="clisting">ObjectOutputStream</span> implementiert die Schnittstelle <span class="clisting">ObjectOutput</span> und bietet so beispielsweise die Methode <span class="clisting">writeObject()</span> zum Schreiben von Objekten. Damit wird das Serialisieren des String-Objekts (das »Today«) und des anschließenden Datum-Objekts zum Kinderspiel.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">class java.io.<span class="cfett">ObjectOutputStream</span>
extends OutputStream
implements ObjectOutput, ObjectStreamConstants</pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">ObjectOutputStream( OutputStream out ) throws IOException</span>
Erzeugt einen <span class="clisting">ObjectOutputStream</span>, der in den angegebenen <span class="clisting">OutputStream</span> schreibt. Ein Fehler kann von den Methoden aus dem <span class="clisting">OutputStream</span> kommen.</li>
</ul>
<ul class="gp">
<li><span class="clisting">final void writeObject( Object obj ) throws IOException</span>
Schreibt das Objekt.</li>
</ul>
<ul class="gp">
<li><span class="clisting">void flush() throws IOException</span>
Schreibt noch gepufferte Daten.</li>
</ul>
<ul class="gp">
<li><span class="clisting">void close() throws IOException</span>
Schließt den Datenstrom. Die Methode muss aufgerufen werden, bevor der Datenstrom zur Eingabe verwendet werden soll.</li>
</ul>
<p>Die Methode <span class="clisting">writeObject()</span> kann nicht nur bei Ein-/Ausgabefehlern eine <span class="clisting">IOException</span> auslösen, sondern auch eine <span class="clisting">NotSerializableException</span>, wenn das Objekt gar nicht serialisierbar ist, und eine <span class="clisting">InvalidClassException</span>, wenn beim Serialisieren etwas falschläuft.</p>
<h4 class="t4">Objekte über die Standard-Serialisierung lesen</h4>
<p>Aus den Daten im Datenstrom stellt der <span class="clisting">ObjectInputStream</span> ein neues Objekt her und initialisiert die Zustände, wie sie geschrieben wurden. Wenn nötig, restauriert der <span class="clisting">ObjectInputStream</span> auch Objekte, auf die verwiesen wurde. Die Klasseninformationen müssen zur Laufzeit vorhanden sein, weil bei der Serialisierung nur die Zustände, aber keine <span class="ckursiv">.class</span>-Dateien gesichert werden. Während des Lesens findet <span class="clisting">readObject()</span> also bei unserem Beispiel den String und das Datum. Der <span class="clisting">ObjectInputStream</span> erwartet die Rohdaten wie üblich über einen Eingabestrom. Kommen die Informationen aus einer Datei, verwenden wir den <span class="clisting">FileInputStream</span>:</p>
<p class="tabunter"><strong>Listing 17.27    </strong>com/tutego/insel/io/ser/SerializeAndDeserializeDate.java, deserialize ()</p>
<div class="listing"><pre class="prettyprint">InputStream fis = null;

try
{
  fis = new FileInputStream( filename );</pre></div>
<div class="listing"><pre class="prettyprint"> <span class="cfett"> ObjectInputStream o = new ObjectInputStream( fis );</span>
 <span class="cfett"> String string = (String) o.readObject();</span>
 <span class="cfett"> Date date</span>    <span class="cfett"> = (Date) o.readObject();</span></pre></div>
<div class="listing"><pre class="prettyprint">  System.out.println( string );
  System.out.println( date );
}
catch ( IOException e ) { System.err.println( e ); }
catch ( ClassNotFoundException e ) { System.err.println( e ); }
finally { try { fis.close(); } catch ( Exception e ) { } }</pre></div>
<p>Die explizite Typumwandlung kann natürlich bei einer falschen Zuweisung zu einem Fehler führen. Bei generischen Typen ist diese Typanpassung immer etwas lästig.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">class java.io.<span class="cfett">ObjectInputStream</span>
extends InputStream
implements ObjectInput, ObjectStreamConstants</pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">ObjectInputStream( InputStream out ) throws IOException</span>
Erzeugt einen <span class="clisting">ObjectInputStream</span>, der aus einem gegebenen <span class="clisting">InputStream</span> liest.</li>
</ul>
<ul class="gp">
<li><span class="clisting">final Object readObject() throws ClassNotFoundException, IOException</span>
Liest ein <span class="clisting">Object</span> und gibt es zurück. Eine <span class="clisting">ClassNotFoundException</span> wird ausgelöst, wenn das Objekt zu einer Klasse gehört, die nicht auffindbar ist.</li>
</ul>
<h4 class="t4">Die Schnittstellen »DataOutput« und »DataInput« *</h4>
<p>Die Klasse <span class="clisting">ObjectOutputStream</span> bekommt die Vorgabe für <span class="clisting">writeObject()</span> aus einer Schnittstelle <span class="clisting">ObjectOutput</span>, genauso wie <span class="clisting">ObjectInputStream</span> die Operation <span class="clisting">readObject()</span> aus <span class="clisting">ObjectInput</span> implementiert. Bis auf die Standard-Serialisierung haben die Schnittstellen in Java keine weitere Verwendung.</p>
<p>Die Schnittstelle <span class="clisting">ObjectOutput</span> erweitert selbst die Schnittstelle <span class="clisting">DataOutput</span> um das Schreiben von Primitiven: <span class="clisting">write(byte[])</span>, <span class="clisting">write(byte[], int, int)</span>, <span class="clisting">write(int)</span>, <span class="clisting">writeBoolean(boolean)</span>, <span class="clisting">writeByte(int)</span>, <span class="clisting">writeBytes(String)</span>, <span class="clisting">writeChar(int)</span>, <span class="clisting">writeChars(String)</span>, <span class="clisting">writeDouble(double)</span>, <span class="clisting">writeFloat(float)</span>, <span class="clisting">writeInt(int)</span>, <span class="clisting">writeLong(long)</span>, <span class="clisting">writeShort(int)</span> und <span class="clisting">writeUTF(String)</span>. Das ist bei einer eigenen angepassten Serialisierung interessant, wenn wir selbst das Schreiben von Zuständen übernehmen. Umgekehrt schreibt die Schnittstelle <span class="clisting">DataInput</span> Leseoperationen vor, die <span class="clisting">ObjectInput</span> implementiert.</p><a id="mj9d80b91a6c19f204a99e533d4b06d998" name="mj9d80b91a6c19f204a99e533d4b06d998"></a><a name="t32"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t33"></a><h3 class="t3"><span class="cfett">17.10.2</span> Zwei einfache Anwendungen der Serialisierung *  <a href="#t2t34"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t32"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Im Folgenden wollen wir uns zwei Beispiele für die Serialisierung anschauen:</p>
<ul class="gp">
<li>Objektzustände zu verpacken, ist bei der Kommunikation über ein Netzwerk sehr sinnvoll. Die Serialisierung kann einfach die Zustände von einem Rechner auf den anderen übertragen.</li>
</ul>
<ul class="gp">
<li>Serialisierung ist aber auch eine Möglichkeit, die Zustände als Byte-Feld etwa in eine Datenbank zu schreiben. Dabei werden wir sehen, dass der <span class="clisting">ByteArrayOutputStream</span> eine nützliche Stream-Klasse ist.</li>
</ul>
<h4 class="t4">Objekte über das Netzwerk schicken</h4>
<p>Es ist natürlich wieder feines objektorientiertes Design, dass es der Methode <span class="clisting">writeObject()</span> egal ist, wohin das Objekt geschoben wird. Dazu wird ja einfach dem Konstruktor von <span class="clisting">Object-OutputStream</span> ein <span class="clisting">OutputStream</span> übergeben, und <span class="clisting">writeObject()</span> delegiert dann das Senden der entsprechenden Einträge an die passenden Methoden der <span class="clisting">Output</span>-Klasse. Im Beispiel <span class="clisting">SerializeAndDeserializeDate</span> haben wir ein <span class="clisting">FileOutputStream</span> benutzt. Es gibt aber noch eine ganze Menge anderer Klassen, die vom Typ <span class="clisting">OutputStream</span> sind. So können die Objekte auch in einer Datenbank abgelegt beziehungsweise über das Netzwerk verschickt werden. Wie dies funktioniert, zeigen die nächsten Zeilen:</p>
<div class="listing"><pre class="prettyprint">Socket s = new Socket( host, port );
OutputStream os = s.getOutputStream();
ObjectOutputStream oos = new ObjectOutputStream( os );
oos.writeObject( object );
oos.flush();</pre></div>
<p>Über <span class="clisting">s.getOutputStream()</span> gelangen wir an den Datenstrom. Dann sieht alles wie gewohnt aus. Da wir allerdings auf der Empfängerseite noch ein Protokoll ausmachen müssen, verfolgen wir diesen Weg der Objektversendung nicht weiter und verlassen uns vielmehr auf eine Technik, die sich <span class="ckursiv">RMI</span> nennt.</p>
<h4 class="t4">Objekte in ein Byte-Feld schreiben</h4>
<p>Die Klassen <span class="clisting">ObjectOutputStream</span> und <span class="clisting">ByteArrayOutputStream</span> sind zusammen zwei gute Partner, wenn es darum geht, eine Repräsentation eines Objekts im Speicher zu erzeugen und die geschätzte Größe eines Objekts herauszufinden.</p>
<div class="listing"><pre class="prettyprint">Object o = ...;
ByteArrayOutputStream baos = new ByteArrayOutputStream();
ObjectOutputStream    oos  = new ObjectOutputStream( baos );
oos.writeObject( o );
oos.close();
byte[] array = baos.toByteArray();</pre></div>
<p>Nun steht das Objekt im Byte-Feld. Wollten wir die Größe erfragen, müssten wir das Attribut <span class="clisting">length</span> des Felds auslesen.</p><a id="mj4cfaf8e1986ce009185bb267467eb491" name="mj4cfaf8e1986ce009185bb267467eb491"></a><a name="t33"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t34"></a><h3 class="t3"><span class="cfett">17.10.3</span> Die Schnittstelle »Serializable«  <a href="#t2t35"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t33"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Bisher nahmen wir immer an, dass eine Klasse weiß, wie sie geschrieben wird. Das funktioniert wie selbstverständlich bei vielen vorhandenen Klassen, und so müssen wir uns bei <span class="clisting">writeObject(new Date())</span> keine Gedanken darüber machen, wie die Bibliothek das Datum schreibt und auch wieder liest.</p>
<p>Damit Objekte serialisiert werden können, müssen die Klassen die Schnittstelle <span class="clisting">Serializable</span> implementieren. Diese Schnittstelle enthält keine Methoden und ist nur eine <span class="ckursiv">Markierungsschnittstelle</span> (engl. <span class="ckursiv">marker interface</span>). Implementiert eine Klasse diese Schnittstelle nicht, folgt beim Serialisierungsversuch eine <span class="clisting">NotSerializableException</span>. Eine Klasse wie <span class="clisting">java.util.Date</span> implementiert somit <span class="clisting">Serializable</span>, <span class="clisting">Thread</span> jedoch nicht. Der Serialisierer lässt damit alle Klassen »durch«, die <span class="clisting">instanceof Serializable</span> sind. Daraus folgt, dass alle Unterklassen einer Klasse, die serialisierbar ist, auch ihrerseits serialisierbar sind. So implementiert <span class="clisting">java.lang.Number</span> &#8211; die Basisklasse der Wrapper-Klassen &#8211; die Schnittstelle <span class="clisting">Serializable</span>, und die konkreten Wrapper-Klassen wie <span class="clisting">Integer</span>, <span class="clisting">BigDecimal</span> sind somit ebenfalls serialisierbar.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Werden Exemplare einer nicht-statischen inneren Klasse serialisiert, die äußere Klasse implementiert aber nicht <span class="clisting">Serializable</span>, gibt es einen Fehler, denn intern hält ein Objekt der inneren Klasse einen Verweis auf das Exemplar der äußeren Klasse. Statische innere Klassen machen das nicht, was das Problem mit der Serialisierung lösen kann. Das Datenvolumen kann natürlich groß werden, wenn schlanke, nicht-statische innere <span class="clisting">Serializable</span>-Klassen in einer äußeren <span class="clisting">Serializable</span>-Klasse liegen, die sehr viele Eigenschaften besitzt.</p>
</td>
</tr>
</table><br><h4 class="t4">»Person« als Beispiel für eine serialisierbare Klasse</h4>
<p>Wir wollen im Folgenden eine Klasse <span class="clisting">Person</span> serialisierbar machen. Dazu benötigen wir das folgende Gerüst:</p>
<p class="tabunter"><strong>Listing 17.28    </strong>com/tutego/insel/io/ser/Person.java</p>
<div class="listing"><pre class="prettyprint">package com.tutego.insel.io.ser;

import java.io.Serializable;
import java.util.Date;

public class Person<span class="cfett"> implements Serializable</span>
{
  static int BMI_OVERWEIGHT = 25;

  String name;
  Date   birthday;
  double bodyHeight;
}</pre></div>
<p>Erzeugen wir ein <span class="clisting">Person</span>-Objekt <span class="clisting">p</span> und rufen <span class="clisting">writeObject(p)</span> auf, so schiebt der <span class="clisting">ObjectOutputStream</span> die Variablen-Belegungen (hier <span class="clisting">name</span>, <span class="clisting">birthday</span> und <span class="clisting">bodyHeight</span>) in den Datenstrom.</p>
<p>Statische Variablen wie <span class="clisting">BMI_OVERWEIGHT</span> werden nicht mit dem Standard-Serialisierungsmechanismus gesichert. Bevor durch Deserialisierung ein Objekt einer Klasse erzeugt wird, muss schon die Klasse geladen sein, was bedeutet, dass statische Variablen schon initialisiert sind. Wenn zwei Objekte wieder deserialisiert werden, könnte es andernfalls vorkommen, dass beide unterschiedliche Werte aufweisen. Was sollte dann passieren?</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Feld-Objekte sind standardmäßig serialisierbar &#8211; sie implementieren versteckt die Schnittstelle <span class="clisting">Serializable</span>.</p>
</td>
</tr>
</table><br><h4 class="t4">Nicht serialisierbare Objekte</h4>
<p>Nicht alle Objekte sind serialisierbar. Zu den nicht serialisierbaren Klassen gehören zum Beispiel <span class="clisting">Thread</span> und <span class="clisting">Socket</span> und viele weitere Klassen aus dem <span class="clisting">java.io</span>-Paket. Das liegt daran, dass nicht klar ist, wie zum Beispiel ein Wiederaufbau aussehen sollte. Wenn ein Thread etwa eine Datei zum Lesen geöffnet hat, wie soll der Zustand serialisiert werden, sodass er beim Deserialisieren auf einem anderen Rechner sofort wieder laufen und dort weitermachen kann, wo er mit dem Lesen aufgehört hat?</p>
<p>Ob Objekte als Träger sensibler Daten serialisierbar sein sollen, ist gut zu überlegen. Denn bei der Serialisierung der Zustände &#8211; es werden auch private Attribute serialisiert, an die zunächst nicht so einfach heranzukommen ist &#8211; öffnet sich die Kapselung. Aus dem Datenstrom lassen sich die internen Belegungen ablesen und auch manipulieren.</p><a id="mjcafe7062d212cfb4fcf71bb901c8099c" name="mjcafe7062d212cfb4fcf71bb901c8099c"></a><a name="t34"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t35"></a><h3 class="t3"><span class="cfett">17.10.4</span> Nicht serialisierbare Attribute aussparen  <a href="#t2t36"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t34"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Es gibt eine Reihe von Objekttypen, die sich nicht serialisieren lassen &#8211; technisch gesprochen implementieren diese Klassen die Schnittstelle <span class="clisting">Serializable</span> nicht. Der Grund, dass nicht alle Klassen diese Schnittstelle implementieren, liegt zum Beispiel in der Sicherheit begründet. Ein Objekt, das Passwörter speichert, soll nicht einfach geschrieben werden. Da reicht es nicht, dass die Attribute privat sind, denn auch sie werden geschrieben. Der andere Punkt ist die Tatsache, dass sich nicht alle Zustände beim Deserialisieren wiederherstellen lassen. Was ist, wenn ein <span class="clisting">FileInputStream</span> oder <span class="clisting">Thread</span> serialisiert wird? Soll dann bei der Deserialisierung eine Datei geöffnet werden oder der Thread neu starten? Was ist, wenn die Datei nicht vorhanden ist? Da all diese Fragen ungeklärt sind, ist es am einfachsten, wenn die Klassen nicht serialisierbarer Objekte die Schnittstelle <span class="clisting">Serializable</span> nicht implementieren.</p>
<p>Doch was soll geschehen, wenn ein Objekt geschrieben wird, das intern auf ein nicht serialisierbares Objekt &#8211; etwa auf einen Thread &#8211; verweist?</p>
<p>Die Serialisierung der folgenden Klasse führt zu einem Laufzeitfehler:</p>
<p class="tabunter"><strong>Listing 17.29    </strong>com/tutego/insel/io/ser/SerializeTransient.java, NotTransientNotSerializable</p>
<div class="listing"><pre class="prettyprint">class NotTransientNotSerializable implements Serializable
{
  Thread t = new Thread();
//  transient Thread t = new Thread();
  String s = "Fremde sind Freunde, die man nur noch nicht kennengelernt hat.";
}</pre></div>
<p>Der Fehler wird eine <span class="clisting">NotSerializableException</span> sein:</p>
<div class="listing"><pre class="prettyprint">Exception in thread "main" java.io.NotSerializableException: java.lang.Thread
    at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1151)
    at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1504)
    at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1469)
at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1387)
at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1145)
at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:326)
at com.tutego.insel.io.ser.SerializeTransient.main(SerializeTransient.java:19)</pre></div>
<p>Die Begründung dafür ist einfach: Ein Thread lässt sich nicht serialisieren.</p>
<p>Wollten wir ein Objekt vom Typ <span class="clisting">NotTransientNotSerializable</span> ohne Thread serialisieren, müssen wir dem Serialisierungsmechanismus mitteilen: »Nimm so weit alle Objekte, aber nicht den Thread!«</p>
<p>Um Elemente bei der Serialisierung auszusparen, bietet Java zwei Möglichkeiten:</p>
<ul class="gp">
<li>ein spezielles Schlüsselwort: <span class="clisting">transient</span></li>
</ul>
<ul class="gp">
<li>das Feld <span class="clisting">private final ObjectStreamField[] serialPersistentFields = {...}</span>, das alle serialisierbaren Eigenschaften aufzählt</li>
</ul>
<p>Statische Eigenschaften würden auch nicht serialisiert, aber das ist hier nicht unser Ziel.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Ausnahmen sind standardmäßg serialisierbar, da <span class="clisting">Throwable</span> die Schnittstelle <span class="clisting">Serializable</span> implementiert. Denn gibt es Serverfehler bei entfernten Methodenaufrufen, so werden die Fehler gerne mit über die Leitung übertragen. Natürlich darf in dem Fall die zu serialisierende Ausnahme auch nur serialisierbare Attribute referenzieren.</p>
</td>
</tr>
</table><br><h4 class="t4">Das Schlüsselwort »transient«</h4>
<p>Um beim Serialisieren Attribute auszusparen, bietet Java den Modifizierer <span class="clisting">transient</span>, der alle Attribute markiert, die <span class="ckursiv">nicht</span> persistent sein sollen. Damit lassen wir die nicht serialisierbaren Kandidaten außen vor und speichern alles ab, was sich speichern lässt.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Das <span class="clisting">Thread</span>-Objekt hinter <span class="clisting">t</span> soll nicht serialisiert werden:</p>
<div class="listing"><pre class="prettyprint"><span class="cfett">transient</span> Thread t;</pre></div>
</td>
</tr>
</table><br><h4 class="t4">Die Variable »serialPersistentFields« *</h4>
<p>Erkennt der Serialisierer in der Klasse eine private statische Feld-Variable <span class="clisting">serialPersistentFields</span>, wird er die <span class="clisting">ObjectStreamField</span>-Einträge des Feldes beachten und nur die dort aufgezählten Elemente serialisieren, egal, was <span class="clisting">transient</span> markiert ist.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Von einer Klasse sollen der String <span class="clisting">s</span> und das Datum <span class="clisting">date</span> serialisiert werden:</p>
<div class="listing"><pre class="prettyprint">private static final ObjectStreamField[] serialPersistentFields = 
  new ObjectStreamField[]
{
  new ObjectStreamField( "s", String.class ),
  new ObjectStreamField( "date", Date.class )
};</pre></div>
</td>
</tr>
</table><br><a id="mjd107c87fbdb86f55755ffc6b4039e012" name="mjd107c87fbdb86f55755ffc6b4039e012"></a><a name="t35"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t36"></a><h3 class="t3"><span class="cfett">17.10.5</span> Das Abspeichern selbst in die Hand nehmen  <a href="#t2t37"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t35"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Die Java-Bibliothek realisiert intern ein Serialisierungs-Protokoll, das beschreibt, wie die Abbildung auf einen Bytestrom aussieht. Dieses »Object Serialization Stream Protocol« beschreibt Oracle unter <span class="ckursiv">http://download.oracle.com/javase/6/docs/platform/serialization/spec/protocol.html</span> etwas genauer, aber Details sind normalerweise nicht nötig.</p>
<p>Es kann aber passieren, dass die Standard-Serialisierung nicht erwünscht ist, wenn zum Beispiel beim Zurücklesen weitere Objekte erzeugt werden sollen oder wenn beim Schreiben eine bessere Abbildung durch Kompression möglich ist.</p>
<p>Für diesen Fall müssen spezielle (private!) Methoden implementiert werden. Beide müssen die nachstehenden Signaturen aufweisen:</p>
<div class="listing"><pre class="prettyprint">private synchronized void writeObject( java.io.ObjectOutputStream s )
  throws IOException</pre></div>
<p>und</p>
<div class="listing"><pre class="prettyprint">private synchronized void readObject( java.io.ObjectInputStream s )
  throws IOException, ClassNotFoundException</pre></div>
<p>Die Methode <span class="clisting">writeObject()</span> ist für das Schreiben verantwortlich. Ist der Rumpf leer, gelangen keine Informationen in den Strom, und das Objekt wird folglich nicht gesichert. <span class="clisting">readObject()</span> wird während der Deserialisierung aufgerufen. Ist dieser Rumpf leer, werden keine Zustände rekonstruiert.</p>
<p>Mit diesen Methoden können wir also die Serialisierung selbst in die Hand nehmen und die Attribute so speichern, wie wir es für sinnvoll halten; eine Kompatibilität lässt sich erzwingen. Eine kleine Versionsnummer im Datenstrom könnte eine Verzweigung provozieren, in der die Daten der Version 1 oder andere Daten der Version 2 gelesen werden.</p>
<p>Beim Lesen können komplette Objekte wieder aufgebaut werden, und es lassen sich zum Beispiel nicht-transiente Objekte wiederbeleben. Stellen wir uns einen Thread vor, dessen Zustände beim Schreiben persistent gemacht werden, und beim Lesen wird ein Thread-Objekt wieder erzeugt und zum Leben erweckt.</p>
<h4 class="t4">Oberklassen serialisieren sich gleich mit</h4>
<p>Wird eine Klasse serialisiert, so werden automatisch die Informationen der Oberklasse mitserialisiert. Hierbei gilt, dass wie beim Konstruktor erst die Attribute der Oberklasse in den Datenstrom geschrieben werden und anschließend die Attribute der Unterklasse. Insbesondere bedeutet dies, dass die Unterklasse nicht noch einmal die Attribute der Oberklasse speichern sollte. Das folgende Programm zeigt den Effekt:</p>
<p class="tabunter"><strong>Listing 17.30    </strong>com/tutego/insel/io/ser/WriteTop.java</p>
<div class="listing"><pre class="prettyprint">import java.io.*;

class Base implements Serializable
{
  private void writeObject( ObjectOutputStream oos )
  {
    System.err.println( "Base" );

  }
}

public class WriteTop extends Base
{
  public static void main( String[] args ) throws IOException
  {
    ObjectOutputStream oos = new ObjectOutputStream( System.out );
    oos.writeObject( new WriteTop() );
  }

  private void writeObject( ObjectOutputStream oos )
  {
    System.err.println( "Top" );
  }
}</pre></div>
<p>In der Ausgabe von Eclipse sind die Ausgaben »Base« und »Top« in einer anderen Farbe dargestellt.</p>
<div class="bildbox">
<p><a name="IDALM1D"></a><a onClick="OpenWin('bilder/365_java_12_016.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein365_java_12_016.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<h4 class="t4">Doch noch den Standardserialisierer nutzen</h4>
<p>Die Methoden <span class="clisting">readObject()</span>/<span class="clisting">writeObject()</span> arbeiten nach dem Alles-oder-nichts-Prinzip. Erkennt der Serialisierer, dass die Schnittstelle <span class="clisting">Serializable</span> implementiert wird, fragt er die Klasse, ob sie die Methoden implementiert. Wenn nicht, beginnt bei der Serialisierung der Serialisierungsmechanismus eigenständig, die Attribute auszulesen und in den Datenstrom zu schreiben. Gibt es die <span class="clisting">readObject()</span>/<span class="clisting">writeObject()</span>-Methoden, so wird der Serialisierer diese aufrufen und nicht selbst die Objekte nach den Werten fragen oder die Objekte mit Werten füllen.</p>
<p>Doch die Arbeit des Serialisierers ist eine große Hilfe. Falls viele Attribute zu speichern sind, fällt viel lästige Arbeit beim Programmieren an, da für jedes zu speichernde Attribut der Aufruf einer <span class="clisting">writeXXX()</span>-Methode und beim Lesen eine entsprechende <span class="clisting">readXXX()</span>-Methode nötig sind. Aus diesem Dilemma gibt es einen Ausweg, weil der Serialisierer in den <span class="clisting">readObject()</span>/<span class="clisting">writeObject()</span>-Methoden auch nachträglich dazu verpflichtet werden kann, die nicht-transienten Attribute zu lesen oder zu schreiben. Die privaten Methoden <span class="clisting">readObject()</span> und <span class="clisting">writeObject()</span> bekommen als Argument ein <span class="clisting">ObjectInputStream</span> und ein <span class="clisting">ObjectOutputStream</span>, die über die entsprechenden Methoden verfügen.</p>
<p>Die Klasse <span class="clisting">ObjectOutputStream</span> erweitert <span class="clisting">java.io.OutputStream</span> unter anderem um die Methode <span class="clisting">defaultWriteObject()</span>. Sie speichert die Attribute einer Klasse.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">class java.io.<span class="cfett">ObjectOutputStream</span>
extends OutputStream
implements ObjectOutput, ObjectStreamConstants</pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">public final void defaultWriteObject()</span> <span class="clisting">throws IOException</span>
Schreibt alle nicht-statischen und nicht-transienten Attribute in den Datenstrom. Die Methode kann nur innerhalb einer privaten <span class="clisting">writeObject()</span>-Methode aufgerufen werden; andernfalls erhalten wir eine <span class="clisting">NotActiveException</span>.</li>
</ul>
<p>Das Gleiche gilt für die Methode <span class="clisting">defaultReadObject</span><span class="clisting">()</span> in der Klasse <span class="clisting">ObjectInputStream</span>.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Die Standard-Deserialisieriung hat mit finalen Variablen kein Problem. Wenn wir allerdings selbst <span class="clisting">readObject()</span> aufrufen, können wir nicht problemlos finale Variablen initialisieren. Hier bietet sich an, auf <span class="clisting">defaultReadObject()</span> zurückzugreifen oder abartig zu tricksen, was etwa nötig ist, wenn eine Variable <span class="clisting">final</span> und <span class="clisting">transient</span> ist, da ja transiente Variablen erst gar nicht von der Standardserialisierung berücksichtigt werden. Das Problem ist unter der Fehlernummer 6379948 (http://bugs.sun.com/bugdatabase/view_bug.do?bug_id= 6379948) geführt und dort werden auch einige Lösungen präsentiert.</p>
</td>
</tr>
</table><br><h4 class="t4">Beispiel für »defaultReadObject()«/»defaultWriteObject()« *</h4>
<p>Unsere nächste Klasse <span class="clisting">SpecialWomen</span> deklariert zwei Attribute: <span class="clisting">name</span> und <span class="clisting">alter</span>. Da manche Frauen über ihr Alter nicht sprechen wollen, soll <span class="clisting">alter</span> nicht serialisiert werden; es ist transient. Wir implementieren eigene <span class="clisting">readObject()</span>/<span class="clisting">writeObject()</span>-Methoden, die den Standardserialisierer bemühen. Bei der Rekonstruktion über <span class="clisting">readObject()</span> wird die Frau dann immer 30 bleiben:</p>
<p class="tabunter"><strong>Listing 17.31    </strong>com/tutego/insel/io/ser/SpecialWomen.java</p>
<div class="listing"><pre class="prettyprint">package com.tutego.insel.io.ser;

import java.io.*;

public class SpecialWomen implements Serializable
{
  private static final long serialVersionUID = 2584203323009771108L;

  String name = "Madonna";
  transient int age = 30;

  private void writeObject( ObjectOutputStream oos ) throws IOException
  {
    oos.defaultWriteObject();  // Schreib Name, aber kein Alter
  }

  private void readObject( ObjectInputStream ois ) throws IOException
  {
    try
    {
      ois.defaultReadObject(); // Lies Name, aber ohne Alter
      age = 30;
    }
    catch ( ClassNotFoundException e )
    {
      throw new IOException( "No class found. HELP!!" );
    }
  }
}</pre></div><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Es ist gar nicht so abwegig, nur eine <span class="clisting">readObject()</span>-, aber keine <span class="clisting">writeObject()</span>-Methode zu implementieren. In <span class="clisting">readObject()</span> lässt ein <span class="clisting">defaultReadObject()</span> alle Eigenschaften initialisieren und danach noch Initialisierungsarbeit ähnlich einem Konstruktor durchführen. Dazu zählen etwa die Initialisierung von transienten Attributen, die Registrierung von Listenern und Weiteres.</p>
</td>
</tr>
</table><br><h4 class="t4">Der andere macht&#8217;s: »writeReplace()« und »readResolve()« *</h4>
<p>Eine Klasse muss die Serialisierung nicht selbst übernehmen, sondern kann die Arbeit abgeben. Dazu muss zum Schreiben eine Methode <span class="clisting">writeReplace()</span> implementiert werden, die eine Referenz auf ein Objekt liefert, das das Schreiben übernimmt. Anregungen finden Leser unter <span class="ckursiv">http://download.oracle.com/javase/6/docs/platform/serialization/spec/output.h</span><span class="ckursiv">tml#5324</span> sowie unter <span class="ckursiv">http://www.galileocomputing.de/openbook/java2/kap_12.htm#t24</span> und <span class="ckursiv">http://www.jguru.com/faq/view.jsp?EID=44039</span>.</p><a id="mjb643b06ff5b465827ea26c24669f7289" name="mjb643b06ff5b465827ea26c24669f7289"></a><a name="t36"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t37"></a><h3 class="t3"><span class="cfett">17.10.6</span> Tiefe Objektkopien *  <a href="#t2t38"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t36"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Implementieren Klassen die Markierungsschnittstelle <span class="clisting">Serializable</span> und überschreiben sie die <span class="clisting">clone()</span>-Methode von <span class="clisting">Object</span>, so können sie eine Kopie der Werte liefern. Die üblichen Implementierungen liefern aber nur flache Kopien. Dies bedeutet, dass Referenzen auf Objekte, die von dem zu klonenden Objekt ausgehen, beibehalten und diese Objekte nicht extra kopiert werden. Als Beispiel kann die Datenstruktur <span class="clisting">List</span> genügen, das <span class="clisting">Map</span>-Objekte enthält. Ein Klon dieser Liste ist lediglich eine zweite Liste, deren Elemente auf die gleichen <span class="clisting">Map</span>s zeigen.</p>
<p>Möchten wir das Verhalten ändern und eine tiefe Kopie anfertigen, so haben wir dank eines kleinen Tricks damit keine Mühe: Wir könnten das zu klonende Objekt einfach serialisieren und dann wieder auspacken. Die zu klonenden Objekte müssen dann neben <span class="clisting">Cloneable</span> noch das <span class="clisting">Serializable</span>-Interface implementieren:</p>
<p class="tabunter"><strong>Listing 17.32    </strong>com/tutego/insel/io/ser/Dolly.java, deepCopy()</p>
<div class="listing"><pre class="prettyprint">@SuppressWarnings("unchecked")
public static &lt;T&gt; T deepCopy( T o ) throws Exception
{
  ByteArrayOutputStream baos = new ByteArrayOutputStream();
  new ObjectOutputStream( baos ).writeObject( o );

  ByteArrayInputStream bais = new ByteArrayInputStream( baos.toByteArray() );
  Object p = new ObjectInputStream( bais ).readObject();

  return (T) p;
}</pre></div>
<p>Das Einzige, was wir zum Gelingen der Methode <span class="clisting">deepCopy()</span> beitragen müssen, ist, das Objekt in einem Byte-Feld zu serialisieren, es wieder auszulesen und zu einem Objekt zu konvertieren. Den Einsatz eines <span class="clisting">ByteArrayOutputStream</span> haben wir schon beobachtet, als wir die Länge eines Objekts herausfinden wollten. Nun fügen wir das Feld einfach wieder zu einem <span class="clisting">ByteArrayInputStream</span> hinzu, aus dessen Daten dann <span class="clisting">ObjectInputStream</span> das Objekt rekreieren kann.</p>
<p>Überzeugen wir uns anhand eines kleinen Programms, dass die tiefe Kopie tatsächlich etwas anderes als ein <span class="clisting">clone()</span> ist:</p>
<p class="tabunter"><strong>Listing 17.33    </strong>Dolly.java, main()</p>
<div class="listing"><pre class="prettyprint">Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();
map.put( "Cul de Paris",
         "hinten unter dem Kleid getragenes Gestell oder Polster" );

LinkedList&lt;Map&lt;String,String&gt;&gt; l1 = new LinkedList&lt;Map&lt;String,String&gt;&gt;();
l1.add( map );

@SuppressWarnings("unchecked")
List&lt;Map&lt;String, String&gt;&gt; l2 = (List&lt;Map&lt;String, String&gt;&gt;) l1.clone();

List&lt;Map&lt;String,String&gt;&gt; l3 = (List&lt;Map&lt;String,String&gt;&gt;) deepCopy( l1 );

map.clear();

System.out.println( l1 ); // [{}]
System.out.println( l2 ); // [{}]
System.out.println( l3 ); // [{Cul de Paris=hinten unter dem Kleid ...}]</pre></div>
<p>Zunächst erstellen wir eine <span class="clisting">Map</span>, die wir anschließend in eine Liste packen. Die <span class="clisting">Map</span> enthält ein Pärchen. Kopiert <span class="clisting">clone()</span> die Liste, so wird sie zwar selbst kopiert, aber nicht die referenzierten <span class="clisting">Map</span>-Objekte &#8211; erst die tiefe Kopie kopiert die <span class="clisting">Map</span> mit. Das sehen wir dann, wenn wir den Eintrag aus der <span class="clisting">Map</span> löschen. Dann ergibt <span class="clisting">l1</span> genauso wie <span class="clisting">l2</span> eine leere Liste, da <span class="clisting">l2</span> nur die Verweise auf die <span class="clisting">Map</span> gespeichert hat, die dann aber geleert ist. Anders ist dies bei <span class="clisting">l3</span>, der tiefen Kopie: Hier ist das Paar noch vorhanden.</p><a id="mj263338363082753d9e0405edbfce3f51" name="mj263338363082753d9e0405edbfce3f51"></a><a name="t37"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t38"></a><h3 class="t3"><span class="cfett">17.10.7</span> Versionenverwaltung und die SUID  <a href="#t2t39"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t37"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Die erste Version einer Klassenbibliothek ist in der Regel nicht vollständig und nicht beendet. Es kann gut sein, dass Attribute und Methoden nachträglich in die Klasse eingefügt, gelöscht oder modifiziert werden. Das bedeutet aber auch, dass die Serialisierung zu einem Problem werden kann. Denn ändert sich der Variablentyp oder kommen Variablen hinzu, ist eine gespeicherte Objektserialisierung nicht mehr gültig.</p>
<p>Bei der Serialisierung wird in Java nicht nur der Objektinhalt geschrieben, sondern zusätzlich eine eindeutige Kennung der Klasse, die <span class="ckursiv">UID</span>. Die UID ist ein Hashcode aus Namen, Attributen, Parametern, Sichtbarkeit und so weiter. Sie wird als <span class="clisting">long</span> wie ein Attribut gespeichert. Ändert sich der Aufbau einer Klasse, ändern sich der Hashcode und damit die UID. Klassen mit unterschiedlicher UID sind nicht kompatibel. Erkennt der Lesemechanismus in einem Datenstrom eine UID, die nicht zur Klasse passt, wird eine <span class="clisting">InvalidClassException</span> ausgelöst. Das bedeutet, dass schon ein einfaches Hinzufügen von Attributen zu einem Fehler führt.</p>
<p>Wir wollen uns dies einmal anhand einer einfachen Klasse ansehen. Wir entwickeln eine Klasse <span class="clisting">Player</span> mit einem einfachen Ganzzahlattribut. Später fügen wir eine Fließkommazahl hinzu:</p>
<p class="tabunter"><strong>Listing 17.34    </strong>com/tutego/insel/io/ser/InvalidSer.java, Player</p>
<div class="listing"><pre class="prettyprint">class Player implements Serializable
{
  String name;
  int    age;
}</pre></div>
<p>Dann benötigen wir noch das Hauptprogramm. Wir bilden ein Exemplar von <span class="clisting">Player</span> und schreiben es in eine Datei:</p>
<p class="tabunter"><strong>Listing 17.35    </strong>com/tutego/insel/io/ser/InvalidSer.java, Ausschnitt main()</p>
<div class="listing"><pre class="prettyprint">ObjectOutputStream oos = new ObjectOutputStream( new FileOutputStream( <img src="common/umbruch.gif" border="0" alt="Umbruch">
  "c:/test.ser" ) );
oos.writeObject( new Player() );
oos.close();</pre></div>
<p>Ohne Änderungen können wir es direkt wieder deserialisieren:</p>
<p class="tabunter"><strong>Listing 17.36    </strong>com/tutego/insel/io/ser/InvalidSer.java, Ausschnitt main()</p>
<div class="listing"><pre class="prettyprint">ObjectInputStream ois = new ObjectInputStream( new FileInputStream( <img src="common/umbruch.gif" border="0" alt="Umbruch">
  "c:/test.ser" ) );
Player player = (Player) ois.readObject();
System.out.println( player );
ois.close();</pre></div>
<p>Ändern wir die Klassendeklaration <span class="clisting">Player</span>, sodass wir etwa aus dem <span class="clisting">int age</span> ein <span class="clisting">double age</span> machen, führt dies bei Deserialisieren zu einem Fehler:</p>
<div class="listing"><pre class="prettyprint">Exception in thread "main" java.io.InvalidClassException: com.tutego.insel.io.ser.Player; local class incompatible: stream classdesc serialVersionUID = <img src="common/umbruch.gif" border="0" alt="Umbruch">
44259824709362049, local class serialVersionUID = 8962277452270582278
  at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:562)
  at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1583)
  at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1496)
  at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1732)
  at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1329)
  at java.io.ObjectInputStream.readObject(ObjectInputStream.java:351)
  at com.tutego.insel.io.ser.InvalidSer.main(InvalidSer.java:22)</pre></div>
<h4 class="t4">Die eigene SUID</h4>
<p>Dem oberen Fehlerauszug entnehmen wir, dass der Serialisierungsmechanismus die SUID selbst berechnet. Das Attribut ist als statische, finale Variable mit dem Namen <span class="clisting">serialVersionUID</span> in der Klasse abgelegt. Ändern sich die Klassenattribute, ist es günstig, eine eigene SUID einzutragen, denn der Mechanismus zum Deserialisieren kann dann etwas gutmütiger mit den Daten umgehen. Beim Einlesen gibt es nämlich Informationen, die nicht hinderlich sind. Wir sprechen in diesem Zusammenhang auch von <span class="ckursiv">stream-kompatibel</span>. Dazu gehören zwei Bereiche:</p>
<ul class="gp">
<li>Neue Felder. Befinden sich in der neuen Klasse Attribute, die im Datenstrom nicht benannt sind, werden diese Attribute mit <span class="clisting">0</span> oder <span class="clisting">null</span> initialisiert.</li>
</ul>
<ul class="gp">
<li>Fehlende Felder. Befinden sich im Datenstrom Attribute, die in der neuen Klasse nicht vorkommen, werden sie einfach ignoriert.</li>
</ul>
<p>Die SUID kann eigentlich beliebig sein, doch die IDE bzw. das kleine Java-Dienstprogramm <span class="ckursiv">serialver</span> berechnet einen Wert, der der gleiche wie der ist, wie ihn der Serialisierungsmechanismus berechnet. Auf diese Weise erreichen wir eine stream-kompatible Serialisierung.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Dies wollen wir für unsere Klasse <span class="clisting">Player</span> mit dem Dienstprogramm testen:</p>
<div class="listing"><pre class="prettyprint">$ <span class="cfett">cd</span> S:\Insel\programme\2_15_Streams\bin
$ <span class="cfett">serialver</span>  <span class="cfett">com.tutego.insel.io.ser.Player</span>
com.tutego.insel.io.ser.Player:    static final long serialVersionUID = 8962277452270582278L;</pre></div>
</td>
</tr>
</table><br><p>Die Anweisung aus der letzten Zeile können wir in unsere Klasse <span class="clisting">Player</span> kopieren. Wird danach ein weiteres Attribut in die Klasse gesetzt, es gelöscht oder ändert sich der Typ eines Attributs, tritt die <span class="clisting">InvalidClassException</span> nicht mehr auf, da die Stream-Kompatibilität über die <span class="clisting">serialVersionUID</span> gewährleistet ist.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Tipp   </span>Da der Wert der Variablen <span class="clisting">serialVersionUID</span> egal ist, kann sie bei <span class="clisting">1</span> beginnen und immer dann, wenn es inkompatible Änderungen gibt, um eins erhöht werden.</p>
</td>
</tr>
</table><br><a id="mj07f5c3cb185628598b5c79a3729d9f9d" name="mj07f5c3cb185628598b5c79a3729d9f9d"></a><a name="t38"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t39"></a><h3 class="t3"><span class="cfett">17.10.8</span> Wie die »ArrayList« serialisiert *  <a href="#t2t310"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t38"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Am Beispiel einer <span class="clisting">java.util.ArrayList</span> lässt sich sehr schön beobachten, wie sich die Methoden <span class="clisting">writeObject()</span> und <span class="clisting">readObject()</span> nutzen lassen. Eine <span class="clisting">ArrayList</span> beinhaltet eine Reihe von Elementen. Zur Speicherung nutzt die Datenstruktur ein internes Feld. Das Feld kann größer als die Anzahl der Elemente sein, damit bei jedem <span class="clisting">add()</span> das Feld nicht immer neu vergrößert werden muss. Nehmen wir an, die <span class="clisting">ArrayList</span> würde eine Standardserialisierung nutzen. Was passiert nun? Es könnte das Problem entstehen, dass bei nur einem Objektverweis in der Liste und einer internen Feldgröße von 1.000 Elementen leider 999 <span class="clisting">null</span>-Verweise gespeichert würden. Das wäre aber Verschwendung! Besser ist es, eine angepasste Serialisierung zu verwenden:</p>
<p class="tabunter"><strong>Listing 17.37    </strong>java.util.ArrayList.java, Ausschnitt</p>
<div class="listing"><pre class="prettyprint">private void writeObject( ObjectOutputStream s ) throws IOException {
  int expectedModCount = modCount;
  s.defaultWriteObject();
  s.writeInt( elementData.length );
  for ( int i = 0; i &lt; size; i++ )
    s.writeObject( elementData[ i ] );

  if ( modCount != expectedModCount )
    throw new ConcurrentModificationException();
}

private void readObject( ObjectInputStream s ) throws IOException, 
    ClassNotFoundException {
  s.defaultReadObject();
  int arrayLength = s.readInt();
  Object[] a = elementData = (E[]) new Object[ arrayLength ];
  for ( int i = 0; i &lt; size; i++ )
    a[ i ] = s.readObject();
}</pre></div><a id="mjfcd0e0b26ebafe7b761d60df5980a4cd" name="mjfcd0e0b26ebafe7b761d60df5980a4cd"></a><a name="t39"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t310"></a><h3 class="t3"><span class="cfett">17.10.9</span> Probleme mit der Serialisierung  <img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"><a href="#t2t39"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Der klassische Weg von einem Objekt zu einer persistenten Speicherung führt über den Serialisierungsmechanismus von Java über die Klassen <span class="clisting">ObjectOutputStream</span> und <span class="clisting">ObjectInputStream</span>. Die Serialisierung in Binärdaten ist aber nicht ohne Nachteile. Schwierig ist beispielsweise die Weiterverarbeitung von Nicht-Java-Programmen oder die nachträgliche Änderung ohne Einlesen und Wiederaufbauen der Objektverbunde. Wünschenswert ist daher eine Text-repräsentation. Diese hat nicht die oben genannten Nachteile.</p>
<p>Ein weiteres Problem ist die Skalierbarkeit. Die Standard-Serialisierung arbeitet nach dem Prinzip: Alles, was vom Basisknoten aus erreichbar ist, gelangt serialisiert in den Datenstrom. Ist der Objektgraph sehr groß, steigen die Zeit für die Serialisierung und das Datenvolumen an. Anders als bei anderen Persistenz-Konzepten ist es nicht möglich, nur die Änderungen (die Differenz) zu schreiben. Wenn sich zum Beispiel in einer sehr großen Adressliste die Hausnummer einer Person ändert, muss die gesamte Adressliste neu geschrieben werden &#8211; das nagt an der Performance.</p>
<p>Auch parallele Änderungen können ein Problem sein, da die Serialisierung über kein transaktionales Konzept verfügt. Während der Serialisierung sind die Objekte und Datenstrukturen nicht gesperrt, und ein anderer Thread kann derweil alles Mögliche modifizieren. Der Entwickler muss sich selbst auferlegen, während des Schreibens keine Änderungen vorzunehmen, damit der Schreibzugriff isoliert ist. Auch wenn es während des Schreibens ein Problem (etwa eine Ausnahme) gibt, kommt ein halbfertiger Datenstrom beim Client an.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Bibliotheksdesign   </span>Heutzutage würden Bibliotheks-Designer keine Markierungsschnittstelle wie <span class="clisting">Serializable</span> mehr einführen, sondern eine Annotation deklarieren. Die Serialisierungs-ID würde dann auch nicht mehr eine private statische Variable mit einem magischen Variablennamen sein, sondern ein Attribut der Annotation, sodass es zum Beispiel an eine Klasse heißen würde: <span class="clisting">@Serializable(1234566778L)</span>. Markierungsschnittstellen haben noch ein anderes Problem, was mit der Endgültigkeit von Vererbung und Typen zu tun hat: Implementiert eine Klase einmal Serializable, so gilt diese Eigenschaft auch für alle Unterklassen, auch wenn vielleicht die Unterklassen gar nicht serialisierbar sein sollen. Auch hier lösen Annotationen das Problem, denn es lässt sich einstellen, ob Annotationen vererbt werden sollen oder nicht. Zu guter Letzt: Für transiente, also nicht serialisierte Zustände hätte kein Schlüsselwort in der Sprache reserviert werden müssen, sondern lediglich eine neue Annotation deklariert werden. Auch statt der magischen privaten Methoden <span class="clisting">readObject()</span>/<span class="clisting">writeObject()</span> hätte gut eine Annotation deklariert werden können, die eben die Methoden markieren, die bei der (De-)Serialisierung aufgerufen werden sollen.</p>
</td>
</tr>
</table><br><br><hr><a name="kommentar"></a><h3>Ihr Kommentar</h3>
                       Wie hat Ihnen das &lt;openbook&gt; gefallen? Wir freuen uns immer über Ihre freundlichen und kritischen Rückmeldungen.
                       <form action="http://www.galileo-press.de/feedback/openbook" method="post" style="text-align: center; margin-top: 10px;"><input type="hidden" name="openbookurl" value="javainsel9/.htm"><input type="hidden" name="buchtitel" value="Java ist auch eine Insel"><input type="hidden" name="Kapitel" value="17.10 Persistente Objekte und Serialisierung"><table border="0">
<tr>
<td><label for="name">Name</label><br></td>
<td><input type="text" name="name" id="name" size="40"><br></td>
</tr>
<tr>
<td><label for="email">E-Mail</label><br></td>
<td><input type="text" name="email" id="email" size="40"><br></td>
</tr>
<tr>
<td valign="top"><label for="comment">Ihr Kommentar</label><br></td>
<td><textarea name="comment" id="comment" rows="10" cols="40"></textarea><br></td>
</tr>
<tr>
<td>
</td>
<td><input type="submit" value="Kommentar absenden"></td>
</tr>
</table>
</form>
</div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="javainsel_17_009.htm" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a class="navnav" href="#">&lt;top&gt;</a></div></td>
<td align="right" width="25%"><div align="right"><a href="javainsel_17_011.htm" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
</table>
</div></td>
<td width="10" valign="top">  </td>
<td width="160" valign="top">
<table border="0" cellpadding="0" cellspacing="0" width="160">
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2">
&nbsp;<a href="http://www.galileocomputing.de/katalog/buecher/?GPP=opjiVIV" class="autor">
<strong>Zum Katalog</strong></a>

</td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2">
<img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV">
<img src="common/9783836215060_s.gif" width="119" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Java ist auch eine Insel" title="Zum Katalog: Java ist auch eine Insel">
<br><br><br><br><br><br><strong>Java ist auch eine Insel</strong><br><img src="common/pfeil_rechts5.gif" border="0" alt="">Jetzt bestellen</a><br /><br />
</td>
</tr>
</table>
</td>

</tr>
</table>
</td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2"><span class="autor"><strong>&nbsp;Ihre Meinung?</strong></a></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">

<table cellspacing="3">
<tr>
<td>Wie hat Ihnen das &lt;openbook&gt; gefallen?<br><a href="#kommentar"><img src="common/pfeil_rechts5.gif" border="0" alt="">Ihre Meinung</a>
<br><br></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>

<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>
<tr>
<td>
</td>
</tr>

<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2">&nbsp;<a href="http://www.galileocomputing.de/katalog/buecher/?GPP=opjiVIV" class="autor"><strong>Buchempfehlungen</strong></a></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2285?GPP=opjiVIV">
<img src="common/9783836215275_s.gif" width="102" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Computergeschichte(n) – nicht nur für Geeks" title="Zum Katalog: Computergeschichte(n) – nicht nur für Geeks"><br><br><br><br><br><br>&nbsp;Computergeschichte(n)<br>&nbsp;nicht nur für Geeks</a><br><br></td>
</tr>

<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/1949?GPP=opjiVIV">
<img src="common/9783836213080_s.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Java und XML" title="Zum Katalog: Java und XML"><br><br><br><br><br><br><br>&nbsp;Java und XML</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2346?GPP=opjiVIV">
<img src="common/9783836215688_s.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Einstieg in Java" title="Zum Katalog: Einstieg in Java"><br><br><br><br><br><br><br>&nbsp;Einstieg<br>&nbsp;in Java</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2051?GPP=opjiVIV">

<img src="common/9783836213677_s.gif" width="112" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Einstieg in XML" title="Zum Katalog: Einstieg in XML"><br><br><br><br><br><br><br>&nbsp;Einstieg<br>&nbsp;in XML</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2322?GPP=opjiVIV">
<img src="common/9783836215527_s.gif" width="112" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Visual C# 2010" title="Zum Katalog: Visual C# 2010"><br><br><br><br><br><br><br>&nbsp;Visual C# 2010</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2212?GPP=opjiVIV">
<img src="common/9783836214742_s.gif" width="119" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Professionell entwickeln mit Visual C# 2010" title="Zum Katalog: Professionell entwickeln mit Visual C# 2010"><br><br><br><br><br><br><br>&nbsp;Professionell<br>&nbsp;entwickeln mit<br>&nbsp;Visual C# 2010</a><br><br></td>
</tr>

<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2156?GPP=opjiVIV">
<img src="common/9783836214292_s.gif" width="108" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C++ von A bis Z" title="Zum Katalog: C++ von A bis Z"><br><br><br><br><br><br><br>&nbsp;C++ von A bis Z</a><br><br></td>
</tr>
</table></td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>

<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2"><span class="autor"><strong>&nbsp;Shopping</strong></span></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><b>Versandkostenfrei</b> bestellen in Deutschland und &Ouml;sterreich<br><a href="http://www.galileocomputing.de/hilfe/Shop/?GPP=opjiVIV"><img src="common/pfeil_rechts5.gif" border="0" alt="Info">Info</a><br><br></td>

</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table><br><br><hr width="70%" align="center">
<div align="center">
<p class="standard"><strong>Copyright © Galileo Press 2011</strong><br>
        Für Ihren privaten Gebrauch dürfen Sie die Online-Version natürlich ausdrucken.
        Ansonsten unterliegt das &lt;openbook&gt; denselben Bestimmungen, wie die
        gebundene Ausgabe: Das Werk einschließlich aller seiner Teile ist urheberrechtlich
        geschützt. Alle Rechte vorbehalten einschließlich der Vervielfältigung, Übersetzung,
        Mikroverfilmung sowie Einspeicherung und Verarbeitung in elektronischen Systemen.</p><br><a href="http://www.galileocomputing.de/">[Galileo Computing]</a><br><br>
      Galileo Press, Rheinwerkallee 4, 53227 Bonn, Tel.: 0228.42150.0, Fax 0228.42150.77, <a href="mailto:info@galileo-press.de">info@galileo-press.de</a></div><br><br></body>
</html>
