<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Galileo Computing :: Java ist auch eine Insel – 4.2 Strings und deren Anwendung</title>
<meta name="title" content="Galileo Computing :: Java ist auch eine Insel - 4.2 Strings und deren Anwendung">
<meta name="author" content="Christian Ullenboom ">
<meta name="publisher" content="Galileo Press 2011">
<meta name="copyright" content="Galileo Press 2011">
<meta name="Description" content="Java ist auch eine Insel - Das umfassende Handbuch – 4.2 Strings und deren Anwendung">
<meta name="audience" content="Alle">
<meta name="robots" content="INDEX,FOLLOW">
<meta http-equiv="content-language" content="de">
<link rel="stylesheet" type="text/css" href="common/galileo_open.css">
<link rel="prev" href=".htm">
<link rel="next" href=".htm"><script type="text/javascript"><!--
    function OpenWin(url,name,height,width)
    {
      var InfoWin = window.open(url,name,"directories=0,height="+height+",width=" + width + ",hotkeys=0,location=0,menubar=0,resizable=1,screenX=150,screenY=10,left=150,top=10,scrollbars=1,status=1,titlebar=0,toolbar=0");
      InfoWin.focus();
    }
    //--></script><link href="common/prettify.css" type="text/css" rel="stylesheet"><script type="text/javascript" src="common/prettify.js"></script></head>
<body vlink="#000099" link="#000099" alink="#000099" onload="prettyPrint()">
<table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#000066">
<tr>
<td height="74" valign="bottom" colspan="2"><a href="http://www.galileocomputing.de/katalog/openbook?GPP=opjiVIV"><img src="common/galileocomputing_openbook.gif" width="200" height="56" border="0" alt="Galileo Computing < openbook >" title="Galileo Computing < openbook >"></a></td>
<td width="80" height="74"><a href="http://www.galileocomputing.de/?GPP=opjiVIV"><img src="common/galileocomputing.gif" border="0" alt="Galileo Computing - Professionelle Bücher. Auch für Einsteiger." title="Galileo Computing - Professionelle Bücher. Auch für Einsteiger."></a></td>
</tr>
</table>
<div align="right"><a href="http://www.galileocomputing.de/?GPP=opjiVIV" class="navnav">Professionelle Bücher. Auch für Einsteiger.</a></div><br><table class="tbl" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="190" valign="top">
<table class="tbl1" border="0" cellpadding="3" cellspacing="0" width="190" align="left">
<tr>
<td class="tbl2"><a class="nav" href="index.htm#_top">Inhaltsverzeichnis</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_00_001.htm#mj58b119301920569a446c9c510503f310">Vorwort</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_01_001.htm#mja8fc5b7ad19fc7332bc66b09a8fda26e">1 Java ist auch eine Sprache</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_02_001.htm#mj313f67c98dc9ecaddfa2d8b80f057fd2">2 Sprachbeschreibung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_03_001.htm#mjcd3b5720e8605484942e3476a1075bdf">3 Klassen und Objekte</a></td>
</tr>
<tr>
<td><a class="navh" href="##mj71fbc84ad33a281b9352b0b19fae2fb2">4 Der Umgang mit Zeichenketten</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_05_001.htm#mj005cd8e604aefc3ae72b92880fcee5c6">5 Eigene Klassen schreiben</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_06_001.htm#mj6f6b47453043c38837bfc32154a97968">6 Exceptions</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_07_001.htm#mjc4a1f6f3499a02fb64fe89046739edca">7 Generics&lt;T&gt;</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_08_001.htm#mj46e914488628367f5dfc0a62c3a78a53">8 Äußere.innere Klassen</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_09_001.htm#mj94af2b90e8a2dad6c1ef67255f89a137">9 Besondere Klassen der Java SE</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_10_001.htm#mjcae20f50ffbc015d0b66861e7087af9b">10 Architektur, Design und angewandte Objektorientierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_11_001.htm#mj60bc6a007ae9b8657949f3e91d96df3d">11 Die Klassenbibliothek</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_12_001.htm#mj0ce00eb41aae2b084534019cf6edc3b6">12 Bits und Bytes und Mathematisches</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_13_001.htm#mj245f5f8d5a858b46462d64e9b9c0786b">13 Datenstrukturen und Algorithmen</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_14_001.htm#mj8c6f381221d805dd6fbe480731ac0c58">14 Threads und nebenläufige Programmierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_15_001.htm#mjbe3ed0989722396930966f95deeb2497">15 Raum und Zeit</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_16_001.htm#mj78bd405fb0de0cff099c06255fe36853">16 Dateien, Verzeichnisse und Dateizugriffe</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_17_001.htm#mjb420b02f4ccf65226f7271e48cefa05d">17 Datenströme</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_18_001.htm#mjedab16f1a9cc168eda4a24416359e0b9">18 Die eXtensible Markup Language (XML)</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_19_001.htm#mjc8f47f7f51ac3795c46c4544f391b02e">19 Grafische Oberflächen mit Swing</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_20_001.htm#mj25cc7d47e476b8b1a183a10ee741dbaa">20 Grafikprogrammierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_21_001.htm#mjea7bcdd596c8bd25b078a00221a01a75">21 Netzwerkprogrammierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_22_001.htm#mjde622db61608a627262a27ecb377d675">22 Verteilte Programmierung mit RMI</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_23_001.htm#mj23bf599d65364bcd05d06a34cb5593bf">23 JavaServer Pages und Servlets</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_24_001.htm#mja621f3b4a74c7fa576b4a58b1614041e">24 Datenbankmanagement mit JDBC</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_25_001.htm#mja2e217bf5724cc65eba184a2af8b79cf">25 Reflection und Annotationen</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_26_001.htm#mjb47dd6e0a309b7e78cad68f6b5de9319">26 Dienstprogramme für die Java-Umgebung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_27_001.htm#mjf59db36d9280a70e0d3d196e9bf160f5">A Die Begleit-DVD</a></td>
</tr>
<tr>
<td><a class="navnav" href="stichwort.htm#_top">Stichwort</a></td>
</tr>
<tr>
<td><br><a href="http://download2.galileo-press.de/openbook/galileocomputing_javainsel9.zip" class="navnav"><strong>Download:</strong><br>- ZIP, ca. 20,5 MB</a></td>
</tr>
<tr>
<td><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV" class="navnav">Buch bestellen</a></td>
</tr>
<tr>
<td><a class="navnav" href="#kommentar">Ihre Meinung?</a><br><br></td>
</tr>
</table>
</td>
<td width="10"><img src="common/spacer10.gif" width="10" height="10" alt="Spacer"></td>
<td width="85%" valign="top" align="center"><div align="center">
<table width="98%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="javainsel_04_001.htm" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a href="http://www.galileocomputing.de/?GPP=opjiVIV" class="navnav">Galileo Computing /</a><a href="http://www.galileocomputing.de/katalog/openbook/?GPP=opjiVIV" class="navnav"> &lt;openbook&gt; /</a><a href="index.htm" class="navnav"> Java-Insel</a></div></td>
<td align="right" width="25%"><div align="right"><a href="javainsel_04_003.htm" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" valign="top"><table width="100%" border="0" cellpadding="10" cellspacing="0" class="box">
<tr>
<td colspan="2"><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV" class="buchtitel">Java ist auch eine Insel</a><span class="autor"> von Christian Ullenboom </span><br><span class="untertitel">Das umfassende Handbuch</span></td>
</tr>
<tr>
<td valign="top" width="211"><dl>
<dt><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV" class="navnav"><img src="common/9783836215060.gif" border="0" alt="Buch: Java ist auch eine Insel" title="Buch: Java ist auch eine Insel"></a></dt>
<dd><br><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV"><span class="autor"><strong>Java ist auch eine Insel</strong><br>geb., mit DVD<br>1482 S., 49,90 Euro<br>Galileo Computing<br>ISBN 978-3-8362-1506-0</span></a></dd>
</dl></td>
<td width="80%"><table border="0">
<tr>
<td valign="baseline"><img src="common/pfeil_u.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="3" class="kap"><strong><a href="javainsel_04_001.htm#mj71fbc84ad33a281b9352b0b19fae2fb2" class="navnav">4 Der Umgang mit Zeichenketten</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_04_001.htm#mj5b63e17de6120d8f4db3409131f2a86c" class="navnav">4.1 Einzelne Zeichen behandeln</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_001.htm#mjc7f12843e36b26e5931db779648c134a" class="navnav">4.1.1 Von ASCII über ISO-8859-1 zu Unicode</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_001.htm#mj367a73ec9189cdf83cea885b4e5f492c" class="navnav">4.1.2 Die Character-Klasse</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="#mj1ce18a66f5cc0a95bbe689a9d8271a3d" class="navh">4.2 Strings und deren Anwendung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj87816fe537a5f78f1f0c0158b90c2bc8" class="navh">4.2.1 String-Literale als String-Objekte für konstante Zeichenketten</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj0deae7da940491bac63ca1ef16eb3552" class="navh">4.2.2 String-Länge und Test auf Leerstring</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjfb86382026187a557451c0b681ad1085" class="navh">4.2.3 Nach enthaltenen Zeichen und Zeichenfolgen suchen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj5ee730cda1f64998edf27bd440d36bf1" class="navh">4.2.4 Gut, dass wir verglichen haben</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjac0dccd09d1a2ec631387a6918cd6768" class="navh">4.2.5 Phonetische Vergleiche</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjc6bf6272c679c8daa6715a7e8985f1c6" class="navh">4.2.6 String-Teile extrahieren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjc18e7a29f3c160214dca9d72db9a1942" class="navh">4.2.7 Strings anhängen, Groß-/Kleinschreibung und Leerraum</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjcea37d75dba4d69967de4d1e249dbcc2" class="navh">4.2.8 Suchen und ersetzen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjae1154bac3cab076ee42a9a2dc61c6cc" class="navh">4.2.9 String-Objekte mit Konstruktoren neu anlegen *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_04_003.htm#mj267aa5287155844072bc1987dd3b46b3" class="navnav">4.3 Konvertieren zwischen Primitiven und Strings</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_003.htm#mj3f9f2b4d25b64111b3aba0aa049989ed" class="navnav">4.3.1 Unterschiedliche Typen in String-Repräsentationen konvertieren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_003.htm#mja9e33f55a33c59da61e960c2023780c1" class="navnav">4.3.2 Stringinhalt in primitiven Wert konvertieren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_003.htm#mj5a9a0a42e317bd6d405a3c8d0ba5d4f7" class="navnav">4.3.3 Unterschiedliche Ausgabeformate (Binär, Hex, Oktal) *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_04_004.htm#mjc49a6b30f15f92cfaa850a38756238c9" class="navnav">4.4 Veränderbare Zeichenketten mit StringBuilder und StringBuffer</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_004.htm#mj83f6ed07e8fdfe6af14e18edf6218235" class="navnav">4.4.1 Anlegen von StringBuilder/StringBuffer-Objekten</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_004.htm#mj0d68aa867da26c23ab1c863a6f9ed03d" class="navnav">4.4.2 StringBuilder/StringBuffer in andere Zeichenkettenformate konvertieren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_004.htm#mj3f07186fbf65f98df2b985234cc07990" class="navnav">4.4.3 Daten anhängen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_004.htm#mj993ba2d25f3b2f2cf18eedc1dbd7e5ca" class="navnav">4.4.4 Zeichen(folgen) setzen, erfragen, löschen und umdrehen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_004.htm#mj5dca8c7e847d7bbfeea8604976bebbf9" class="navnav">4.4.5 Länge und Kapazität eines StringBuilder/StringBuffer-Objekts *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_004.htm#mj49dcd52f127505866171474743dac369" class="navnav">4.4.6 Vergleichen von String mit StringBuilder und StringBuffer</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_004.htm#mjfcc09b72a35d873d5db103bdf4e4d1c3" class="navnav">4.4.7 »hashCode()« bei StringBuilder/StringBuffer *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_04_005.htm#mjc824d83eace3a6d1a6f009039461af93" class="navnav">4.5 CharSequence als Basistyp *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_04_006.htm#mj99de4087a46a9de05745fee5e80eb080" class="navnav">4.6 Sprachabhängiges Vergleichen und Normalisierung *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_006.htm#mje5efed3fcaf2a5c0e494ccbc901ac5d4" class="navnav">4.6.1 Die Klasse »Collator«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_006.htm#mjdc835aa7b61dc6f449d3d4cd1d3f2871" class="navnav">4.6.2 Effiziente interne Speicherung für die Sortierung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_006.htm#mjffb5d2a9021a5520cecfe6f6b589bff5" class="navnav">4.6.3 Normalisierung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_04_007.htm#mj26fc5cf60311afbddd72295cdd646a48" class="navnav">4.7 Reguläre Ausdrücke</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_007.htm#mjd5b5d84cb3f1b5bcb7638ea9221a491f" class="navnav">4.7.1 Arbeiten mit der Fassade: String#matches()</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_007.htm#mj10b152411c18f403a01181de6805ffab" class="navnav">4.7.2 Die Klassen Pattern und Matcher</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_007.htm#mjf7cf6ba5fe7a1ff4534771fe3acdcb82" class="navnav">4.7.3 Finden und nicht matchen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_007.htm#mjec24b38a489c334c89e79b5d93a7407c" class="navnav">4.7.4 Gierige und nicht gierige Operatoren *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_007.htm#mj2895cc789e3750872721abe1a018c166" class="navnav">4.7.5 Mit MatchResult alle Ergebnisse einsammeln *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_007.htm#mj1abbf8af8df05805ee6bdc65f332be5c" class="navnav">4.7.6 Suchen und Ersetzen mit Mustern</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_04_008.htm#mjea76920fd083ba12b49068b2113a5f62" class="navnav">4.8 Zerlegen von Zeichenketten</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_008.htm#mj8173df624dd4e503133672215a4fb5b2" class="navnav">4.8.1 Splitten von Zeichenketten mit »split()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_008.htm#mj93a3cb6f9d58defedbc989a780cf6c99" class="navnav">4.8.2 Die Klasse Scanner</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_008.htm#mj1f9dc3aad0907a177bf204b21eae4ddd" class="navnav">4.8.3 Die Klasse StringTokenizer *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_008.htm#mja636105fd65ffad38a6c118a42268154" class="navnav">4.8.4 BreakIterator als Zeichen-, Wort-, Zeilen- und Satztrenner *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_04_009.htm#mj8ef58986d2961c26b8707c1a8afb4d11" class="navnav">4.9 Zeichenkodierungen, XML/HTML-Entitys, Base64 *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_009.htm#mjb87cc00c80880e927ff29ee8ce0e1f50" class="navnav">4.9.1 Unicode und 8-Bit-Abbildungen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_009.htm#mjf513be2231479f85d1af7ab5d6f80a8b" class="navnav">4.9.2 Konvertieren mit »OutputStreamWriter«-Klassen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_009.htm#mje99d09ac96d967c3bb0d030f145ec3b3" class="navnav">4.9.3 Das Paket »java.nio.charset«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_009.htm#mj449273bd5294b09262f137915733a778" class="navnav">4.9.4 XML/HTML-Entitys ausmaskieren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_009.htm#mj19dbf52792d98cd964b1133e5108ec63" class="navnav">4.9.5 Base64-Kodierung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_04_010.htm#mj53b74ba10bc69f50ef35fec994a0e0cf" class="navnav">4.10 Ausgaben formatieren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_010.htm#mj858fbf1c224f5da2028e472edf93dba4" class="navnav">4.10.1 Formatieren und Ausgeben mit »format()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_010.htm#mj87b0fa4e81f1eed16d205ce033d86124" class="navnav">4.10.2 Die Formatter-Klasse *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_010.htm#mjcb99bccbb69f33858ae88eb50f4973fc" class="navnav">4.10.3 Formatieren mit Masken *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_010.htm#mjf3f02de332c4f2de75442068ee669fef" class="navnav">4.10.4 Format-Klassen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_04_010.htm#mj8ba0378eee002645ede566d73c70c8f0" class="navnav">4.10.5 Zahlen, Prozente und Währungen mit »NumberFormat« und »DecimalFormat« formatieren *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_04_011.htm#mjf6c9a513b65380464457c07fcb456181" class="navnav">4.11 Zum Weiterlesen</a></strong></td>
</tr>
</table><br></td>
</tr>
</table>
<table width="100%" cellpadding="20" cellspacing="0" border="0" bgcolor="#eeeeee">
<tr>
<td><div class="main"><a id="mj1ce18a66f5cc0a95bbe689a9d8271a3d" name="mj1ce18a66f5cc0a95bbe689a9d8271a3d"></a><a name="t21"></a><a name="t2t31"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div>
<h2 class="t2"><span class="cfett">4.2</span> Strings und deren Anwendung  <a href="#t2t32"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><img src="common/15x15leer.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></h2>
<p>Ein String ist eine Sammlung von Zeichen (Datentyp <span class="clisting">char</span>), die die Laufzeitumgebung geordnet im Speicher ablegt. Die Zeichen sind einem Zeichensatz entnommen, der in Java dem 16-Bit-Unicode-Standard entspricht &#8211; mit einigen Umwegen ist auch Unicode 4 mit 32-Bit-Zeichen möglich.</p>
<p>Java sieht drei Klassen vor, die Zeichenfolgen verwalten. Sie unterscheiden sich in drei Punkten: Sind die Zeichenfolgen unveränderbar (<span class="ckursiv">immutable</span>) oder veränderbar (<span class="ckursiv">mutable</span>), und sind die Operationen auf den Zeichenketten gegen nebenläufige Zugriffe aus mehreren Threads abgesichert?</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 4.2    </strong>Die drei Klassen, die Zeichenfolgen verwalten</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett"> </span>
</td>
<td class="tabellenkopf"><span class="cfett">Verwaltet immutable Zeichenketten</span>
</td>
<td class="tabellenkopf"><span class="cfett">Verwaltet mutable Zeichenketten</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="cfett">Threadsicher</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">String</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">StringBuffer</span></p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="cfett">Nicht threadsicher</span></p>
</td>
<td class="tabellentext">
<p>-</p>
</td>
<td class="tabellentext">
<p><span class="clisting">StringBuilder</span></p>
</td>
</tr>
</table><br><p>Die Klasse <span class="clisting">String</span> repräsentiert nicht änderbare Zeichenketten. (Allgemein heißen Objekte, deren Zustand sich nicht verändern lässt, <span class="ckursiv">immutable</span><span class="ckursiv">.</span>) Daher ist ein <span class="clisting">String</span> immer threadsicher, denn eine Synchronisation ist nur dann nötig, wenn es Änderungen geben kann. Mit Objekten vom Typ <span class="clisting">String</span> lässt sich nach Zeichen oder Teilzeichenketten suchen, und ein String lässt sich mit einem anderen String vergleichen, aber Zeichen im String können nicht verändert werden. Es gibt einige Methoden, die scheinbar Veränderungen an Strings vornehmen, aber sie erzeugen in Wahrheit neue <span class="clisting">String</span>-Objekte, die die veränderten Zeichenreihen repräsentieren. So entsteht beim Aneinanderhängen zweier String-Objekte als Ergebnis ein drittes String-Objekt für die zusammengefügte Zeichenreihe.</p>
<p>Die Klassen <span class="clisting">StringBuilder</span> und <span class="clisting">StringBuffer</span> repräsentieren im Gegensatz zu <span class="clisting">String</span> dynamische, beliebig änderbare Zeichenreihen. Der Unterschied zwischen den API-gleichen Klassen ist, dass <span class="clisting">StringBuffer</span> vor nebenläufigen Operationen geschützt ist, <span class="clisting">StringBuilder</span> nicht. Die Unterscheidung ist bei String nicht nötig, denn wenn Objekte nachträglich nicht veränderbar sind, machen parallele Lesezugriffe keine Schwierigkeiten.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>String-Objekte selbst lassen sich nicht verändern, aber natürlich lässt sich eine Referenz auf ein anderes String-Objekt legen:</p>
<div class="listing"><pre class="prettyprint">String s = "tutego";
s = "TUTEGO";</pre></div>
</td>
</tr>
</table><br><p>Die Klassen entsprechen der idealen Umsetzung der objektorientierten Idee (mit der wir uns in Kapitel 5, »Eigene Klassen schreiben«, intensiv auseinandersetzen): Die Daten sind gekapselt, das heißt, die tatsächliche Zeichenkette ist in der Klasse als privates <span class="clisting">char</span>-Array gegen Zugriffe von außen gesichert, und selbst die Länge ist ein privates Attribut der Klasse, die nur über eine Methode zugänglich ist. Die Klassen nehmen uns also die lästige Arbeit ab, selbst Zeichenfolgen in Feldern verwalten zu müssen.</p>
<h4 class="t4">String: Eine Klasse mit bevorzugter Behandlung</h4>
<p>Die Entwickler von Java haben eine Symbiose zwischen dem String als Objekt und dem String als eingebautem Datentyp vorgenommen. Die Sprache ermöglicht zwar die direkte Konstruktion von String-Objekten etwa aus String-Literalen (Zeichenketten in doppelten Anführungszeichen) und die Konkatenation (Aneinanderreihung von Strings mit +) von mehreren Strings, doch intern ist die Aneinanderreihung über Methoden der Klassen <span class="clisting">String</span>, <span class="clisting">StringBuilder</span> beziehungsweise <span class="clisting">StringBuffer</span> realisiert. Mit dem Plus auf <span class="clisting">String</span>-Objekten ist also ein besonderer Operator auf der Klasse <span class="clisting">String</span> definiert, der nicht eigenständig auf anderen Klassen definiert werden kann. Java unterstützt keine überladenen Operatoren für Klassen, und dieses Plus ist ein Abweichler.</p>
<div class="bildbox">
<p><a name="IDAXN0D"></a><a onClick="OpenWin('bilder/stringuml.gif','Abbildung',800,800)"><img border="0" src="bilderklein/kleinstringuml.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div><a id="mj87816fe537a5f78f1f0c0158b90c2bc8" name="mj87816fe537a5f78f1f0c0158b90c2bc8"></a><a name="t31"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t32"></a><h3 class="t3"><span class="cfett">4.2.1</span> String-Literale als String-Objekte für konstante Zeichenketten  <a href="#t2t33"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t31"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Damit wir Zeichenketten nutzen können, muss ein Objekt der Klasse <span class="clisting">String</span> oder <span class="clisting">StringBuilder</span>/<span class="clisting">StringBuffer</span> erzeugt worden sein. Nutzen wir String-Literale, so müssen wir die String-Objekte nicht von Hand mit <span class="clisting">new</span> erzeugen, denn ein Ausdruck in doppelten Anführungszeichen ist schon automatisch ein String-Objekt. Das bedeutet auch, dass hinter dem String-Literal gleich ein Punkt für den Methodenaufruf stehen kann.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span><span class="clisting">"Hi Chris".length()</span> liefert die Länge der Zeichenkette. Das Ergebnis ist 8. Leerzeichen und Sonderzeichen zählen mit.</p>
</td>
</tr>
</table><br><a id="mj0deae7da940491bac63ca1ef16eb3552" name="mj0deae7da940491bac63ca1ef16eb3552"></a><a name="t32"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t33"></a><h3 class="t3"><span class="cfett">4.2.2</span> String-Länge und Test auf Leerstring  <a href="#t2t34"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t32"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>String-Objekte verwalten intern die Zeichenreihe, die sie repräsentieren, und bieten eine Vielzahl von Methoden, um die Eigenschaften des Objekts preiszugeben. Eine Methode haben wir schon benutzt: <span class="clisting">length()</span>. Für String-Objekte ist diese so implementiert, dass die Anzahl der Zeichen im String (die Länge des Strings) zurückgegeben wird. Um herauszufinden, ob der String keine Zeichen hat, lässt sich neben <span class="clisting">length() == 0</span> auch die Methode <span class="clisting">isEmpty()</span> nutzen:</p>
<p class="tabunter"><strong>Listing 4.4    </strong>LengthAndEmptyDemo.java, main()</p>
<div class="listing"><pre class="prettyprint">System.out.println( "".<span class="cfett">length()</span> );   // 0
System.out.println( "".<span class="cfett">isEmpty()</span> );  // true
System.out.println( " ".<span class="cfett">length()</span> );  // 1
System.out.println( " ".<span class="cfett">isEmpty()</span> ); // false
String s = null;
System.out.println( s.<span class="cfett">length()</span> );    // <img src="common/totenkopf.gif" border="0" align="bottom" alt="Fehler"> NullPointerException
System.out.println( s.<span class="cfett">isEmpty()</span> );   // <img src="common/totenkopf.gif" border="0" align="bottom" alt="Fehler"> NullPointerException</pre></div><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Während das .NET-Framework etwa die statische Member-Funktion <span class="clisting">IsNullOrEmpty(String)</span> anbietet, um zu testen, ob die übergebene Referenz <span class="clisting">null</span> oder die Zeichenkette leer ist, so muss das in Java getrennt getestet werden. Hier ist eine eigene statische Utility-Methode praktisch:</p>
<p class="tabunter"><strong>Listing 4.5    </strong>LengthAndEmptyDemo.java, isNullOrEmpty()</p>
<div class="listing"><pre class="prettyprint">/**
 * Checks if a String is {@code null} or empty ({@code ""}).
 *
 * &lt;pre&gt;
 * StringUtils.isEmpty(null) == true
 * StringUtils.isEmpty(&amp;quot;&amp;quot;) == true
 * StringUtils.isEmpty(&amp;quot; &amp;quot;) == false
 * StringUtils.isEmpty(&amp;quot;bob&amp;quot;) == false
 * StringUtils.isEmpty(&amp;quot; bob &amp;quot;) == false
 * &lt;/pre&gt;
 *
 * @param str The String to check, may be {@code null}.</pre></div>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint"> * @return {@code true} if the String is empty or {@code null}, 
 * {@code false} otherwise.
 */
public static boolean isNullOrEmpty( String str )
{
  return str == null || str.length() == 0;
}
Ob der String nur aus Leerzeichen besteht, testet die Methode nicht.</pre></div>
</td>
</tr>
</table><br><a id="mjfb86382026187a557451c0b681ad1085" name="mjfb86382026187a557451c0b681ad1085"></a><a name="t33"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t34"></a><h3 class="t3"><span class="cfett">4.2.3</span> Nach enthaltenen Zeichen und Zeichenfolgen suchen  <a href="#t2t35"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t33"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Die Objektmethode <span class="clisting">contains(CharSequence)</span> testet, ob ein <span class="ckursiv">Teilstring</span> (engl. <span class="ckursiv">substring</span>) in der Zeichenkette vorkommt, und liefert <span class="clisting">true</span>, wenn das der Fall ist. <span class="clisting">CharSequence</span> ist unter anderem die gemeinsame Schnittstelle von <span class="clisting">String</span>, <span class="clisting">StringBuilder</span> und <span class="clisting">StringBuffer</span>. Das heißt, dass wir beim gewünschten Typ <span class="clisting">CharSequence</span> immer Exemplare von etwa <span class="clisting">String</span>, <span class="clisting">StringBuilder</span>/<span class="clisting">StringBuffer</span> übergeben können.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Wenn im String <span class="clisting">s</span> das Spam-Wort »Viagra« vorkommt, gehe in den Rumpf:</p>
<div class="listing"><pre class="prettyprint">if ( s.<span class="cfett">contains</span>( "Viagra" ) )
  ...</pre></div>
</td>
</tr>
</table><br><p>Groß-/Kleinschreibung ist relevant.</p>
<h4 class="t4">Fundstelle mit »indexOf()« zurückgeben</h4>
<p>Die Methode <span class="clisting">contains()</span> ist <span class="ckursiv">nicht</span> mit einem <span class="clisting">char</span> überladen, kann also nicht nach einem einzelnen Zeichen suchen, es sei denn, der String bestünde nur aus einem Zeichen. Dazu ist <span class="clisting">indexOf()</span> in der Lage: Die Methode liefert die Fundstelle eines Zeichens beziehungsweise Teilstrings. Findet <span class="clisting">indexOf()</span> nichts, liefert sie &#8211;1.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Ein Zeichen mit <span class="clisting">indexOf()</span> suchen:</p>
<div class="listing"><pre class="prettyprint">String s = "Ernest Gräfenberg";
int index1 = s.<span class="cfett">indexOf</span>( 'e' );                     // 3
int index2 = s.<span class="cfett">indexOf</span>( 'e', index1 + 1 );         // 11</pre></div>
<p class="BStandard">Die Belegung von <span class="clisting">index1</span> ist 3, da an der Position 3 das erste Mal ein <span class="clisting">'e'</span> vorkommt. Die zweite Methode <span class="clisting">indexOf()</span> sucht mit dem zweiten Ausdruck <span class="clisting">index1 + 1</span> ab der Stelle 4 weiter. Das Resultat ist 11.</p>
</td>
</tr>
</table><br><p>Wie <span class="clisting">contains()</span> unterscheidet die Suche zwischen Groß- und Kleinschreibung. Die Zeichen in einem String sind wie Array-Elemente ab 0 durchnummeriert. Ist der Index kleiner 0, so wird dies ignoriert und automatisch auf 0 gesetzt.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Beschreibt das Zeichen <span class="clisting">c</span> ein Escape-Zeichen, etwa einen Tabulator oder ein Return, dann soll die Bearbeitung weitergeführt werden:</p>
<div class="listing"><pre class="prettyprint">if ( "\b\t\n\f\r\"\\".<span class="cfett">indexOf(c)</span> &gt;= 0 ) {
  ...
}</pre></div>
<p class="BStandard"><span class="clisting">contains()</span> konnten wir nicht verwenden, da der Parametertyp nur <span class="clisting">CharSequence</span>, aber kein <span class="clisting">char</span> ist.</p>
</td>
</tr>
</table><br><p>Die <span class="clisting">indexOf()</span>-Methode ist nicht nur mit <span class="clisting">char</span> parametrisiert, sondern auch mit <span class="clisting">String [</span>Der Parametertyp <span class="clisting">String</span> erlaubt natürlich nur Objekte vom Typ <span class="clisting">String</span>, und Unterklassen von <span class="clisting">String</span> gibt es nicht. Allerdings gibt es andere Klassen in Java, die Zeichenfolgen beschreiben, etwa <span class="clisting">StringBuilder</span> oder <span class="clisting">StringBuffer</span>. Diese Typen unterstützt die <span class="clisting">indexOf()</span>-Methode nicht. Das ist schade, denn <span class="clisting">indexOf()</span> hätte statt <span class="clisting">String</span> durchaus einen allgemeineren Typ <span class="clisting">CharSequence</span> erwarten können, den String sowie <span class="clisting">StringBuilder</span>/<span class="clisting">StringBuffer</span> implementieren (zu dieser Schnittstelle später mehr).
] , um nach ganzen Zeichenfolgen zu suchen und die Startposition zurückzugeben.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span><span class="clisting">indexOf()</span> mit der Suche nach einem Teilstring:</p>
<div class="listing"><pre class="prettyprint">String str = "In Deutschland gibt es immer noch ein Ruhrgebiet, " +
             "obwohl es diese Krankheit schon lange nicht mehr geben soll.";
String s = "es";
int index = str.<span class="cfett">indexOf</span>( s, str.indexOf(s) + 1 );       // 57</pre></div>
<p class="BStandard">Die nächste Suchposition wird ausgehend von der alten Finderposition errechnet. Das Ergebnis ist 57, da dort zum zweiten Mal das Wort »es« auftaucht.</p>
</td>
</tr>
</table><br><h4 class="t4">Vom Ende an suchen</h4>
<p>Genauso wie am Anfang gesucht werden kann, ist es auch möglich, am Ende zu beginnen.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Hierzu dient die Methode <span class="clisting">lastIndexOf()</span>:</p>
<div class="listing"><pre class="prettyprint">String str = "May the F<span class="cfett">o</span>rce be with y<span class="cfett">o</span>u.";
int index  = str.<span class="cfett">lastIndexOf</span>( 'o' );                 // 23</pre></div>
<p class="BStandard">Genauso wie bei <span class="clisting">indexOf()</span> existiert eine überladene Version, die rückwärts ab einer bestimmten Stelle nach dem nächsten Vorkommen von »a« sucht. Wir schreiben:</p>
<div class="listing"><pre class="prettyprint">index = str.lastIndexOf( 'o', index &#8211; 1 );          // 9</pre></div>
</td>
</tr>
</table><br><p>Die Parameter der <span class="clisting">char</span>-orientierten Methoden <span class="clisting">indexOf()</span> und <span class="clisting">lastIndexOf()</span> sind alle vom Typ <span class="clisting">int</span> und nicht, wie man spontan erwarten könnte, vom Typ <span class="clisting">char</span> und <span class="clisting">int</span>. Das zu suchende Zeichen wird als erstes <span class="clisting">int</span>-Argument übergeben. Die Umwandlung des <span class="clisting">char</span> in ein <span class="clisting">int</span> nimmt der Java-Compiler automatisch vor, sodass dies nicht weiter auffällt. Bedauerlicherweise kann es dadurch aber zu Verwechslungen bei der Reihenfolge der Argumente kommen: Bei <span class="clisting">s.indexOf(start, c)</span> wird der erste Parameter <span class="clisting">start</span> als Zeichen interpretiert und das gewünschte Zeichen <span class="clisting">c</span> als Startposition der Suche.</p>
<h4 class="t4">Anzahl Teilstrings einer Zeichenkette</h4>
<p>Bisher bietet die Java-Bibliothek keine direkte Methode, um die Anzahl Teilstrings einer Zeichenkette herauszufinden. Eine solche Methode ist jedoch schnell geschrieben:</p>
<p class="tabunter"><strong>Listing 4.6    </strong>CountMatches.java, frequency()</p>
<div class="listing"><pre class="prettyprint">static int frequency( String source, String part )
{
  if ( source == null || source.isEmpty() || part == null || part.isEmpty() )
    return 0;

  int count = 0;

  for ( int pos = 0; (pos = source.indexOf( part, pos )) != &#8211;1; count++ )
    pos += part.length();

  return count;
}</pre></div><a id="mj5ee730cda1f64998edf27bd440d36bf1" name="mj5ee730cda1f64998edf27bd440d36bf1"></a><a name="t34"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t35"></a><h3 class="t3"><span class="cfett">4.2.4</span> Gut, dass wir verglichen haben  <a href="#t2t36"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t34"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Um Strings zu vergleichen, gibt es viele Möglichkeiten und Optionen:</p>
<ul class="gp">
<li><span class="clisting">equals()</span> achtet auf absolute Übereinstimmung, und <span class="clisting">equalsIgnoreCase()</span> ist für einen Vergleich zu haben, der unabhängig von der Groß-/Kleinschreibung ist.</li>
</ul>
<ul class="gp">
<li>Seit Java 7 erlaubt <span class="clisting">switch</span> den Vergleich von <span class="clisting">String</span>-Objekten mit einer Liste von Sprungzielen. Der Vergleich wird intern mit <span class="clisting">equals()</span> durchgeführt.</li>
</ul>
<ul class="gp">
<li>Ob ein String mit einem Wort beginnt oder endet, sagen <span class="clisting">startsWith()</span> und <span class="clisting">endsWith()</span>.</li>
</ul>
<ul class="gp">
<li>Zum Vergleichen von Teilen gibt es <span class="clisting">regionMatches()</span>, eine Methode, die auch unabhängig von der Groß-/Kleinschreibung arbeiten kann.</li>
</ul>
<ul class="gp">
<li>Ist eine Übereinstimmung mit einem regulären Ausdruck gewünscht, hilft <span class="clisting">matches()</span>.</li>
</ul>
<h4 class="t4">Die Methode »equals()«</h4>
<p>Als Erstes gibt es die aus der Klasse <span class="clisting">Object</span> geerbte und in der Klasse <span class="clisting">String</span> überschriebene Methode <span class="clisting">equals()</span>. Die Methode gibt <span class="clisting">true</span> zurück, falls die Strings gleich lang sind und Zeichen für Zeichen übereinstimmen.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Während die allermeisten Skript-Sprachen und auch C# Zeichenkettenvergleiche mit <span class="clisting">==</span> erlauben, ist die Semantik für Java immer eindeutig: Der Vergleich mit <span class="clisting">==</span> ist nur dann wahr, wenn die beiden Referenzen gleich sind, also zwei String-Objekte identisch sind; die Gleichheit reicht nicht aus.</p>
</td>
</tr>
</table><br><p>Dazu ein Beispiel. Bei dem Vergleich mit <span class="clisting">==</span> ist das Ergebnis ein anderes als mit <span class="clisting">equals()</span>:</p>
<p class="tabunter"><strong>Listing 4.7    </strong>EqualsDemo.java, main()</p>
<div class="listing"><pre class="prettyprint">String input = javax.swing.JOptionPane.showInputDialog( "Passwort" );
System.out.println( input<span class="cfett"> ==</span> "heinzelmann" );              //    (1)
System.out.println( input.<span class="cfett">equals</span>( "heinzelmann" ) );       //    (2.1)
System.out.println( "heinzelmann".<span class="cfett">equals</span>( input ) );       //    (2.2)</pre></div>
<p>Unter der Annahme, dass <span class="clisting">input</span> die Zeichenkette »heinzelmann« referenziert, ergibt der Vergleich (1) über <span class="clisting">==</span> den Wert <span class="clisting">false</span>, da das von <span class="clisting">showInputDialog()</span> gelieferte <span class="clisting">String</span>-Objekt ein ganz anderes ist als das, was uns die virtuelle Maschine für den Test bereitstellt (später dazu mehr). Nur der <span class="clisting">equals()</span>-Vergleich (2.1) und (2.2) ist hier korrekt, da hier die puren Zeichen verglichen werden, und die sind dann gleich.</p>
<p>Grundsätzlich sind Variante (2.1) und (2.2) gleich, da <span class="clisting">equals()</span> symmetrisch ist. Doch gibt es einen Vorteil bei (2.2), denn da kann <span class="clisting">input</span> auch <span class="clisting">null</span> sein, und es gibt nicht wie bei (2.1) eine <span class="clisting">NullPointerException</span>.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Beim <span class="clisting">equals()</span>-Vergleich spielen alle Zeichen eine Rolle, auch wenn sie nicht sichtbar sind. So führen folgende Vergleiche zum <span class="clisting">false</span>:</p>
<div class="listing"><pre class="prettyprint">System.out.println( <span class="cfett">"\t"</span>.equals( <span class="cfett">"\n"</span> ) );              // false
System.out.println( <span class="cfett">"\t"</span>.equals( <span class="cfett">"\t "</span> ) );             // false
System.out.println( <span class="cfett">"\u0000"</span>.equals( <span class="cfett">"\u0000\u0000"</span> ) );// false</pre></div>
</td>
</tr>
</table><br><h4 class="t4">Die Methode »equalsIgnoreCase()«</h4>
<p><span class="clisting">equals()</span> beachtet beim Vergleich die Groß- und Kleinschreibung. Mit <span class="clisting">equalsIgnoreCase()</span> bietet die Java-Bibliothek eine zusätzliche Methode, um Zeichenketten ohne Beachtung der Groß-/Kleinschreibung zu vergleichen.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span><span class="clisting">equals()</span> liefert für <span class="clisting">result1</span> den Wert <span class="clisting">false</span>, und <span class="clisting">equalsIgnoreCase()</span> liefert für <span class="clisting">result2</span> den Wert <span class="clisting">true</span>:</p>
<div class="listing"><pre class="prettyprint">String str = "REISEPASS";
boolean result1 = str.<span class="cfett">equals</span>( "Reisepass" );             // false
boolean result2 = str.<span class="cfett">equalsIgnoreCase</span>( "ReISePaSs" );   // true</pre></div>
</td>
</tr>
</table><br><p>Eine kleine Anmerkung noch: Die Implementierung von <span class="clisting">equalsIgnoreCase()</span> basiert intern darauf, beide Zeichnenfolgen abzulaufen, einzelne Zeichen in Großbuchstaben zu konvertieren und dann zu prüfen, ob die beiden Großbuchstaben gleich sind. Das ist wichtig, denn das führt dazu, dass</p>
<div class="listing"><pre class="prettyprint">System.out.println( "naß".toUpperCase().equals("NASS".toUpperCase()) ); // true
System.out.println( "NASS".toUpperCase().equals("naß".toUpperCase()) ); // true</pre></div>
<p>nicht identisch mit der folgenden Variante ist:</p>
<div class="listing"><pre class="prettyprint">System.out.println( "naß".equalsIgnoreCase("NASS") );                   // false
System.out.println( "NASS".equalsIgnoreCase("naß") )                    // false</pre></div>
<p>Da <span class="clisting">Character.toUpperCase('ß')</span> wieder ß ist, kann »naß« nicht »NASS« sein.</p>
<h4 class="t4">Lexikografische Vergleiche mit größer/kleiner-Relation</h4>
<p>Wie <span class="clisting">equals()</span> und <span class="clisting">equalsIgnoreCase()</span> vergleichen auch die Methoden <span class="clisting">compareTo(String)</span> und <span class="clisting">compareToIgnoreCase(String)</span> den aktuellen String mit einem anderen String. Nur ist der Rückgabewert von <span class="clisting">compareTo()</span> kein <span class="clisting">boolean</span>, sondern ein <span class="clisting">int</span>. Das Ergebnis signalisiert, ob das Argument lexikografisch kleiner oder größer als das String-Objekt ist beziehungsweise mit diesem übereinstimmt. Das ist zum Beispiel in einer Sortiermethode wichtig. Der Sortieralgorithmus muss beim Vergleich zweier Strings wissen, wie sie einzusortieren sind.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Drei Strings in ihrer lexikografischen Ordnung. Alle Vergleiche ergeben <span class="clisting">true</span>:</p>
<div class="listing"><pre class="prettyprint">System.out.println( "Justus".compareTo( "Bob" )    &gt; 0 );
System.out.println( "Justus".compareTo( "Justus" ) == 0 );
System.out.println( "Justus".compareTo( "Peter" )  &lt; 0 );</pre></div>
<p class="BStandard">Da im ersten Fall »Justus» lexikografisch größer ist als »Bob«, ist die numerische Rückgabe der Methode <span class="clisting">compareTo()</span> größer 0.</p>
</td>
</tr>
</table><br><p>Der von <span class="clisting">compareTo()</span> vorgenommene Vergleich basiert nur auf der internen numerischen Kodierung der Unicode-Zeichen. Dabei berücksichtigt <span class="clisting">compareTo()</span> nicht die landestypischen Besonderheiten, etwa die übliche Behandlung der deutschen Umlaute. Dafür müssten wir <span class="clisting">Collator</span>-Klassen nutzen, die später in diesem Kapitel vorgestellt werden.</p>
<p><span class="clisting">compareToIgnoreCase()</span> ist vergleichbar mit <span class="clisting">equalsIgnoreCase()</span>, bei der die Groß-/Kleinschreibung keine Rolle spielt.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Das JDK implementiert <span class="clisting">compareToIgnoreCase()</span> mit einem <span class="clisting">Comparator&lt;String&gt;</span>, der zwei beliebige Zeichenketten in eine Reihenfolge bringt. Der <span class="clisting">Comparator&lt;String&gt;</span> ist auch für uns zugänglich als statische Varible <span class="clisting">CASE_INSENSITIVE_ORDER</span>. Er ist zum Beispiel praktisch für sortierte Mengen, bei denen die Groß-/Kleinschreibung keine Rolle spielt. Comperatoren werden genauer in Abschnitt 9.1, »Vergleichen von Objekten«, vorgestellt.</p>
</td>
</tr>
</table><br><h4 class="t4">Endet der String mit ..., beginnt er mit ...?</h4>
<p>Interessiert uns, ob der String mit einer bestimmten Zeichenfolge beginnt (wir wollen dies <span class="ckursiv">Präfix</span> nennen), so rufen wir die <span class="clisting">startsWith()</span>-Methode auf. Eine ähnliche Methode gibt es für <span class="ckursiv">Suffixe</span>: <span class="clisting">endsWith()</span>. Sie überprüft, ob ein String mit einer Zeichenfolge am Ende übereinstimmt.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Teste mit <span class="clisting">endsWith()</span> eine Dateinamenendung und mit <span class="clisting">startsWith()</span> eine Ansprache:</p>
<div class="listing"><pre class="prettyprint">String  filename = "die besten stellungen (im schach).txt";
boolean isTxt  = filename.<span class="cfett">endsWith</span>( ".txt" );                // true
String email = "Sehr geehrte Frau Müller,\ndanke für Ihr Angebot.";
boolean isMale = email.<span class="cfett">startsWith</span>( "Sehr geehrter Herr" );   // false</pre></div>
</td>
</tr>
</table><br><h4 class="t4">String-Teile mit »regionMatches()« vergleichen *</h4>
<p>Eine Erweiterung der Ganz-oder-gar-nicht-Vergleichsmethoden bietet <span class="clisting">regionMatches()</span>, die Teile einer Zeichenkette mit Teilen einer anderen vergleicht. Nimmt das erste Argument von <span class="clisting">regionMatches()</span> den Wahrheitswert <span class="clisting">true</span> an, dann spielt die Groß-/Kleinschreibung keine Rolle &#8211; damit lässt sich dann auch ein <span class="clisting">startsWith()</span> und <span class="clisting">endsWith()</span> mit Vergleichen unabhängig von der Groß-/Kleinschreibung durchführen. Der Rückgabewert ist wie bei <span class="clisting">equalsXXX()</span> ein <span class="clisting">boolean</span>.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Der Aufruf von <span class="clisting">regionMatches()</span> ergibt <span class="clisting">true</span>.</p>
<div class="listing"><pre class="prettyprint">String s = "Deutsche <span class="cfett">Kinder</span> sind zu dick";
boolean b = s.<span class="cfett">regionMatches</span>( 9, "Bewegungsarmut bei <span class="cfett">Kinder</span>n", 19, 6 );</pre></div>
</td>
</tr>
</table><br><p>Die Methode beginnt den Vergleich am neunten Zeichen, also bei »K« im String <span class="clisting">s</span>, und dem 19. Buchstaben in dem Vergleichsstring, ebenfalls ein »K«. Dabei beginnt die Zählung der Zeichen wieder bei 0. Ab diesen beiden Positionen werden sechs Zeichen verglichen. Im Beispiel ergibt der Vergleich von »Kinder« und »Kinder« dann <span class="clisting">true</span>.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Sollte der Vergleich unabhängig von der Groß-/Kleinschreibung stattfinden, ist das erste Argument der überladenen Methode <span class="clisting">true</span>:</p>
<div class="listing"><pre class="prettyprint">String s = "Deutsche <span class="cfett">KINDER</span> sind zu dick";
boolean b = s.regionMatches( <span class="cfett">true</span>, 9, "Bewegungsarmut bei <span class="cfett">kinder</span>n", 19, 6 );</pre></div>
</td>
</tr>
</table><br><a id="mjac0dccd09d1a2ec631387a6918cd6768" name="mjac0dccd09d1a2ec631387a6918cd6768"></a><a name="t35"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t36"></a><h3 class="t3"><span class="cfett">4.2.5</span> Phonetische Vergleiche  <a href="#t2t37"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t35"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Bei der <span class="clisting">equals()</span>-Methode ist das Ergebnis nur dann <span class="clisting">true</span>, wenn beide Zeichenketten absolut gleich sind, also jedes Zeichen »passt«. <span class="clisting">equalsIgnoreCase()</span> ist schon etwas großzügiger, und hier sind etwa »vuvuzela« und »VuVuZeLa« gleich. Noch entspanntere Vergleiche erlauben <span class="clisting">Collatoren</span>, die etwa den Umlauten die Punkte nehmen, sodass »männo« und »manno« dann gleich sind.</p>
<p>Vergleiche aufgrund von Ähnlichkeiten und gleichem »Klang« gibt es jedoch in der Java Standardbibliothek nicht. Das ist aber interessant bei Namen. Mein Name »Ullenboom« wird oft zu Konstruktionen wie »Uhlenbohm« was sich im Prinzip gleich anhört (und jeder Maier, Meyer, Mayer, Meir, Myer, Meier kennt das Problem).</p>
<p>Zur Erkennung helfen besondere String-Algorithmen weiter. Für (insbesondere englische) Namen sind der <span class="ckursiv">Soundex</span>-Algorithmus und seine Verbesserungen <span class="ckursiv">Metaphone</span> und <span class="ckursiv">(Double) Metaphone</span> bekannt. Wer das in Java sucht, findet bei <span class="ckursiv">Apache Commons Codec</span> (http://commons.apache.org/codec/userguide.html) passende Implementierungen. So liefert etwa <span class="clisting">isDoubleMetaphoneEqual(String value1, String value2)</span> einen Wahrheitswert, der aussagt, ob die Strings ähnlich sind. Interessant sind die Algorithmen auch für Korrekturhilfen [Wobei ich die Korrektvorschläge »Ullendorf«, »Quellenbox«, »Patrouillenboot« und »Müllenborn« in den Textboxen von Google Chrome schon sehr schräg finde.
] . Der Name "<span class="clisting">Ullenboom</span>" ist dem Soundex-Code U451 zugeordnet. Schreibt jemand diesen Namen falsch, etwa "<span class="clisting">Uhlenbohm</span>", und dieser Name ist nicht im Wörterbuch, so berechnet das Programm von "<span class="clisting">Uhlenbohm</span>" ebenfalls den Soundex und kommt auf U451. Ein Blick in die Datenstruktur bei U451 liefert dann den korrekten Namen "<span class="clisting">Ullenboom</span>" oder andere Vorschläge, die den gleichen Soundex ergeben.</p>
<p>Wie ähnlich denn nun Strings sind, sagen andere Algorithmen. Die <span class="ckursiv">Levenshtein Distanz</span> zum Beispiel berechnet sich aus der (kleinst nötigen) Anzahl der einzufügenden, löschenden oder ersetzenden Zeichen, um von einem String zum anderen zu kommen; daher nennt sie sich auch <span class="ckursiv">Edit-Distanz</span>. Von "<span class="clisting">Chris</span>" nach "<span class="clisting">Char</span>" ist die Edit-Distanz drei und von "<span class="clisting">Ullenboom</span>" nach "<span class="clisting">Uhlenbohm</span>" vier. <span class="ckursiv">Jaro-Winkler</span> ist ein weiter Algorithmus, der die Ähnlichkeit zwischen 0 und 1 angibt. Das Projekt <span class="ckursiv">SecondString</span> (http://secondstring.sourceforge.net/) implementiert diese Algorithmen &#8211; und noch ein Duzend mehr.</p><a id="mjc6bf6272c679c8daa6715a7e8985f1c6" name="mjc6bf6272c679c8daa6715a7e8985f1c6"></a><a name="t36"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t37"></a><h3 class="t3"><span class="cfett">4.2.6</span> String-Teile extrahieren  <a href="#t2t38"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t36"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Die vielleicht wichtigste Methode der Klasse <span class="clisting">String</span> ist <span class="clisting">charAt(int index)</span>. Diese Methode liefert das entsprechende Zeichen an einer Stelle, die »Index« genannt wird. Dies bietet eine Möglichkeit, die Zeichen eines Strings (zusammen mit der Methode <span class="clisting">length()</span>) zu durchlaufen. Ist der Index kleiner null oder größer beziehungsweise gleich der Anzahl der Zeichen im String, so löst die Methode eine <span class="clisting">StringIndexOutOfBoundsException</span> [Mit 31 Zeichen gehört dieser Klassenname schon zu den längsten. Übertroffen wird er aber noch um fünf Zeichen von <span class="clisting">TransformerFactoryConfigurationError</span>. Im Spring-Paket gibt es aber <span class="clisting">JdbcUpdateAffectedIncorrectNumberOfRowsException</span> &#8211; auch nicht von schlechten Eltern.
]  mit der Fehlerstelle aus.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Liefere das erste und letzte Zeichen im String <span class="clisting">s</span>:</p>
<div class="listing"><pre class="prettyprint">String s = "Ich bin nicht dick! Ich habe nur weiche Formen.";
char first = s.<span class="cfett">charAt</span>( 0 );                          // 'I'
char last  = s.<span class="cfett">charAt</span>( s.length() &#8211; 1 );             // '.'</pre></div>
</td>
</tr>
</table><br><p>Wir müssen bedenken, dass die Zählung wieder bei null beginnt. Daher müssen wir von der Länge des Strings eine Stelle abziehen. Da der Vergleich auf den korrekten Bereich bei jedem Zugriff auf <span class="clisting">charAt()</span> stattfindet, ist zu überlegen, ob der String bei mehrmaligem Zugriff nicht stattdessen einmalig in ein eigenes Zeichen-Array kopiert werden sollte.</p>
<h4 class="t4">Teile eines Strings als String mit »substring()«</h4>
<p>Wollen wir einen Teilstring aus der Zeichenkette erfragen, so greifen wir zur Methode <span class="clisting">substring()</span>. Sie existiert in zwei Varianten &#8211; beide liefern ein neues String-Objekt zurück, das dem gewünschten Ausschnitt des Originals entspricht.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span><span class="clisting">substring(int)</span> liefert eine Teilzeichenkette ab einem Index bis zum Ende. Das Ergebnis ist ein neues <span class="clisting">String</span>-Objekt:</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">String s1 = "Infiltration durch <span class="cfett">Penetration</span>";
//  Position:                   19
String s2 = s1.<span class="cfett">substring</span>( 19 );                  // Penetration</pre></div>
</td>
</tr>
</table><br><p>Der Index von <span class="clisting">substring(int)</span> gibt die Startposition (null-basiert) an, ab der Zeichen in die neue Teilzeichenkette kopiert werden. <span class="clisting">substring(int)</span> liefert den Teil von diesem Zeichen bis zum Ende des ursprünglichen Strings &#8211; es ergibt <span class="clisting">s.substring(0)</span> gleich <span class="clisting">s</span>.</p>
<p>Wollen wir die Teilzeichenkette genauer spezifizieren, so nutzen wir die zweite Variante, <span class="clisting">substring(int, int)</span>. Ihre Argumente geben den Anfang und das Ende des gewünschten Ausschnitts an.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Schneide einen Teil des Strings aus:</p>
<div class="listing"><pre class="prettyprint">String tear = "'Jede Träne kitzelt auch die Wange.'";
//             0     6    11
System.out.println( tear.<span class="cfett">substring</span>( 6, 11 ) ); // Träne</pre></div>
<p class="BStandard">Während die Startposition inklusiv ist, ist die Endposition exklusiv. Das heißt, bei der Endposition gehört das Zeichen nicht mehr zur Teilzeichenkette.</p>
</td>
</tr>
</table><br><p>Die Methode <span class="clisting">substring(int)</span> ist nichts anderes als eine Spezialisierung von <span class="clisting">substring(int, int)</span>, denn die erste Variante mit dem Startindex lässt sich auch als <span class="clisting">s.substring(beginIndex, s.length())</span> schreiben.</p>
<p>Selbstverständlich kommen nun diverse Indexüberprüfungen hinzu &#8211; eine <span class="clisting">StringIndexOutOfBoundsException</span> meldet fehlerhafte Positionsangaben wie bei <span class="clisting">charAt()</span>.</p>
<h4 class="t4">String vor/nach einem Trennstring</h4>
<p>Ist ein Trennzeichen gegeben, und ein Teilstring vor oder nach diesem Trennzeichnen gewünscht, bietet die <span class="clisting">String</span>-Klasse keine Bibliotheksmethode an. [Selbst XPath bietet mit <span class="clisting">substring-before()</span> und <span class="clisting">substring-after()</span> solche Funktionen. Und Apache Commons Lang (<span class="ckursiv"><a href="http://commons.apache.org/lang/" target="_blank">http://commons.apache.org/lang/</a></span>) bildet sie in der Klasse <span class="clisting">org.apache.commons.     lang.StringUtils</span> auch nach.
]  Dabei wäre eine solche Methode praktisch, etwa bei Dateien, bei denen der Punkt den Dateinamen vom Suffix trennt. Wir wollen zwei statische Utility-Methoden <span class="clisting">substringBefore(String string, String delimiter)</span> und <span class="clisting">substringAfter(String string, String delimiter)</span> schreiben, die genau diese Aufgabe übernehmen. Angewendet sehen sie dann so aus (wir ignorieren für einen Moment, dass der Dateiname selbst auch einen Punkt enthalten kann):</p>
<ul class="gp">
<li><span class="clisting">substringBefore( "index.html", "." )</span> -> <span class="clisting">"index"</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">substringAfter( "index.html", "." )</span> -> <span class="clisting">"html"</span></li>
</ul>
<p>Die Implementierung der Methoden ist einfach: Im ersten Schritt suchen die Methoden mit <span class="clisting">indexOf()</span> nach dem Trenner. Anschließend liefern sie mit <span class="clisting">substring()</span> den Teilstring vor bzw. hinter diesem gefunden Trennstring. Noch einige Vereinbarungen: Der Trenner ist kein Teil der Rückgabe. Und taucht das Trennzeichen nicht im String auf, ist die Rückgabe von <span class="clisting">substringBefore()</span> der gesamte String und bei <span class="clisting">substringAfter()</span>der Leerstring. String und Trenner dürfen nicht <span class="clisting">null</span> sein, wenn dem so ist, folgt eine <span class="clisting">NullPointerException</span> und zeigt so den Programmierfehler an. Ausprogrammiert sehen die beiden Methoden so aus:</p>
<p class="tabunter"><strong>Listing 4.8    </strong>StringUtils.java</p>
<div class="listing"><pre class="prettyprint">public class StringUtils
{
  /**
   * Returns the substring before the first occurrence of a delimiter. The
   * delimiter is not part of the result.
   *
   * @param string    String to get a substring from.
   * @param delimiter String to search for.
   * @return          Substring before the first occurrence of the delimiter.
   */
  public static String substringBefore( String string, String delimiter )
  {
    int pos = string.indexOf( delimiter );

    return pos &gt;= 0 ? string.substring( 0, pos ) : string;
  }

  /**
   * Returns the substring after the first occurrence of a delimiter. The
   * delimiter is not part of the result.
   * @param string    String to get a substring from.
   * @param delimiter String to search for.
   * @return          Substring after the last occurrence of the delimiter.
   */
  public static String substringAfter( String string, String delimiter )
  {
    int pos = string.indexOf( delimiter );

    return pos &gt;= 0 ? string.substring( pos + delimiter.length() ) : "";
  }
}</pre></div>
<p>Zur Übung sei den Lesern überlassen, noch zwei Methoden <span class="clisting">substringBeforeLast()</span> und <span class="clisting">substringAfterLast()</span> zu realisieren, die statt <span class="clisting">indexOf()</span> die Methode <span class="clisting">lastIndexOf()</span> einsetzen (mit den beiden Methoden kann auch der Dateiname selbst einen Punkt enthalten). Frage: Lässt sich in der Implementierung einfach <span class="clisting">indexOf()</span> durch <span class="clisting">lastIndexOf()</span> ersetzen, und das war es dann schon?</p>
<h4 class="t4">Mit getChars() Zeichenfolgen als Array aus dem String extrahieren *</h4>
<p>Während <span class="clisting">charAt()</span> nur ein Zeichen liefert, kopiert <span class="clisting">getChars()</span> mehrere Zeichen aus einem angegebenen Bereich des Strings in ein übergebenes Feld.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Kopiere Teile des Strings in ein Feld:</p>
<div class="listing"><pre class="prettyprint">String s = "Blasiussegen";
char[] chars = new char[ 5 ];
int srcBegin = 7;
s.<span class="cfett">getChars</span>( srcBegin, srcBegin + 5, chars, 0 );
System.out.println( new String(chars) );  // segen</pre></div>
<p class="BStandard"><span class="clisting">s.getChars()</span> kopiert ab Position 7 aus dem String <span class="clisting">s</span> fünf Zeichen in die Elemente des Arrays <span class="clisting">chars</span>. Das erste Zeichen aus dem Ausschnitt steht dann in <span class="clisting">chars[0]</span>.</p>
</td>
</tr>
</table><br><p>Die Methode <span class="clisting">getChars()</span> muss natürlich wieder testen, ob die gegebenen Argumente im grünen Bereich liegen, das heißt, ob der Startwert nicht &lt; 0 ist und ob der Endwert nicht über die Größe des Strings hinausgeht. Passt das nicht, löst die Methode eine <span class="clisting">StringIndexOutOfBoundsException</span> aus. Liegt zudem der Startwert hinter dem Endwert, gibt es ebenfalls eine <span class="clisting">StringIndexOutOfBoundsException</span>, die anzeigt, wie groß die Differenz der Positionen ist. Am besten ist es, die Endposition aus der Startposition zu berechnen, wie es im obigen Beispiel geschehen ist. Passen alle Zeichen in das Feld, kopiert die Implementierung der Methode <span class="clisting">getChars()</span> mittels <span class="clisting">System.arraycopy()</span> die Zeichen aus dem internen Array des String-Objekts in das von uns angegebene Ziel.</p>
<p>Möchten wir den kompletten Inhalt eines Strings als ein Array von Zeichen haben, so können wir die Methode <span class="clisting">toCharArray()</span> verwenden. Intern arbeitet die Methode auch mit <span class="clisting">getChars()</span>. Als Ziel-Array legt <span class="clisting">toCharArray()</span> nur ein neues Array an, das wir dann zurückbekommen.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Mit folgendem Idiom lässt sich über eine Zeichenkette iterieren:</p>
<div class="listing"><pre class="prettyprint">String string = "Herr, schmeiß Java vom Himmel!";
for ( char c : string.toCharArray()
  System.out.println( c );
}</pre></div>
<p class="BStandard">Diese Lösung hat aber ihren Preis, denn ein neues <span class="clisting">char[]</span>-Objekt einfach für den Durchlauf zu erzeugen, kostet Speicher und Rechenzeit für die Speicherbereitstellung und die -bereinigung. Daher ist diese Variante nicht empfehlenswert. Hübscher wäre es natürlich, wenn rechts vom Doppelpunkt automatisch ein <span class="clisting">String</span>-Objekt berücksichtigt werden würde und den Compiler dazu anregte, die Zeichenkette zu durchlaufen.</p>
</td>
</tr>
</table><br><a id="mjc18e7a29f3c160214dca9d72db9a1942" name="mjc18e7a29f3c160214dca9d72db9a1942"></a><a name="t37"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t38"></a><h3 class="t3"><span class="cfett">4.2.7</span> Strings anhängen, Groß-/Kleinschreibung und Leerraum  <a href="#t2t39"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t37"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Obwohl String-Objekte selbst unveränderlich sind, bietet die Klasse <span class="clisting">String</span> Methoden an, die aus einer Zeichenkette Teile herausnehmen oder ihr Teile hinzufügen. Diese Änderungen werden natürlich nicht am String-Objekt vorgenommen, sondern die Methode liefert eine Referenz auf ein neues String-Objekt mit verändertem Inhalt zurück.</p>
<h4 class="t4">Anhängen an Strings</h4>
<p>Eine weitere Methode erlaubt das Anhängen von Teilen an einen String. Wir haben dies schon öfter mit dem Plus-Operator realisiert. Die Methode der <span class="clisting">String</span>-Klasse dazu heißt <span class="clisting">concat(String)</span>. Wir werden später sehen, dass es die <span class="clisting">StringBuilder</span>/<span class="clisting">StringBuffer</span>-Klassen noch weiter treiben und eine überladene Methode <span class="clisting">append()</span> mit der gleichen Funktionalität anbieten. Das steckt auch hinter dem Plus-Operator. Der Compiler wandelt dies automatisch in eine Kette von <span class="clisting">append()</span>-Aufrufen um.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Hänge das aktuelle Tagesdatum hinter eine Zeichenkette:</p>
<div class="listing"><pre class="prettyprint">String s1 = "Das aktuelle Datum ist: ";
String s2 = new Date().toString();
String s3 = s1.concat( s2 ); // Das aktuelle Datum ist: Tue Jun 05 14:46:41 CEST 2005</pre></div>
</td>
</tr>
</table><br><p>Die <span class="clisting">concat()</span>-Methode arbeitet relativ zügig und effizienter als der Plus-Operator, der einen temporären String-Puffer anlegt. Doch mit dem Plus-Operator ist es hübscher anzusehen (doch wie das so ist: Sieht nett aus, aber ...).</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Ähnlich wie im obigen Beispiel können wir Folgendes schreiben:</p>
<div class="listing"><pre class="prettyprint">String s3 = "Das aktuelle Datum ist: " + new Date().toString();</pre></div>
<p class="BStandard">Es geht sogar noch kürzer, denn der Plus-Operator ruft automatisch <span class="clisting">toString()</span> bei Objekten auf:</p>
<div class="listing"><pre class="prettyprint">String s3 = "Das aktuelle Datum ist: " + new Date();</pre></div>
</td>
</tr>
</table><br><p><span class="clisting">concat()</span> legt ein internes Feld an, kopiert die beiden Zeichenreihen per <span class="clisting">getChars()</span> hinein und liefert mit einem String-Konstruktor die resultierende Zeichenkette.</p>
<h4 class="t4">Groß-/Kleinschreibung</h4>
<p>Die Klasse <span class="clisting">Character</span> deklariert einige statische Methoden, um einzelne Zeichen in Groß-/Kleinbuchstaben umzuwandeln. Die Schleife, die das für jedes Zeichen übernimmt, können wir uns sparen, denn dazu gibt es die Methoden <span class="clisting">toUpperCase()</span> und <span class="clisting">toLowerCase()</span> in der Klasse <span class="clisting">String</span>. Interessant ist an beiden Methoden, dass sie einige sprachabhängige Feinheiten beachten. So zum Beispiel, dass es im Deutschen nicht wirklich ein großes »ß« gibt, denn »ß« wird zu »SS«. Gammelige Textverarbeitungen bekommen das manchmal nicht auf die Reihe, und im Inhaltsverzeichnis steht dann so etwas wie »SPAß IN DER NAßZELLE«. Aber bei möglichen Missverständnissen müsste »ß« auch zu »SZ« werden, vergleiche »SPASS IN MASZEN« mit »SPASS IN MASSEN« (ein ähnliches Beispiel steht im Duden). Diese Umwandlung ist aber nur von Klein nach Groß von Bedeutung. Für beide Konvertierungsrichtungen gibt es jedoch im Türkischen Spezialfälle, bei denen die Zuordnung zwischen Groß- und Kleinbuchstaben von der Festlegung in anderen Sprachen abweicht.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Konvertierung von Groß- in Kleinbuchstaben und umgekehrt:</p>
<div class="listing"><pre class="prettyprint">String s1 = "Spaß in der Naßzelle.";
String s2 = s1<span class="cfett">.toLowerCase().toUpperCase()</span>;      // SPASS IN DER NASSZELLE.
System.out.println( s2.length() &#8211; s1.length() ); // 2</pre></div>
</td>
</tr>
</table><br><p>Das Beispiel dient zugleich als Warnung, dass sich im Fall von »ß« die Länge der Zeichenkette vergrößert. Das kann zu Problemen führen, wenn vorher Speicherplatz bereitgestellt wurde. Dann könnte die neue Zeichenkette nicht mehr in den Speicherbereich passen. Arbeiten wir nur mit String-Objekten, haben wir dieses Problem glücklicherweise nicht. Aber berechnen wir etwa für einen Texteditor die Darstellungsbreite einer Zeichenkette in Pixel auf diese Weise, dann sind Fehler vorprogrammiert.</p>
<p>Um länderspezifische Besonderheiten zu berücksichtigen, lassen sich die <span class="clisting">toXXXCase()</span>-Methoden zusätzlich mit einem <span class="clisting">Locale</span>-Objekt füttern (<span class="clisting">Locale</span>-Objekte repräsentieren eine sprachliche Region). Die parameterlosen Methoden wählen die Sprachumgebung gemäß den Länder-Einstellungen des Betriebssystems:</p>
<div class="listing"><pre class="prettyprint">public String toLowerCase() {
  return toLowerCase( Locale.getDefault() );
}</pre></div>
<p>Ähnliches steht bei <span class="clisting">toUpperCase()</span>.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Es gibt Konvertierungen in Groß-/Kleinbuchstaben, die abhängig von der Landessprache zu unterschiedlichen Zeichenfolgen führen. Die Angabe eines <span class="clisting">Locale</span> bei den beiden <span class="clisting">toXXXXXCase()</span>-Methoden ist insbesondere bei türkischsprachigen Applikationen wichtig:</p>
<div class="listing"><pre class="prettyprint">System.out.println( "TITANIK".toLowerCase()  );                     // titan<span class="cfett">i</span>k
System.out.println( "TITANIK".toLowerCase(new Locale( "tr" ) )  );  // titanik</pre></div>
<p class="BStandard">Kleiner Unterschied: Im zweiten Ergebnisstring hat das i keinen i-Punkt!</p>
</td>
</tr>
</table><br><h4 class="t4">Leerraum entfernen</h4>
<p>In einer Benutzereingabe oder Konfigurationsdatei steht nicht selten vor oder hinter dem wichtigen Teil eines Texts Leerraum wie Leerzeichen oder Tabulatoren. Vor der Bearbeitung sollten sie entfernt werden. Die String-Klasse bietet dazu <span class="clisting">trim()</span> an.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Entferne Leer- und ähnliche Füllzeichen am Anfang und Ende eines Strings:</p>
<div class="listing"><pre class="prettyprint">String s = " \tSprich zu der Hand.\n  \t ";
System.out.println( "'" + <span class="cfett">s.trim()</span> + "'" ); // 'Sprich zu der Hand.'</pre></div>
</td>
</tr>
</table><br><p>Andere Modesprachen wie Visual Basic bieten dazu noch <span class="clisting">trim()</span>-Methoden an, die nur die Leerzeichen vorher oder nachher verwerfen. Die Java-Bibliothek bietet das so einfach nicht.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Teste, ob ein String mit Abzug allen Weißraums leer ist:</p>
<div class="listing"><pre class="prettyprint">boolean isBlank = "".equals( s.<span class="cfett">trim()</span> );</pre></div>
<p class="BStandard">Alternativ:</p>
<div class="listing"><pre class="prettyprint">boolean isBlank = s.<span class="cfett">trim()</span>.isEmpty();</pre></div>
</td>
</tr>
</table><br><a id="mjcea37d75dba4d69967de4d1e249dbcc2" name="mjcea37d75dba4d69967de4d1e249dbcc2"></a><a name="t38"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t39"></a><h3 class="t3"><span class="cfett">4.2.8</span> Suchen und ersetzen  <a href="#t2t310"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t38"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Da String-Objekte unveränderlich sind, kann eine Veränderungsmethode nur einen neuen String mit den Veränderungen zurückgeben. Wir finden in Java vier Methoden, die suchen und ersetzen:</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">final class java.lang.<span class="cfett">String</span>
implements Serializable, Comparable&lt;String&gt;, CharSequence</pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">replace( char oldChar, char newChar )</span>. Ersetzt einzelne Zeichen.</li>
</ul>
<ul class="gp">
<li><span class="clisting">replace( CharSequence target, CharSequence replacement)</span>. Ersetzt eine Zeichenkette durch eine andere Zeichenkette.</li>
</ul>
<ul class="gp">
<li><span class="clisting">replaceAll( String regex, String replacement)</span>. Ersetzt alle Strings, die durch einen regulären Ausdruck beschrieben werden.</li>
</ul>
<ul class="gp">
<li><span class="clisting">replaceFirst( String regex, String replacement)</span>. Ersetzt den ersten String, der durch einen regulären Ausdruck beschrieben wird.</li>
</ul>
<h4 class="t4">Ersetzen ohne reguläre Ausdrücke</h4>
<p>Die <span class="clisting">replace</span><span class="clisting">(char, char)</span>-Methode ersetzt einzelne Zeichen.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Ändere den in einer Zeichenkette vorkommenden Buchstaben »o« in »u«:</p>
<div class="listing"><pre class="prettyprint">String s1 = "H<span class="cfett">o</span>n<span class="cfett">o</span>lulu";
String s2 = s1.<span class="cfett">replace</span>( 'o', 'u' );          // s2 = "H<span class="cfett">u</span>n<span class="cfett">u</span>lulu"</pre></div>
<p class="BStandard">Das String-Objekt mit dem Namen <span class="clisting">s1</span> wird selbst nicht verändert. Es wird nur ein neues String-Objekt mit dem Inhalt »<span class="clisting">Hunululu</span>« erzeugt und von <span class="clisting">replace()</span> zurückgegeben.</p>
</td>
</tr>
</table><br><p>Gibt es etwas zu ersetzen, erzeugt <span class="clisting">replace()</span> intern ein neues Zeichenfeld, führt die Ersetzungen durch und konvertiert das interne Zeichenfeld in ein String-Objekt, was die Rückgabe ist. Gab es nichts zu ersetzen, bekommen wir das gleiche String-Objekt zurück, das die Anfrage stellte. Die <span class="clisting">replace()</span>-Methode ersetzt immer alle Zeichen. Eine Variante, die nur das erste Zeichen ersetzt, müssen wir uns selbst schreiben.</p>
<p>Eine zweite überladene Variante, <span class="clisting">replace(CharSequence, CharSequence)</span>, sucht nach allen auftretenden Zeichenfolgen und ersetzt sie durch eine andere Zeichenfolge. Der Ersetzungsstring kann auch leer sein.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Im String <span class="clisting">s</span> soll »Schnecke« durch »Katze« ersetzt werden:</p>
<div class="listing"><pre class="prettyprint">String s = "Schnecken erschrecken, wenn Schnecken an Schnecken schlecken, " +
           "weil zum Schrecken vieler Schnecken Schnecken nicht schmecken.";
System.out.println( s.<span class="cfett">replace</span>("Schnecke", "Katze") );</pre></div>
<p class="BStandard">Das Ergebnis auf dem Bildschirm ist »Katzen erschrecken, wenn Katzen an Katzen schlecken, weil zum Schrecken vieler Katzen Katzen nicht schmecken.«</p>
</td>
</tr>
</table><br><h4 class="t4">Suchen und ersetzen mit regulären Ausdrücken</h4>
<p>Die Methoden <span class="clisting">replaceAll()</span> und <span class="clisting">replaceFirst()</span> suchen in Zeichenketten mithilfe von regulären Ausdrücken (mehr dazu folgt in Abschnitt 4.7, »Reguläre Ausdrücke«) und nehmen Ersetzungen vor; <span class="clisting">replaceFirst()</span> ersetzt, wie der Name schon sagt, nur das erste Auftreten.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Mehr als zwei Leerzeichen in Folge sollen auf ein Leerzeichen komprimiert werden:</p>
<div class="listing"><pre class="prettyprint">String s = "Alles  fit im   Schritt?";
System.out.println( s.<span class="cfett">replaceAll( " +", " " )</span> );   // Alles fit im Schritt?
System.out.println( s.<span class="cfett">replaceFirst( " +", " " )</span> ); // Alles fit im   Schritt?</pre></div>
</td>
</tr>
</table><br><p>Weil der Suchstring immer ein regulärer Ausdruck ist und Sonderzeichen wie ».« oder »+« eine Sonderrolle einnehmen, eignen sich <span class="clisting">replaceAll()</span> und <span class="clisting">replaceFirst()</span> nicht direkt für allgemeine Ersetzungsaufgaben; hier ist die <span class="clisting">replace()</span>-Methode passender.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Für eine String-Ersetzung stellen wir <span class="clisting">replace()</span> und <span class="clisting">replaceAll()</span> nebeneinander:</p>
<div class="listing"><pre class="prettyprint">String s;
s = "'Tag, Karl.' 'Wie geht's, Karl?' 'Gut, Karl.' 'Kahl, Karl?' 'Ja, Karl, ganz kahl.'";
System.out.println( s.replace(".", "!") );</pre></div>
<p class="BStandard">Der Aufruf ersetzt alle Punkte durch Ausrufezeichen, sodass das Ergebnis wie folgt lautet:</p>
<div class="listing"><pre class="prettyprint">'Tag, Karl!' 'Wie geht's, Karl?' 'Gut, Karl!' 'Kahl, Karl?' 'Ja, Karl, ganz kahl!'</pre></div>
<p class="BStandard">Nutzen wir <span class="clisting">s.replaceAll(".", "!")</span>, führt das nicht zum Erfolg, sondern nur zu der Zeichenkette:</p>
<div class="listing"><pre class="prettyprint">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</pre></div>
</td>
</tr>
</table><br><p>Der Punkt steht in regulären Ausdrücken für beliebige Zeichen. Erst, wenn er mit <span class="clisting">\\</span> ausmaskiert wird &#8211; wegen des Sonderstatus von »\« muss auch dieses Zeichen selbst ausmaskiert werden &#8211;, liefert die Anweisung wie in <span class="clisting">s.replaceAll("\\.", "!")</span> das gewünschte Ergebnis. Die statische Methode <span class="clisting">Pattern.quote(String)</span> maskiert die Pattern-Sonderzeichen für uns aus, sodass auch <span class="clisting">s.replaceAll(Pattern.quote("."), "!")</span> gut funktioniert. Zur Klasse <span class="clisting">java.util.regex.Pattern</span> und regulären Ausdrücken folgt mit Abschnitt 4.7 ein eigenes großes Unterkapitel.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Ersetze in einem String alle diakritischen Zeichen:</p>
<div class="listing"><pre class="prettyprint">String s = "Müller";
s = Normalizer.normalize( s, Normalizer.Form.NFD );
s = s.replaceAll( "[\\p{InCombiningDiacriticalMarks}\\p{IsLm}\\p{IsSk}]+", "" );
System.out.println( s );  // Muller</pre></div>
<p class="BStandard">Die Lösung geht zweistufig vor. Der <span class="clisting">Normalisierer</span> zerlegt zunächst den String und macht die eigentliche Arbeit. <span class="clisting">replaceAll()</span> entfernt dann übrig gebliebene Punke, Striche, Kreise und Häkchen.</p>
</td>
</tr>
</table><br><a id="mjae1154bac3cab076ee42a9a2dc61c6cc" name="mjae1154bac3cab076ee42a9a2dc61c6cc"></a><a name="t39"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t310"></a><h3 class="t3"><span class="cfett">4.2.9</span> String-Objekte mit Konstruktoren neu anlegen *  <img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"><a href="#t2t39"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Liegt die Zeichenkette nicht als String-Literal vor, lassen sich mit den unterschiedlichen Konstruktoren der <span class="clisting">String</span>-Klasse neue String-Objekte aufbauen. Die meisten Konstruktoren sind für Spezialfälle gedacht und kommen in normalen Java-Programmen nicht vor:</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">final class java.lang<span class="cfett">.String</span>
implements CharSequence, Comparable&lt;String&gt;, Serializable</pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">String()</span>
Erzeugt ein neues Objekt ohne Zeichen (den leeren String <span class="clisting">""</span>).</li>
</ul>
<ul class="gp">
<li><span class="clisting">String( String string )</span>
Erzeugt ein neues Objekt mit einer Kopie von <span class="clisting">string</span>. Es wird selten benötigt, da String-Objekte unveränderbar (<span class="ckursiv">immutable</span>) sind.</li>
</ul>
<ul class="gp">
<li><span class="clisting">String( char[] value )</span>
Erzeugt ein neues Objekt und kopiert die im <span class="clisting">char</span>-Feld vorhandenen Zeichen in das neue String-Objekt.</li>
</ul>
<ul class="gp">
<li><span class="clisting">String( char[] value, int offset, int length )</span>
Erzeugt wie <span class="clisting">String(char[])</span> einen String aus einem Ausschnitt eines Zeichenfelds. Der verwendete Ausschnitt beginnt bei dem Index <span class="clisting">offset</span> und umfasst <span class="clisting">length</span> Zeichen.</li>
</ul>
<ul class="gp">
<li><span class="clisting">String( byte[] bytes )</span>
Erzeugt ein neues Objekt aus dem Byte-Feld. Das <span class="clisting">byte</span>-Array enthält keine Unicode-Zeichen, sondern eine Folge von Bytes, die nach der Standardkodierung der jeweiligen Plattform in Zeichen umgewandelt werden.</li>
</ul>
<ul class="gp">
<li><span class="clisting">String( byte[] bytes, int offset, int length )</span>
Erzeugt wie <span class="clisting">String(byte[])</span> einen String aus einem Ausschnitt eines Byte-Felds.</li>
</ul>
<ul class="gp">
<li><span class="clisting">String( byte[] bytes, String charsetName ) throws UnsupportedEncodingException</span>
Erzeugt einen neuen String von einem Byte-Array mithilfe einer speziellen Zeichenkodierung, die die Umwandlung von Bytes in Unicode-Zeichen festlegt.</li>
</ul>
<ul class="gp">
<li><span class="clisting">String( byte[] bytes, int offset, int length, String charset )</span>
   <span class="clisting">throws UnsupportedEncodingException</span>
Erzeugt einen neuen String mit einem Teil des Byte-Arrays mithilfe einer speziellen Zeichenkodierung.</li>
</ul>
<ul class="gp">
<li><span class="clisting">String( StringBuffer buffer )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">String( StringBuilder builder )</span>
Erzeugt aus einem veränderlichen <span class="clisting">StringBuffer</span>-/<span class="clisting">StringBuilder</span>-Objekt ein unveränderliches String-Objekt, das dieselbe Zeichenreihe repräsentiert.</li>
</ul>
<ul class="gp">
<li><span class="clisting">String( int[] codePoints, int offset, int count )</span>
Erzeugt ein String-Objekt mit Unicode-Codepoints, die Zeichen über <span class="clisting">int</span> kodieren.</li>
</ul>
<p>Die Konstruktoren sind im Speziellen nur dann nötig, wenn aus einer Fremdrepräsentation wie einem <span class="clisting">StringBuilder</span>, <span class="clisting">StringBuffer</span>, <span class="clisting">char[]</span> oder <span class="clisting">byte[]</span> oder Teilen von ihnen ein <span class="clisting">String</span>-Objekt aufgebaut werden soll.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Erzeuge einen String einer gegebenen Länge:</p>
<p class="tabunter"><strong>Listing 4.9    </strong>GenerateStringWithGivenLength.java, generateStringWithLength()</p>
<div class="listing"><pre class="prettyprint">public static String generateStringWithLength( int len, char fill )
{
  if ( len &lt; 0 )
    return null;

  char[] cs = new char[ len ];
  Arrays.fill( cs, fill );
  return  new String( cs );
}</pre></div>
<p class="BStandard">In der <span class="clisting">String</span>-Klasse gibt es keine Methode, die eine Zeichenkette einer vorgegebenen Länge aus einem einzelnen Zeichen erzeugt.</p>
</td>
</tr>
</table><br><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Teste, ob zwei Zeichenketten Anagramme darstellen, also Zeichenfolgen, die beim Vertauschen von Buchstaben gleich sind:</p>
<div class="listing"><pre class="prettyprint">String a1 = "iPad", a2 = "Paid";
char[] a1chars = a1.toCharArray();
char[] a2chars = a2.toCharArray();
Arrays.sort( a1chars );
Arrays.sort( a2chars );
boolean isAnangram = new String(a1chars).equalsIgnoreCase(new String(a2chars));
System.out.println( isAnangram );       // true</pre></div>
</td>
</tr>
</table><br><h4 class="t4">Der Konstruktor der Klasse »String«</h4>
<p>Ein Konstruktor führt leicht zur Verwirrung, und zwar der Konstruktor, der einen anderen String annimmt. So ergeben die beiden folgenden Zeilen die Referenz auf ein String-Objekt:</p>
<div class="listing"><pre class="prettyprint">String rudi = "There is no spoon";
String rudi = new String( "There is no spoon" );</pre></div>
<p>Die zweite Lösung erzeugt unnötigerweise ein zusätzliches <span class="clisting">String</span>-Objekt, denn das Literal ist ja schon ein vollwertiges <span class="clisting">String</span>-Objekt.      </p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Tuning-Hinweis   </span>Der Konstruktor ist <span class="ckursiv">nur</span> für eine besondere Optimierung zu gebrauchen, die in der Regel wie folgt aussieht (sei <span class="clisting">s</span> ein großer String und <span class="clisting">t</span> ein Teilstring):</p>
<div class="listing"><pre class="prettyprint">String
String t = <span class="cfett">new String( s.substring(…) )</span>;</pre></div>
<p class="BStandard">Die <span class="clisting">String</span>-Klasse in Java ist nichts anderes als eine Abstraktion von einem darunterliegenden <span class="clisting">char</span>-Feld.[Die ersten Zeilen in der Klasse String beginnen mit:<span class="clisting">
public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
 /** The value is used for character storage. */
private final char value[];</span>
] Bei einem <span class="clisting">substring()</span> wird kein neues <span class="clisting">char</span>-Feld mit der Teilzeichenkette aufgebaut, sondern es wird das ursprüngliche <span class="clisting">char</span>-Feld (in unserem Beispiel von <span class="clisting">s</span>) genutzt, und es werden lediglich die Start- und End-Positionen gesetzt. Ein <span class="clisting">String</span>-Objekt enthält daher nicht nur intern ein Attribut für das <span class="clisting">char</span>-Feld, sondern auch noch <span class="clisting">offset</span> (also den Startpunkt) und die Länge.[ <span class="clisting">/** The offset is the first index of the storage that is used. */
private final int offset;
/** The count is the number of characters in the String. */
 private final int count;</span>
] Somit ist die Operation <span class="clisting">substring()</span> sehr performant, da keine Zeichenfelder kopiert werden müssen. Das Problem: Ist das von <span class="clisting">s</span> referenzierte <span class="clisting">char</span>-Feld sehr groß, wird dieses Feld ebenfalls vom Teilstring referenziert. Wenn das ursprüngliche String-Objekt <span class="clisting">s</span> vom GC entfernt wird, bleibt trotzdem das große <span class="clisting">char</span>-Feld bestehen, denn es wird vom Teilstring referenziert. Um den Speicherbedarf in diesem Fall zu optimieren, ist der <span class="clisting">new String(String)</span>-Konstruktor geeignet, denn er legt ein neues kompaktes <span class="clisting">char</span>-Feld an, das ausschließlich die Zeichen speichert. Somit ist kein Verweis mehr auf das ursprüngliche Feld vorhanden, was dann der GC wegräumen kann, wenn das ursprüngliche String-Objekt <span class="clisting">s</span> auch nicht mehr existiert.</p>
</td>
</tr>
</table><br><h4 class="t4">Strings im Konstantenpool</h4>
<p>Die JVM erzeugt für jedes Zeichenketten-Literal automatisch ein entsprechendes String-Objekt. Das geschieht für jede konstante Zeichenkette höchstens einmal, egal wie oft sie im Programmverlauf benutzt wird und welche Klassen den String nutzen. Dieses String-Objekt »lebt« in einem Bereich, der <span class="ckursiv">Konstantenpool</span> genannt wird. [Die Java-Bibliothek implementiert hier das Entwurfsmuster <span class="ckursiv">Fliegengewicht</span> (Flyweight-Pattern) der Gang of Four.
] </p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Nehmen wir an, die Anweisung</p>
<div class="listing"><pre class="prettyprint">System.out.println( <span class="cfett">"tutego"</span> );</pre></div>
<p class="BStandard">steht in einer Klasse <span class="clisting">A</span> und in einer anderen Klasse <span class="clisting">B</span> steht:</p>
<div class="listing"><pre class="prettyprint">int len = "tutego".length();</pre></div>
<p class="BStandard">Dann gibt es die Zeichenfolge »tutego« als String-Objekt nur ein einziges Mal in der Laufzeitumgebung.</p>
</td>
</tr>
</table><br><p>Bei konstanten Werten führt der Compiler Optimierungen durch, etwa in der Art, dass er konstante Ausdrücke gleich berechnet. Nicht nur setzt er für Ausdrücke wie <span class="clisting">1 + 2</span> das Ergebnis <span class="clisting">3</span> ein, auch aufgebrochene konstante String-Teile, die mit Plus konkateniert werden, fügt der Compiler zu einer Zeichenkette zusammen.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Beide Anweisungen sehen im Bytecode gleich aus:</p>
<div class="listing"><pre class="prettyprint">String s = "Operating systems are like underwear &#8211; nobody really wants to look at them. (Bill Joy)";
String s = "Operating systems are like underwear &#8211; nobody really wants to look at them" <span class="cfett">+</span> '.' <span class="cfett">+</span> " (Bill Joy)";</pre></div>
<p class="BStandard">Der Compiler fügt die Zeilzeichenketten automatisch zu einer großen Zeichenkette zusammen, sodass keine Konkatenation zur Laufzeit nötig ist.</p>
</td>
</tr>
</table><br><h4 class="t4">Leerer String, Leer-String oder Null-String</h4>
<p>Die Anweisungen</p>
<div class="listing"><pre class="prettyprint">String s = "";</pre></div>
<p>und</p>
<div class="listing"><pre class="prettyprint">String s = new String();</pre></div>
<p>referenzieren in beiden Fällen String-Objekte, die keine Zeichen enthalten. Die zweite Schreibweise erzeugt aber ein neues String-Objekt, während im ersten Fall das String-Literal im Konstantenpool liegt.</p>
<p>Ein String ohne Zeichen nennen wir <span class="ckursiv">leeren String</span>, <span class="ckursiv">Leer-String</span> oder <span class="ckursiv">Null-String</span>. Der letzte Begriff ist leider etwas unglücklich gewählt, sodass wir ihn im Buch nicht nutzen, denn der Begriff <span class="ckursiv">Null-String</span> kann leicht mit dem Begriff <span class="clisting">null</span>-<span class="ckursiv">Referenz</span> verwechselt werden. Doch während Zugriffe auf einem Null-String unproblematisch sind, führen Dereferezierungen auf der <span class="clisting">null</span>-Referenz unweigerlich zu einer <span class="clisting">NullPointerException</span>:</p>
<div class="listing"><pre class="prettyprint">String s = null;
System.out.println( s );              //    Ausgabe: null
s.length();                           // <img src="common/totenkopf.gif" border="0" align="bottom" alt="Fehler"> NullPointerException</pre></div>
<p><span class="clisting">printXXX(null)</span> führt zu der Konsolenausgabe »null« und zu keiner Ausnahme, da es eine Fallunterscheidung in <span class="clisting">printXXX()</span> gibt, die die <span class="clisting">null</span>-Referenz als Sonderfall betrachtet. [In der Implementierung von <span class="clisting">PrintStream</span> von Sun:<span class="clisting"> public void print( String s ) { if ( s == null ) s = "null"; write( s ); }</span>
]  Der Zugriff auf <span class="clisting">s</span> über <span class="clisting">s.length()</span> führt dagegen zur unbliebten <span class="clisting">NullPointerException</span>.</p><br><hr><a name="kommentar"></a><h3>Ihr Kommentar</h3>
                       Wie hat Ihnen das &lt;openbook&gt; gefallen? Wir freuen uns immer über Ihre freundlichen und kritischen Rückmeldungen.
                       <form action="http://www.galileo-press.de/feedback/openbook" method="post" style="text-align: center; margin-top: 10px;"><input type="hidden" name="openbookurl" value="javainsel9/.htm"><input type="hidden" name="buchtitel" value="Java ist auch eine Insel"><input type="hidden" name="Kapitel" value="4.2 Strings und deren Anwendung"><table border="0">
<tr>
<td><label for="name">Name</label><br></td>
<td><input type="text" name="name" id="name" size="40"><br></td>
</tr>
<tr>
<td><label for="email">E-Mail</label><br></td>
<td><input type="text" name="email" id="email" size="40"><br></td>
</tr>
<tr>
<td valign="top"><label for="comment">Ihr Kommentar</label><br></td>
<td><textarea name="comment" id="comment" rows="10" cols="40"></textarea><br></td>
</tr>
<tr>
<td>
</td>
<td><input type="submit" value="Kommentar absenden"></td>
</tr>
</table>
</form>
</div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="javainsel_04_001.htm" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a class="navnav" href="#">&lt;top&gt;</a></div></td>
<td align="right" width="25%"><div align="right"><a href="javainsel_04_003.htm" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
</table>
</div></td>
<td width="10" valign="top">  </td>
<td width="160" valign="top">
<table border="0" cellpadding="0" cellspacing="0" width="160">
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2">
&nbsp;<a href="http://www.galileocomputing.de/katalog/buecher/?GPP=opjiVIV" class="autor">
<strong>Zum Katalog</strong></a>

</td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2">
<img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV">
<img src="common/9783836215060_s.gif" width="119" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Java ist auch eine Insel" title="Zum Katalog: Java ist auch eine Insel">
<br><br><br><br><br><br><strong>Java ist auch eine Insel</strong><br><img src="common/pfeil_rechts5.gif" border="0" alt="">Jetzt bestellen</a><br /><br />
</td>
</tr>
</table>
</td>

</tr>
</table>
</td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2"><span class="autor"><strong>&nbsp;Ihre Meinung?</strong></a></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">

<table cellspacing="3">
<tr>
<td>Wie hat Ihnen das &lt;openbook&gt; gefallen?<br><a href="#kommentar"><img src="common/pfeil_rechts5.gif" border="0" alt="">Ihre Meinung</a>
<br><br></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>

<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>
<tr>
<td>
</td>
</tr>

<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2">&nbsp;<a href="http://www.galileocomputing.de/katalog/buecher/?GPP=opjiVIV" class="autor"><strong>Buchempfehlungen</strong></a></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2285?GPP=opjiVIV">
<img src="common/9783836215275_s.gif" width="102" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Computergeschichte(n) – nicht nur für Geeks" title="Zum Katalog: Computergeschichte(n) – nicht nur für Geeks"><br><br><br><br><br><br>&nbsp;Computergeschichte(n)<br>&nbsp;nicht nur für Geeks</a><br><br></td>
</tr>

<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/1949?GPP=opjiVIV">
<img src="common/9783836213080_s.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Java und XML" title="Zum Katalog: Java und XML"><br><br><br><br><br><br><br>&nbsp;Java und XML</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2346?GPP=opjiVIV">
<img src="common/9783836215688_s.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Einstieg in Java" title="Zum Katalog: Einstieg in Java"><br><br><br><br><br><br><br>&nbsp;Einstieg<br>&nbsp;in Java</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2051?GPP=opjiVIV">

<img src="common/9783836213677_s.gif" width="112" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Einstieg in XML" title="Zum Katalog: Einstieg in XML"><br><br><br><br><br><br><br>&nbsp;Einstieg<br>&nbsp;in XML</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2322?GPP=opjiVIV">
<img src="common/9783836215527_s.gif" width="112" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Visual C# 2010" title="Zum Katalog: Visual C# 2010"><br><br><br><br><br><br><br>&nbsp;Visual C# 2010</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2212?GPP=opjiVIV">
<img src="common/9783836214742_s.gif" width="119" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Professionell entwickeln mit Visual C# 2010" title="Zum Katalog: Professionell entwickeln mit Visual C# 2010"><br><br><br><br><br><br><br>&nbsp;Professionell<br>&nbsp;entwickeln mit<br>&nbsp;Visual C# 2010</a><br><br></td>
</tr>

<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2156?GPP=opjiVIV">
<img src="common/9783836214292_s.gif" width="108" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C++ von A bis Z" title="Zum Katalog: C++ von A bis Z"><br><br><br><br><br><br><br>&nbsp;C++ von A bis Z</a><br><br></td>
</tr>
</table></td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>

<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2"><span class="autor"><strong>&nbsp;Shopping</strong></span></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><b>Versandkostenfrei</b> bestellen in Deutschland und &Ouml;sterreich<br><a href="http://www.galileocomputing.de/hilfe/Shop/?GPP=opjiVIV"><img src="common/pfeil_rechts5.gif" border="0" alt="Info">Info</a><br><br></td>

</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table><br><br><hr width="70%" align="center">
<div align="center">
<p class="standard"><strong>Copyright © Galileo Press 2011</strong><br>
        Für Ihren privaten Gebrauch dürfen Sie die Online-Version natürlich ausdrucken.
        Ansonsten unterliegt das &lt;openbook&gt; denselben Bestimmungen, wie die
        gebundene Ausgabe: Das Werk einschließlich aller seiner Teile ist urheberrechtlich
        geschützt. Alle Rechte vorbehalten einschließlich der Vervielfältigung, Übersetzung,
        Mikroverfilmung sowie Einspeicherung und Verarbeitung in elektronischen Systemen.</p><br><a href="http://www.galileocomputing.de/">[Galileo Computing]</a><br><br>
      Galileo Press, Rheinwerkallee 4, 53227 Bonn, Tel.: 0228.42150.0, Fax 0228.42150.77, <a href="mailto:info@galileo-press.de">info@galileo-press.de</a></div><br><br></body>
</html>
