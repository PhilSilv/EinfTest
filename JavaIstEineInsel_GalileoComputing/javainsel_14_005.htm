<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Galileo Computing :: Java ist auch eine Insel – 14.5 Synchronisation über kritische Abschnitte</title>
<meta name="title" content="Galileo Computing :: Java ist auch eine Insel - 14.5 Synchronisation über kritische Abschnitte">
<meta name="author" content="Christian Ullenboom ">
<meta name="publisher" content="Galileo Press 2011">
<meta name="copyright" content="Galileo Press 2011">
<meta name="Description" content="Java ist auch eine Insel - Das umfassende Handbuch – 14.5 Synchronisation über kritische Abschnitte">
<meta name="audience" content="Alle">
<meta name="robots" content="INDEX,FOLLOW">
<meta http-equiv="content-language" content="de">
<link rel="stylesheet" type="text/css" href="common/galileo_open.css">
<link rel="prev" href=".htm">
<link rel="next" href=".htm"><script type="text/javascript"><!--
    function OpenWin(url,name,height,width)
    {
      var InfoWin = window.open(url,name,"directories=0,height="+height+",width=" + width + ",hotkeys=0,location=0,menubar=0,resizable=1,screenX=150,screenY=10,left=150,top=10,scrollbars=1,status=1,titlebar=0,toolbar=0");
      InfoWin.focus();
    }
    //--></script><link href="common/prettify.css" type="text/css" rel="stylesheet"><script type="text/javascript" src="common/prettify.js"></script></head>
<body vlink="#000099" link="#000099" alink="#000099" onload="prettyPrint()">
<table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#000066">
<tr>
<td height="74" valign="bottom" colspan="2"><a href="http://www.galileocomputing.de/katalog/openbook?GPP=opjiVIV"><img src="common/galileocomputing_openbook.gif" width="200" height="56" border="0" alt="Galileo Computing < openbook >" title="Galileo Computing < openbook >"></a></td>
<td width="80" height="74"><a href="http://www.galileocomputing.de/?GPP=opjiVIV"><img src="common/galileocomputing.gif" border="0" alt="Galileo Computing - Professionelle Bücher. Auch für Einsteiger." title="Galileo Computing - Professionelle Bücher. Auch für Einsteiger."></a></td>
</tr>
</table>
<div align="right"><a href="http://www.galileocomputing.de/?GPP=opjiVIV" class="navnav">Professionelle Bücher. Auch für Einsteiger.</a></div><br><table class="tbl" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="190" valign="top">
<table class="tbl1" border="0" cellpadding="3" cellspacing="0" width="190" align="left">
<tr>
<td class="tbl2"><a class="nav" href="index.htm#_top">Inhaltsverzeichnis</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_00_001.htm#mj58b119301920569a446c9c510503f310">Vorwort</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_01_001.htm#mja8fc5b7ad19fc7332bc66b09a8fda26e">1 Java ist auch eine Sprache</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_02_001.htm#mj313f67c98dc9ecaddfa2d8b80f057fd2">2 Sprachbeschreibung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_03_001.htm#mjcd3b5720e8605484942e3476a1075bdf">3 Klassen und Objekte</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_04_001.htm#mj71fbc84ad33a281b9352b0b19fae2fb2">4 Der Umgang mit Zeichenketten</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_05_001.htm#mj005cd8e604aefc3ae72b92880fcee5c6">5 Eigene Klassen schreiben</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_06_001.htm#mj6f6b47453043c38837bfc32154a97968">6 Exceptions</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_07_001.htm#mjc4a1f6f3499a02fb64fe89046739edca">7 Generics&lt;T&gt;</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_08_001.htm#mj46e914488628367f5dfc0a62c3a78a53">8 Äußere.innere Klassen</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_09_001.htm#mj94af2b90e8a2dad6c1ef67255f89a137">9 Besondere Klassen der Java SE</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_10_001.htm#mjcae20f50ffbc015d0b66861e7087af9b">10 Architektur, Design und angewandte Objektorientierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_11_001.htm#mj60bc6a007ae9b8657949f3e91d96df3d">11 Die Klassenbibliothek</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_12_001.htm#mj0ce00eb41aae2b084534019cf6edc3b6">12 Bits und Bytes und Mathematisches</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_13_001.htm#mj245f5f8d5a858b46462d64e9b9c0786b">13 Datenstrukturen und Algorithmen</a></td>
</tr>
<tr>
<td><a class="navh" href="javainsel_14_001.htm#mj8c6f381221d805dd6fbe480731ac0c58">14 Threads und nebenläufige Programmierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_15_001.htm#mjbe3ed0989722396930966f95deeb2497">15 Raum und Zeit</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_16_001.htm#mj78bd405fb0de0cff099c06255fe36853">16 Dateien, Verzeichnisse und Dateizugriffe</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_17_001.htm#mjb420b02f4ccf65226f7271e48cefa05d">17 Datenströme</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_18_001.htm#mjedab16f1a9cc168eda4a24416359e0b9">18 Die eXtensible Markup Language (XML)</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_19_001.htm#mjc8f47f7f51ac3795c46c4544f391b02e">19 Grafische Oberflächen mit Swing</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_20_001.htm#mj25cc7d47e476b8b1a183a10ee741dbaa">20 Grafikprogrammierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_21_001.htm#mjea7bcdd596c8bd25b078a00221a01a75">21 Netzwerkprogrammierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_22_001.htm#mjde622db61608a627262a27ecb377d675">22 Verteilte Programmierung mit RMI</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_23_001.htm#mj23bf599d65364bcd05d06a34cb5593bf">23 JavaServer Pages und Servlets</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_24_001.htm#mja621f3b4a74c7fa576b4a58b1614041e">24 Datenbankmanagement mit JDBC</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_25_001.htm#mja2e217bf5724cc65eba184a2af8b79cf">25 Reflection und Annotationen</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_26_001.htm#mjb47dd6e0a309b7e78cad68f6b5de9319">26 Dienstprogramme für die Java-Umgebung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_27_001.htm#mjf59db36d9280a70e0d3d196e9bf160f5">A Die Begleit-DVD</a></td>
</tr>
<tr>
<td><a class="navnav" href="stichwort.htm#_top">Stichwort</a></td>
</tr>
<tr>
<td><br><a href="http://download2.galileo-press.de/openbook/galileocomputing_javainsel9.zip" class="navnav"><strong>Download:</strong><br>- ZIP, ca. 20,5 MB</a></td>
</tr>
<tr>
<td><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV" class="navnav">Buch bestellen</a></td>
</tr>
<tr>
<td><a class="navnav" href="#kommentar">Ihre Meinung?</a><br><br></td>
</tr>
</table>
</td>
<td width="10"><img src="common/spacer10.gif" width="10" height="10" alt="Spacer"></td>
<td width="85%" valign="top" align="center"><div align="center">
<table width="98%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="javainsel_14_004.htm" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a href="http://www.galileocomputing.de/?GPP=opjiVIV" class="navnav">Galileo Computing /</a><a href="http://www.galileocomputing.de/katalog/openbook/?GPP=opjiVIV" class="navnav"> &lt;openbook&gt; /</a><a href="index.htm" class="navnav"> Java-Insel</a></div></td>
<td align="right" width="25%"><div align="right"><a href="javainsel_14_006.htm" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" valign="top"><table width="100%" border="0" cellpadding="10" cellspacing="0" class="box">
<tr>
<td colspan="2"><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV" class="buchtitel">Java ist auch eine Insel</a><span class="autor"> von Christian Ullenboom </span><br><span class="untertitel">Das umfassende Handbuch</span></td>
</tr>
<tr>
<td valign="top" width="211"><dl>
<dt><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV" class="navnav"><img src="common/9783836215060.gif" border="0" alt="Buch: Java ist auch eine Insel" title="Buch: Java ist auch eine Insel"></a></dt>
<dd><br><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV"><span class="autor"><strong>Java ist auch eine Insel</strong><br>geb., mit DVD<br>1482 S., 49,90 Euro<br>Galileo Computing<br>ISBN 978-3-8362-1506-0</span></a></dd>
</dl></td>
<td width="80%"><table border="0">
<tr>
<td valign="baseline"><img src="common/pfeil_u.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="3" class="kap"><strong><a href="javainsel_14_001.htm#mj8c6f381221d805dd6fbe480731ac0c58" class="navnav">14 Threads und nebenläufige Programmierung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_14_001.htm#mjbc08c9ba7fdf2e6f67fc98569de436d7" class="navnav">14.1 Nebenläufigkeit</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_001.htm#mj43de7374f351a9fba442f8d3b0f02d3e" class="navnav">14.1.1 Threads und Prozesse</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_001.htm#mja9c21f6c79bc59a950217decf528edb6" class="navnav">14.1.2 Wie parallele Programme die Geschwindigkeit steigern können</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_001.htm#mj5562a2faec24834d623c76125dc07ce4" class="navnav">14.1.3 Was Java für Nebenläufigkeit alles bietet</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_14_002.htm#mj45ef6b526108a654e748170e45b47506" class="navnav">14.2 Threads erzeugen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_002.htm#mjd345a92a4debb2b6c1b71c9da5491844" class="navnav">14.2.1 Threads über die Schnittstelle Runnable implementieren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_002.htm#mj0165190038369a99536f97f8344a85aa" class="navnav">14.2.2 Thread mit Runnable starten</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_002.htm#mj8e1e70be702a313131e53009a9232b14" class="navnav">14.2.3 Die Klasse Thread erweitern</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_14_003.htm#mjd0f19999270d6e1fbfd4af3a16273eef" class="navnav">14.3 Thread-Eigenschaften und -Zustände</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_003.htm#mj3a1cfb56f9c6901e615807d90a0beec7" class="navnav">14.3.1 Der Name eines Threads</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_003.htm#mj35593f9059cd12233d0f6ecc9d1eabbc" class="navnav">14.3.2 Wer bin ich?</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_003.htm#mj06ce248fe2000330b7f17e9b7547230b" class="navnav">14.3.3 Die Zustände eines Threads *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_003.htm#mj00ef8d8369b2f161f338e0395d2d3375" class="navnav">14.3.4 Schläfer gesucht</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_003.htm#mjc55c89ec9366f4b8fdd423c85d3794c1" class="navnav">14.3.5 Mit »yield()« auf Rechenzeit verzichten</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_003.htm#mj2fe030afd882ac6fb143b967926afdfa" class="navnav">14.3.6 Der Thread als Dämon</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_003.htm#mj164ad9b22305873b9aa42eea993c3092" class="navnav">14.3.7 Das Ende eines Threads</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_003.htm#mj4193c6da30b5a3e9d41c167ec04d571f" class="navnav">14.3.8 Einen Thread höflich mit Interrupt beenden</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_003.htm#mj33fd0981eb8001536afe69cd515aa912" class="navnav">14.3.9 »UncaughtExceptionHandler« für unbehandelte Ausnahmen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_003.htm#mjaa35fb508fd076484f1fe6f102542192" class="navnav">14.3.10 Der »stop()« von außen und die Rettung mit ThreadDeath *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_003.htm#mj4d4380c02798d72c9129099992a3f7c1" class="navnav">14.3.11 Ein Rendezvous mit »join()« *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_003.htm#mj0fba9714c2dc96c5fdda5b22e6123a91" class="navnav">14.3.12 Arbeit niederlegen und wieder aufnehmen *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_003.htm#mjb80d2e0bed313429e1cc31b6b5533932" class="navnav">14.3.13 Priorität *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_14_004.htm#mj2f866e14a50f07accd817e14e068e022" class="navnav">14.4 Der Ausführer (Executor) kommt</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_004.htm#mjfdf7295f7b164c526b7e2bcc93c82c77" class="navnav">14.4.1 Die Schnittstelle »Executor«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_004.htm#mje4f944bb971775c1015afd48aaa0f8fd" class="navnav">14.4.2 Die Thread-Pools</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_004.htm#mj1b2390839194e0171bbe333adf513efb" class="navnav">14.4.3 Threads mit Rückgabe über Callable</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_004.htm#mj216a6d7dc56854a7c2ace2af15ea7538" class="navnav">14.4.4 Mehrere Callable abarbeiten</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_004.htm#mj040a06e4da6875dc988daed0e6698a0e" class="navnav">14.4.5 Mit ScheduledExecutorService wiederholende Ausgaben und Zeitsteuerungen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="#mjdd7f4718142f506c26dd21b125c3eeb9" class="navh">14.5 Synchronisation über kritische Abschnitte</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj0b86165a201ae570714e286c068b2481" class="navh">14.5.1 Gemeinsam genutzte Daten</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjfffb7cafaea36a3ca8312390e06292da" class="navh">14.5.2 Probleme beim gemeinsamen Zugriff und kritische Abschnitte</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjc042126cea52cb31673bce1b51e7da34" class="navh">14.5.3 Punkte parallel initialisieren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj93dd1d204a3132119782b90b9d2a8b91" class="navh">14.5.4 »i++« sieht atomar aus, ist es aber nicht *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj9311fe1d3b8eab7542264c02d389dd2f" class="navh">14.5.5 Kritische Abschnitte schützen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj56cc8d74bdebad1074cc9c5a8010bf9b" class="navh">14.5.6 Schützen mit ReentrantLock</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj1bb85cdbf7de3e53c2f4909006721fe5" class="navh">14.5.7 Synchronisieren mit »synchronized«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjcd4b04f6e98c720091cfe986e6ffbbcd" class="navh">14.5.8 Synchronized-Methoden der Klasse »StringBuffer« *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj06c1e7e183ad53dff9ca9f5f31845549" class="navh">14.5.9 Mit synchronized synchronisierte Blöcke</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj7dbd0ab9bb5f9d276c324109e3fca0e5" class="navh">14.5.10 Dann machen wir doch gleich alles synchronisiert!</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj7f86c2fcc6f66725145007cbca98aa8f" class="navh">14.5.11 Lock-Freigabe im Fall von Exceptions</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj835189eac360de56887ed92c5c4ecde5" class="navh">14.5.12 Deadlocks</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjac6b857b6e9b19e0ddd6f7047deb1927" class="navh">14.5.13 Mit »synchronized« nachträglich synchronisieren *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjef386e0ad0e4f81d20c24fc7013063a6" class="navh">14.5.14 Monitore sind reentrant &#8211; gut für die Geschwindigkeit *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj971b2acd022777011b0152eaa4837a24" class="navh">14.5.15 Synchronisierte Methodenaufrufe zusammenfassen *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_14_006.htm#mj9bf9f420b34b6f02276dafd31a8fd050" class="navnav">14.6 Synchronisation über Warten und Benachrichtigen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_006.htm#mje2b58ede047a8963da930acab3fa6052" class="navnav">14.6.1 Die Schnittstelle »Condition«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_006.htm#mjc38ef5b969bd2691779c81805b6c2a7c" class="navnav">14.6.2 It&#8217;s Disco-Time *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_006.htm#mj0ba218bd2eaf4ea985fe997b1df29eff" class="navnav">14.6.3 Warten mit »wait()« und Aufwecken mit »notify()« *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_006.htm#mj136bf82444e4726887b78ff7e2940dcb" class="navnav">14.6.4 Falls der Lock fehlt: IllegalMonitorStateException *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_14_007.htm#mj4145d5f8cf91e93d1d41e573c3d11ccc" class="navnav">14.7 Zeitgesteuerte Abläufe</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_007.htm#mjb1126ef61ae8b4987d341b8b5ca908bb" class="navnav">14.7.1 Die Klassen »Timer« und »TimerTask«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_14_007.htm#mjf6968022d786735ff347cc7539d4a5cc" class="navnav">14.7.2 Job-Scheduler Quartz</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_14_008.htm#mjd6f266fe3a93d82ea877896fff494d12" class="navnav">14.8 Einen Abbruch der virtuellen Maschine erkennen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_14_009.htm#mj97bf64dc1952296836c473e63db84371" class="navnav">14.9 Zum Weiterlesen</a></strong></td>
</tr>
</table><br></td>
</tr>
</table>
<table width="100%" cellpadding="20" cellspacing="0" border="0" bgcolor="#eeeeee">
<tr>
<td><div class="main"><a id="mjdd7f4718142f506c26dd21b125c3eeb9" name="mjdd7f4718142f506c26dd21b125c3eeb9"></a><a name="t21"></a><a name="t2t31"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div>
<h2 class="t2"><span class="cfett">14.5</span> Synchronisation über kritische Abschnitte  <a href="#t2t32"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><img src="common/15x15leer.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></h2>
<p>Wenn Threads in Java ein eigenständiges Leben führen, ist dieser Lebensstil nicht immer unproblematisch für andere Threads, insbesondere beim Zugriff auf gemeinsam genutzte Ressourcen. In den folgenden Abschnitten erfahren wir mehr über gemeinsam genutzte Daten und Schutzmaßnahmen beim konkurrierenden Zugriff durch mehrere Threads.</p><a id="mj0b86165a201ae570714e286c068b2481" name="mj0b86165a201ae570714e286c068b2481"></a><a name="t31"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t32"></a><h3 class="t3"><span class="cfett">14.5.1</span> Gemeinsam genutzte Daten  <a href="#t2t33"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t31"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Ein Thread besitzt zum einen seine eigenen Variablen, etwa die Objektvariablen, kann aber auch statische Variablen nutzen, wie das folgende Beispiel zeigt:</p>
<div class="listing"><pre class="prettyprint">class T extends Thread
{
 <span class="cfett"> static</span> int result;

  public void run() { ... }
}</pre></div>
<p>In diesem Fall können verschiedene Exemplare der Klasse <span class="clisting">T</span>, die jeweils einen Thread bilden, Daten austauschen, indem sie die Informationen in <span class="clisting">result</span> ablegen oder daraus entnehmen. Threads können aber auch an einer zentralen Stelle eine Datenstruktur erfragen und dort Informationen entnehmen oder Zugriff auf gemeinsame Objekte über eine Referenz bekommen. Es gibt also viele Möglichkeiten, wie Threads &#8211; und damit potenziell parallel ablaufende Aktivitäten &#8211; Daten austauschen können.</p><a id="mjfffb7cafaea36a3ca8312390e06292da" name="mjfffb7cafaea36a3ca8312390e06292da"></a><a name="t32"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t33"></a><h3 class="t3"><span class="cfett">14.5.2</span> Probleme beim gemeinsamen Zugriff und kritische Abschnitte  <a href="#t2t34"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t32"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Da Threads ihre eigenen Daten verwalten &#8211; sie haben alle eigene lokale Variablen und einen Stack &#8211;, kommen sie sich gegenseitig nicht in die Quere. Auch wenn mehrere Threads gemeinsame Daten nur lesen, ist das unbedenklich; Schreiboperationen sind jedoch kritisch. Wenn sich zehn Nutzer einen Drucker teilen, der die Ausdrucke nicht als unteilbare Einheit bündelt, lässt sich leicht ausmalen, wie das Ergebnis aussieht. Seiten, Zeilen oder gar einzelne Zeichen aus verschiedenen Druckaufträgen werden bunt gemischt ausgedruckt.</p>
<p>Die Probleme haben ihren Ursprung in der Art und Weise, wie die Threads umgeschaltet werden. Der Scheduler unterbricht zu einem uns unbekannten Zeitpunkt die Abarbeitung eines Threads und lässt den nächsten arbeiten. Wenn nun der erste Thread gerade Programmzeilen abarbeitet, die zusammengehören, und der zweite Thread beginnt, parallel auf diesen Daten zu arbeiten, ist der Ärger vorprogrammiert. Wir müssen also Folgendes ausdrücken können: Wenn ich den Job mache, dann möchte ich der Einzige sein, der die Ressource &#8211; etwa einen Drucker &#8211; nutzt. Erst nachdem der Drucker den Auftrag eines Benutzers fertiggestellt hat, darf er den nächsten in Angriff nehmen.</p>
<h4 class="t4">Kritische Abschnitte</h4>
<p>Zusammenhängende Programmblöcke, denen während der Ausführung von einem Thread kein anderer Thread reinwurschteln sollte und die daher besonders geschützt werden müssen, nennen sich <span class="ckursiv">kritische Abschnitte</span>. Wenn lediglich ein Thread den Programmteil abarbeitet, dann nennen wir dies <span class="ckursiv">gegenseitigen Ausschluss</span> oder <span class="ckursiv">atomar</span>. Wir könnten das etwas lockerer sehen, wenn wir wüssten, dass innerhalb der Programmblöcke nur von den Daten gelesen wird. Sobald aber nur ein Thread Änderungen vornehmen möchte, ist ein Schutz nötig. Denn arbeitet ein Programm bei nebenläufigen Threads falsch, ist es nicht <span class="ckursiv">thread-sicher</span> (engl. <span class="ckursiv">thread-safe</span>).</p>
<p>Wir werden uns nun Beispiele für kritische Abschnitte anschauen und dann sehen, wie wir diese in Java realisieren können.</p>
<h4 class="t4">Nicht kritische Abschnitte</h4>
<p>Wenn mehrere Threads auf das gleiche Programmstück zugreifen, muss das nicht zwangsläufig zu einem Problem führen, und Thread-Sicherheit ist immer gegeben. Immutable Objekte &#8211; nehmen wir an, ein Konstruktor belegt einmalig die Zustände &#8211; sind automatisch thread-sicher, da es keine Schreibzugriffe gibt und bei Lesezugriffen nichts schiefgehen kann. Immutable-Klassen wie <span class="clisting">String</span> oder Wrapper-Klassen kommen daher ohne Synchronisierung aus.</p>
<p>Das Gleiche gilt für Methoden, die keine Objekteigenschaften verändern. Da jeder Thread seine Thread-eigenen Variablen besitzt &#8211; jeder Thread hat einen eigenen Stack &#8211;, können lokale Variablen, auch Parametervariablen, beliebig gelesen und geschrieben werden. Wenn zum Beispiel zwei Threads die folgende statische Utility-Methode aufrufen, ist das kein Problem:</p>
<div class="listing"><pre class="prettyprint">public static String reverse( String s )
{
  return new StringBuilder( s ).reverse().toString();
}</pre></div>
<p>Jeder Thread wird eine eigene Variablenbelegung für <span class="clisting">s</span> haben und ein temporäres Objekt vom Typ <span class="clisting">StringBuilder</span> referenzieren.</p>
<h4 class="t4">Thread-sichere und nicht thread-sichere Klassen der Java Bibliothek</h4>
<p>Es gibt in Java viele Klassen, die nicht thread-sicher sind &#8211; das ist sogar der Standard. So sind etwa alle <span class="clisting">Format</span>-Klassen, wie <span class="clisting">MessageFormat, NumberFormat, DecimalFormat</span>, <span class="clisting">ChoiceFormat</span>, <span class="clisting">DateFormat</span> und <span class="clisting">SimpleDateFormat</span>, nicht für den nebenläufigen Zugriff gemacht. In der Regel steht das in der JavaDoc, etwa bei <span class="clisting">DateFormat</span>:</p>
<p><em><span class="ckursiv">»Synchronization. Date formats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally.«</span></em></p>
<p>Wer also Objekte nebenläufig verwendet, der sollte immer in der Java API-Dokumentation nachschlagen, ob es dort einen Hinweis gibt, ob die Objekte überhaupt thread-sicher sind.</p>
<p>In einigen wenigen Fällen haben Entwickler die Wahl zwischen thread-sicheren und nicht-thread-sicheren Klassen:</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 14.3    </strong>Thread-sichere und nicht thread-sichere Klassen</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">Nicht thread-sicher</span>
</td>
<td class="tabellenkopf"><span class="cfett">Thread-sicher</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">StringBuilder</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">StringBuffer</span></p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">ArrayList</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">Vector</span></p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">HashMap</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">Hashtable</span></p>
</td>
</tr>
</table><br><p>Obwohl es die Auswahl bei den Datenstrukturen im Prinzip gibt, werden <span class="clisting">Vector</span> und <span class="clisting">Hashtable</span> dennoch nicht verwendet. Wir haben uns darum bereits in Kapitel 13, »Datenstrukturen und Algorithmen«, gekümmert.</p><a id="mjc042126cea52cb31673bce1b51e7da34" name="mjc042126cea52cb31673bce1b51e7da34"></a><a name="t33"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t34"></a><h3 class="t3"><span class="cfett">14.5.3</span> Punkte parallel initialisieren  <a href="#t2t35"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t33"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Nehmen wir an, ein Thread T1 möchte ein <span class="clisting">Point</span>-Objekt <span class="clisting">p</span> mit den Werten (1,1) und ein zweiter Thread T2 eine Belegung mit den Werten (2,2) durchführen.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellenkopf"><span class="cfett">Thread T1</span>
</td>
<td class="tabellenkopf"><span class="cfett">Thread T2</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">p.x = 1;
p.y = 1;</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">p.x = 2;
p.y = 2;</span></p>
</td>
</tr>
</table><br><p>Beide Threads können natürlich bei einem 2 Kern-Prozessor parallel arbeiten, aber da sie auf gemeinsame Variablen zugreifen, ist der Zugriff auf <span class="clisting">x</span> bzw. <span class="clisting">y</span> von <span class="clisting">p</span> trotzdem sequenziell. Um es nicht allzu kompliziert zu machen, vereinfachen wir unser Ausführungsmodell, dass wir zwar zwei Threads laufen haben, aber nur jeweils einer ausgeführt wird. Dann ist es möglich, dass T1 mit der Arbeit beginnt und x = 1 setzt. Da der Thread-Scheduler einen Thread jederzeit unterbrechen kann, kann nun T2 an die Reihe kommen, der x = 2 und y = 2 setzt. Wird dann T1 wieder Rechenzeit zugeteilt, darf T1 an der Stelle weitermachen, wo er aufgehört hat, und y = 1 folgt. In einer Tabelle ist das Ergebnis noch besser zu sehen:</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellenkopf"><span class="cfett">Thread T1</span>
</td>
<td class="tabellenkopf"><span class="cfett">Thread T2</span>
</td>
<td class="tabellenkopf"><span class="cfett">x/y</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">p.x = 1;</span></p>
</td>
<td class="tabellentext"> </td>
<td class="tabellentext">
<p>1/0</p>
</td>
</tr>
<tr>
<td class="tabellentext"> </td>
<td class="tabellentext">
<p><span class="clisting">p.x = 2;</span></p>
</td>
<td class="tabellentext">
<p>2/0</p>
</td>
</tr>
<tr>
<td class="tabellentext"> </td>
<td class="tabellentext">
<p><span class="clisting">p.y = 2;</span></p>
</td>
<td class="tabellentext">
<p>2/2</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">p.y = 1;</span></p>
</td>
<td class="tabellentext"> </td>
<td class="tabellentext">
<p>2/1</p>
</td>
</tr>
</table><br><p>Wir erkennen das nicht beabsichtigte Ergebnis (2,1), es könnte aber auch (1,2) sein, wenn wir das gleiche Szenario beginnend mit T2 durchführen. Je nach zuerst abgearbeitetem Thread wäre jedoch nur (1,1) oder (2,2) korrekt. Die Threads sollen ihre Arbeit aber atomar erledigen, denn die Zuweisung bildet einen kritischen Abschnitt, der geschützt werden muss. Standardmäßig sind die zwei Zuweisungen nicht-atomare Operationen und können unterbrochen werden. Um dies an einem Beispiel zu zeigen, sollen zwei Threads ein <span class="clisting">Point</span>-Objekt verändern. Die Threads belegen x und y immer gleich, und immer dann, wenn sich die Koordinaten unterscheiden, soll es eine Meldung geben:</p>
<p class="tabunter"><strong>Listing 14.15    </strong>com/tutego/insel/thread/concurrent/ParallelPointInit.java, main()</p>
<div class="listing"><pre class="prettyprint">final Point p = new Point();

Runnable r = new Runnable()
{
  @Override public void run()
  {
    int x = (int)(Math.random() * 1000), y = x;

    while ( true )
    {
      p.x = x; p.y = y;            // *

      int xc = p.x, yc = p.y;      // *

      if ( xc != yc )
        System.out.println( "Aha: x=" + xc + ", y=" + yc );
    }
  }
};

new Thread( r ).start();
new Thread( r ).start();</pre></div>
<p>Die interessanten Zeilen sind mit * markiert. <span class="clisting">p.x = x; p.y = y;</span> belegt die Koordinaten neu, und <span class="clisting">int xc = p.x, yc = p.y;</span> liest die Koordinaten erneut aus. Würden Belegung und Auslesen in einem Rutsch passieren, dürfte überhaupt keine unterschiedliche Belegung von <span class="clisting">x</span> und <span class="clisting">y</span> zu finden sein. Doch das Beispiel zeigt es anders:</p>
<div class="listing"><pre class="prettyprint">Aha: x=58, y=116
Aha: x=116, y=58
Aha: x=58, y=116
Aha: x=58, y=116
...</pre></div>
<p>Was wir mit den parallelen Punkten vor uns haben, sind Effekte, die von den Ausführungszeiten der einzelnen Operationen abhängen. In Abhängigkeit von dem Ort der Unterbrechung wird ein fehlerhaftes Verhalten produziert. Dieses Szenario nennt sich im Englischen <span class="ckursiv">race condition</span> beziehungsweise <span class="ckursiv">race hazard</span> (zu Deutsch auch <span class="ckursiv">Wettlaufsituation</span>).</p><a id="mj93dd1d204a3132119782b90b9d2a8b91" name="mj93dd1d204a3132119782b90b9d2a8b91"></a><a name="t34"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t35"></a><h3 class="t3"><span class="cfett">14.5.4</span> »i++« sieht atomar aus, ist es aber nicht *  <a href="#t2t36"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t34"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Das Beispiel vorhin ist plastisch und einleuchtend, weil zwischen Anweisungen unterbrochen werden kann. Das Problem liegt aber noch tiefer. Schon einfache Anweisungen wie <span class="clisting">i++</span> müssen geschützt werden. Um dies zu verstehen, wollen wir einen Blick auf folgende Zeilen werfen:</p>
<p class="tabunter"><strong>Listing 14.16    </strong>com/tutego/insel/thread/IPlusPlus.java, IPlusPlus</p>
<div class="listing"><pre class="prettyprint">public class IPlusPlus
{
  static int i;
  static void foo()
  {
   i++;
  }
}</pre></div>
<p>Die Objektmethode <span class="clisting">foo()</span> erhöht die statische Variable <span class="clisting">i</span>. Um zu erkennen, dass <span class="clisting">i++</span> ein kritischer Abschnitt ist, sehen wir uns den dazu generierten Bytecode [Machbar zum Beispiel mit dem jeder Java-Distribution beiliegenden Dienstprogramm <span class="ckursiv">javap</span> und der Option <span class="ckursiv">-c</span>.
]  für die Methode <span class="clisting">foo()</span> an:</p>
<div class="listing"><pre class="prettyprint">0 getstatic #19 &lt;Field int i&gt;
3 iconst_1
4 iadd
5 putstatic #19 &lt;Field int i&gt;
8 return</pre></div>
<p>Die einfach aussehende Operation <span class="clisting">i++</span> ist also etwas komplizierter. Zuerst wird <span class="clisting">i</span> gelesen und auf dem Stack abgelegt. Danach wird die Konstante 1 auf den Stack gelegt, und anschließend addiert <span class="clisting">iadd</span> beide Werte. Das Ergebnis steht wiederum auf dem Stack und wird von <span class="clisting">putstatic</span> zurück in <span class="clisting">i</span> geschrieben.</p>
<p>Wenn jetzt auf die Variable <span class="clisting">i</span> von zwei Threads A und B gleichzeitig zugegriffen wird, kann folgende Situation eintreten:</p>
<ul class="gp">
<li>Thread A holt sich den Wert von <span class="clisting">i</span> in den internen Speicher, wird dann aber unterbrochen. Er kann das um 1 erhöhte Resultat nicht wieder <span class="clisting">i</span> zuweisen.</li>
</ul>
<ul class="gp">
<li>Nach der Unterbrechung von A kommt Thread B an die Reihe. Auch er besorgt sich <span class="clisting">i</span>, kann aber <span class="clisting">i + 1</span> berechnen und das Ergebnis in <span class="clisting">i</span> ablegen. Dann ist B beendet, und der Scheduler beachtet Thread A.</li>
</ul>
<ul class="gp">
<li>Jetzt steht in <span class="clisting">i</span> das von Thread B um 1 erhöhte <span class="clisting">i</span>. Thread A addiert nun 1 zu dem gespeicherten alten Wert von <span class="clisting">i</span> und schreibt dann nochmals denselben Wert wie Thread B zuvor. Insgesamt wurde die Variable <span class="clisting">i</span> nur um 1 erhöht, obwohl zweimal inkrementiert werden sollte. Jeder Thread hat für sich gesehen das korrekte Ergebnis berechnet.</li>
</ul>
<p>Wenn wir unsere Methode <span class="clisting">foo()</span> atomar ausführen, haben wir das Problem nicht mehr, weil das Lesen aus <span class="clisting">i</span> und das Schreiben zusammen einen unteilbaren, kritischen Abschnitt bilden.</p><a id="mj9311fe1d3b8eab7542264c02d389dd2f" name="mj9311fe1d3b8eab7542264c02d389dd2f"></a><a name="t35"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t36"></a><h3 class="t3"><span class="cfett">14.5.5</span> Kritische Abschnitte schützen  <a href="#t2t37"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t35"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Beginnen wir mit einem anschaulichen Alltagsbeispiel. Gehen wir aufs Klo, schließen wir die Tür hinter uns. Möchte jemand anderes auf die Toilette, muss er warten. Vielleicht kommen noch mehrere dazu, die müssen dann auch warten, und eine Warteschlage bildet sich. Dass die Toilette besetzt ist, signalisiert die abgeschlossene Tür. Jeder Wartende muss so lange vor dem Klo ausharren, bis das Schloss geöffnet wird, selbst wenn der auf der Toilette Sitzende nach einer langen Nacht einnicken sollte.</p>
<p>Wie übertragen wir das auf Java? Soll die Laufzeitumgebung nur einen Thread in einen Block lassen, ist ein <span class="ckursiv">Monitor</span> [Der Begriff geht auf C. A. R. Hoare zurück, der in seinem Aufsatz »Communicating Sequential Processes« von 1978 erstmals dieses Konzept veröffentlichte.
]  nötig. Ein Monitor wird mithilfe eines <span class="ckursiv">Locks</span> (zu Deutsch »Schloss«) realisiert, welches ein Thread öffnet oder schließt. Tritt ein Thread in den kritischen Abschnitt ein, muss Programmcode wie eine Tür abgeschlossen werden (engl. <span class="ckursiv">lock</span>). Erst wenn der Abschnitt durchlaufen wurde, darf die Tür wieder aufgeschlossen werden (engl. <span class="ckursiv">unlock</span>), und ein anderer Thread kann den Abschnitt betreten.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Ein anderes Wort für Lock ist <span class="ckursiv">Mutex</span> (engl. <span class="ckursiv">mutual exclusion</span>, also »gegenseitiger Ausschluss«). Der Begriff »Monitor« wird oft gleichgesetzt mit Lock (Mutex), doch kann ein Monitor mit Warten/Benachrichtigen mehr als ein klassischer Lock. In der Definition der Sprache Java (JLS Kapitel 17) tauchen die Begriffe Mutex und Lock allerdings nicht auf; die Autoren sprechen nur von den Monitor-Aktionen <span class="ckursiv">lock</span> und <span class="ckursiv">unlock</span>. Die Java Virtual Machine definiert dafür die Opcodes <span class="clisting">monitorenter</span> und <span class="clisting">monitorexit</span>.</p>
</td>
</tr>
</table><br><h4 class="t4">Java-Konstrukte zum Schutz der kritischen Abschnitte</h4>
<p>Wenn wir auf unser Punkte-Problem zurückkommen, so stellen wir fest, dass zwei Zeilen auf eine Variable zugreifen:</p>
<div class="listing"><pre class="prettyprint">p.x = x; p.y = y;
int xc = p.x, yc = p.y;</pre></div>
<p>Diese beiden Zeilen bilden also einen kritischen Abschnitt, den jeweils nur ein Thread betreten darf. Wenn also einer der Threads mit <span class="clisting">p.x = x</span> beginnt, muss er so lange den exklusiven Zugriff bekommen, bis er mit <span class="clisting">yc = p.y</span> endet.</p>
<p>Aber wie wird nun ein kritischer Abschnitt bekannt gegeben? Zum Markieren und Abschließen dieser Bereiche gibt es zwei Konzepte: [Vereinfachte Darstellung, später mehr.
] </p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 14.4    </strong>Lock-Konzepte</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">Konstrukt</span>
</td>
<td class="tabellenkopf"><span class="cfett">eingebautes Schlüsselwort</span>
</td>
<td class="tabellenkopf"><span class="cfett">Java Standardbibliothek</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="cfett">Schlüsselwort/Typen</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">synchronized</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">java.util.concurrent.locks.Lock</span></p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="cfett">Nutzungsschema</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">synchronized
{</span>
  <span class="clisting">Tue1</span>
  <span class="clisting">Tue2
}</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">lock.lock();
{</span>
  <span class="clisting">Tue1</span>
  <span class="clisting">Tue2
}
lock.unlock();</span>6</p>
</td>
</tr>
</table><br><p>Beim <span class="clisting">synchronized</span> entsteht Bytecode, der der JVM sagt, dass ein kritischer Block beginnt und endet. So überwacht die JVM, ob ein zweiter Thread warten muss, wenn er in einen synchronisierten Block eintritt, der schon von einem Thread ausgeführt wird. Bei <span class="clisting">Lock</span> ist das Ein- und Austreten explizit vom Entwickler programmiert, und vergisst er das, ist das ein Problem. Und während bei der <span class="clisting">Lock</span>-Implementierung das Objekt, an dem synchronisiert wird, offen hervortritt, ist das bei <span class="clisting">synchronized</span> nicht so offensichtlich. Hier gilt es zu wissen, dass jedes Objekt in Java implizit mit einem Monitor verbunden ist. Auf diesen Unterschied kommen wir in Abschnitt 14.5.9, »Mit synchronized synchronisierte Blöcke«, noch einmal zurück. Da moderne Programme aber mittlerweile mit <span class="clisting">Lock</span>-Objekten arbeiten, tritt die <span class="clisting">synchronized</span>-Möglichkeit, die schon Java 1.0 zur Synchronisation bot, etwas in den Hintergrund.</p>
<p>Fassen wir zusammen: Nicht thread-sichere Abschnitte müssen geschützt werden. Sie können entweder mit <span class="clisting">synchronized</span> geschützt werden, bei denen implizit der Eintritt und Austritt geregelt ist, oder durch <span class="clisting">Lock</span>-Objekte. Befindet sich dann ein Thread in einem geschützten Block und möchte ein zweiter Thread in den Abschnitt, muss er so lange warten, bis der erste Thread den Block wieder freigibt. So ist die Abarbeitung über mehrere Threads einfach synchronisiert, und das Konzept eines Monitors gewährleistet seriellen Zugriff auf kritische Ressourcen. Die kritischen Bereiche sind nicht per se mit einem Monitor verbunden, sondern werden eingerahmt und dieser Rahmen ist mit einem Monitor (Lock) verbunden.</p>
<p>Mit dem Abschließen und Aufschließen werden wir uns noch intensiver in den folgenden Abschnitten beschäftigen.</p><a id="mj56cc8d74bdebad1074cc9c5a8010bf9b" name="mj56cc8d74bdebad1074cc9c5a8010bf9b"></a><a name="t36"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t37"></a><h3 class="t3"><span class="cfett">14.5.6</span> Schützen mit ReentrantLock  <a href="#t2t38"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t36"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Seit Java 5 gibt es die Schnittstelle <span class="clisting">Lock</span>, mit der sich ein kritischer Block markieren lässt. Ein Abschnitt beginnt mit <span class="clisting">lock()</span> und endet mit <span class="clisting">unlock()</span>:</p>
<p class="tabunter"><strong>Listing 14.17    </strong>com/tutego/insel/thread/concurrent/ParallelPointInitSync.java, main()</p>
<div class="listing"><pre class="prettyprint"><span class="cfett">final Lock lock = new ReentrantLock();</span>
final Point p = new Point();

Runnable r = new Runnable()
{
  @Override public void run()
  {
    int x = (int)(Math.random() * 1000), y = x;

    while ( true )
    {
     <span class="cfett"> lock.lock();
</span><span class="clisting">
      p.x = x; p.y = y;            // *
      int xc = p.x, yc = p.y;      // *
</span><span class="cfett">
      lock.unlock();
</span><span class="clisting">
      if ( xc != yc )
        System.out.println( "Aha: x=" + xc + ", y=" + yc );
    }
  }
};

new Thread( r ).start();
new Thread( r ).start();</span></pre></div>
<p>Mit dieser Implementierung wird keine Ausgabe auf dem Bildschirm folgen.</p>
<h4 class="t4">Die Schnittstelle java.util.concurrent.locks.Lock</h4>
<p><span class="clisting">Lock</span> ist eine Schnittstelle, von der <span class="clisting">ReentrantLock</span> die wichtigste Implementierung ist. Mit ihr lässt sich der Block betreten und verlassen.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p><span class="clisting">interface java.util.concurrent.locks.</span><span class="cfett">Lock</span></p>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">void lock()</span>
Wartet so lange, bis der ausführende Thread den kritischen Abschnitt betreten kann, und markiert ihn dann als betreten. Hat schon ein anderer Thread an diesem <span class="clisting">Lock</span>-Objekt ein <span class="clisting">lock()</span> aufgerufen, muss der aktuelle Thread warten, bis der Lock wieder frei ist. Hat der aktuelle Thread schon den Lock, kann er bei der Implementierung <span class="clisting">ReentrantLock</span> wiederum <span class="clisting">lock()</span> aufrufen und sperrt sich nicht selbst.</li>
</ul>
<ul class="gp">
<li><span class="clisting">boolean tryLock()</span>
Wenn der kritische Abschnitt sofort betreten werden kann, ist die Funktionalität wie bei <span class="clisting">lock()</span>, und die Rückgabe ist <span class="clisting">true</span>. Ist der Lock gesetzt, so wartet die Methode nicht wie <span class="clisting">lock()</span>, sondern kehrt mit einem <span class="clisting">false</span> zurück.</li>
</ul>
<ul class="gp">
<li><span class="clisting">boolean tryLock( long time, TimeUnit unit ) throws InterruptedException</span>
Versucht in der angegebenen Zeitspanne den Lock zu bekommen. Das Warten kann mit <span class="clisting">interrupt()</span> auf dem Thread unterbrochen werden, was <span class="clisting">tryLock()</span> mit einer Exception beendet.</li>
</ul>
<ul class="gp">
<li><span class="clisting">void unlock()</span>
Verlässt den kritischen Block.</li>
</ul>
<ul class="gp">
<li><span class="clisting">void lockInterruptibly() throws InterruptedException</span>
Wartet wie <span class="clisting">lock()</span>, um den kritischen Abschnitt betreten zu dürfen, kann aber mit einem <span class="clisting">interrupt()</span> von außen abgebrochen werden (der <span class="clisting">lock()</span>-Methode ist ein Interrupt egal). Implementierende Klassen müssen diese Vorgabe nicht zwingend umsetzen, sondern können die Methode auch mit einem einfachen <span class="clisting">lock()</span> realisieren. <span class="clisting">ReentrantLock</span> implementiert <span class="clisting">lockInterruptibly()</span> erwartungsgemäß.</li>
</ul><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" rowspan="2">
<p class="BStandard"><span class="cfett">Beispiel   </span>Wenn wir sofort in den kritischen Abschnitt gehen können, tun wir das; sonst etwas anderes:</p>
<div class="listing"><pre class="prettyprint">Lock lock = ...;
if ( <span class="cfett">lock.tryLock()</span> )
{
  try {
    ...
  }
  finally { lock.unlock(); }
}
else
  ...</pre></div>
</td>
</tr>
</table><br><p>Die Implementierung <span class="clisting">ReentrantLock</span> kann noch ein bisschen mehr als <span class="clisting">lock()</span> und <span class="clisting">unlock()</span>:</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p><span class="clisting">class java.util.concurrent.locks.</span><span class="cfett">ReentrantLock</span><span class="clisting">
implements Lock, Serializable</span></p>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">ReentrantLock()</span>
Erzeugt ein neues Lock-Objekt, das nicht dem am längsten Wartenden den ersten Zugriff gibt.</li>
</ul>
<ul class="gp">
<li><span class="clisting">ReentrantLock( boolean fair )</span>
Erzeugt ein neues Lock-Objekt mit fairem Zugriff, gibt also dem am längsten Wartenden den ersten Zugriff.</li>
</ul>
<ul class="gp">
<li><span class="clisting">boolean isLocked()</span>
Anfrage, ob der Lock gerade genutzt wird und im Moment kein Betreten möglich ist.</li>
</ul>
<ul class="gp">
<li><span class="clisting">final int getQueueLength()</span>
Ermittelt, wie viele auf das Betreten des Blocks warten.</li>
</ul>
<ul class="gp">
<li><span class="clisting">int getHoldCount()</span>
Gibt die Anzahl der erfolgreichen <span class="clisting">lock()</span>-Aufrufe ohne passendes <span class="clisting">unlock()</span> zurück. Sollte nach Beenden des Vorgangs 0 sein.</li>
</ul>
<div class="bildbox">
<p><a name="IDALMZD"></a><a onClick="OpenWin('bilder/lockreentrantlockuml.gif','Abbildung',800,800)"><img border="0" src="bilderklein/kleinlockreentrantlockuml.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Das Warten auf den Lock kann unterbrochen werden:</p>
<div class="listing"><pre class="prettyprint">Lock l = new ReentrantLock();
try
{
  <span class="cfett">l.lockInterruptibly();</span>
  try
  {
   ...
  }
  finally { l.unlock(); }
}
catch ( InterruptedException e ) { ...</pre></div>
<p class="BStandard">Wenn wir den Lock nicht bekommen haben, dürfen wir ihn auch nicht freigeben!</p>
</td>
</tr>
</table><br><h4 class="t4">ReentrantReadWriteLock</h4>
<p>Unsere Klasse <span class="clisting">ReentrantLock</span> blockt bei jedem <span class="clisting">lock()</span> und lässt keinen Interessenten in den kritischen Abschnitt. Viele Szenarien sind jedoch nicht so streng, und so kommt es zu Situationen, in denen lesender Zugriff durchaus von mehreren Parteien möglich ist, schreibender Zugriff aber blockiert wird.</p>
<div class="bildbox">
<p><a name="IDAUNZD"></a><a onClick="OpenWin('bilder/readwritelockuml.gif','Abbildung',800,800)"><img border="0" src="bilderklein/kleinreadwritelockuml.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p>Für diese Lock-Situation gibt es die Schnittstelle <span class="clisting">ReadWriteLock</span>, die nicht von <span class="clisting">Lock</span> abgeleitet ist, sondern mit <span class="clisting">readLock()</span> und <span class="clisting">writeLock()</span> die Lock-Objekte liefert. Die bisher einzige Implementierung der Schnittstelle ist <span class="clisting">java.util.concurrent.locks.ReentrantReadWrite-Lock</span>. Ein Programmausschnitt könnte so aussehen:</p>
<div class="listing"><pre class="prettyprint">ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
try
{
  lock.readLock().lock();
  ...
}
finally
{
  lock.readLock().unlock();
}</pre></div>
<h4 class="t4">Schreiben sperren, lesen durchlassen *</h4>
<p>In Java sind drei Typen von Datenstrukturen essenziell: Listen (dynamische Felder), Mengen (Elemente gibt es nur einmal) und Assoziativspeicher (ein Objekt ist mit einem anderen Objekt verbunden). Die Operationen der Datenstrukturen beschreiben Schnittstellen und konkrete Klassen realisieren sie. Dabei sind drei Implementierungen hervorzuheben: <span class="clisting">ArrayList</span> (Implementierung für Listen), <span class="clisting">TreeSet</span> (sortierte Menge), <span class="clisting">HashSet</span> (Assoziativspeicher). Eine Besonderheit der meisten <span class="clisting">java.util</span>-Klassen ist, dass sie nicht gegen nebenläufige Zugriffe gesichert sind, also Datenmüll enthalten können, wenn mehrere Threads gleichzeitig Operationen durchführen.</p>
<p>Java bietet zwar auch thread-sichere Datenstrukturen, doch wollen wir mit <span class="clisting">ReentrantReadWriteLock</span> zwei Datenstrukturen nachträglich synchronisieren, sodass Lesezugriffe parallel erlaubt und Schreibzugriffe nur atomar sind.</p>
<p>Nehmen wir an, eine Liste soll Strings speichern. Dann müssen wir das <span class="clisting">get()</span> über den Lese-<span class="clisting">Lock</span> anmelden und das <span class="clisting">set()</span> über den Schreib-<span class="clisting">Lock</span> sperren. Das Ganze sieht so aus:</p>
<p class="tabunter"><strong>Listing 14.18    </strong>com/tutego/insel/thread/concurrent/ConcurrentReadWriteStringList.java, ConcurrentReadWriteStringList</p>
<div class="listing"><pre class="prettyprint">private final List&lt;String&gt; list = new ArrayList&lt;String&gt;();
private final<span class="cfett"> ReentrantReadWriteLock lock = new ReentrantReadWriteLock();</span>
private final<span class="cfett"> Lock readLock  = lock.readLock();</span>
private final<span class="cfett"> Lock writeLock = lock.writeLock();

public String get( int index )
{
  readLock.lock();</span>
  try
  {
    return list.get( index );
  }
  finally
  {
   <span class="cfett"> readLock.unlock();</span>
  }
}

public void add( int index, String element )
{
 <span class="cfett"> writeLock.lock();</span>
  try
  {
    list.add( index, element );
  }
  finally
  {
   <span class="cfett"> writeLock.unlock();</span>
  }
}</pre></div>
<p>Der <span class="clisting">readLock</span> und der <span class="clisting">writeLock</span> kommen zwingend vom gleichen <span class="clisting">ReentrantReadWriteLock</span> und koordinieren sich dadurch.</p>
<p>Die Absicherung, dass beliebig viele Leser, aber nur ein Schreiber erlaubt sind, sieht in der Programmierung immer gleich aus. Daher noch ein zweites Beispiel. <span class="clisting">HashMap</span> ist eine Java-Klasse, die über <span class="clisting">put()</span> eine Assoziation herstellt und über <span class="clisting">get()</span> erfragt. Im Unterschied zum vorangehenden Beispiel ist die von uns angebotene Datenstruktur selbst generisch deklariert:</p>
<p class="tabunter"><strong>Listing 14.19    </strong>com/tutego/insel/thread/concurrent/ConcurrentReadWriteMap.java</p>
<div class="listing"><pre class="prettyprint">package com.tutego.insel.thread.concurrent;

import java.util.*;
import java.util.concurrent.locks.*;

public class ConcurrentReadWriteMap&lt;K,V&gt;
{
  private final HashMap&lt;K, V&gt;  map       = new HashMap&lt;K,V&gt;();
  private final ReadWriteLock  lock      = new ReentrantReadWriteLock();
  private final Lock           readLock  = lock.readLock(),
                               writeLock = lock.writeLock();

  public V get( K key )
  {
    readLock.lock();
    try {
      return map.get( key );
    }
    finally {
      readLock.unlock();
    }
  }

  public V put( K key, V value )
  {
    writeLock.lock();
    try {
      return map.put( key, value );
    }
    finally {
      writeLock.unlock();
    }
  }

  public void clear()
  {
    writeLock.lock();
    try {
      map.clear();
    }
    finally {
      writeLock.unlock();
    }
  }
}</pre></div><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Die Java-Bibliothek verfügt im Paket <span class="clisting">java.util.concurrent</span> über einige Datenstrukturen, die speziell für den nebenläufigen Zugriff geschrieben wurden. <span class="clisting">ConcurrentHashMap</span> ist eine sehr performante Klasse für sichere parallele Lese-/Schreibzugriffe.</p>
</td>
</tr>
</table><br><a id="mj1bb85cdbf7de3e53c2f4909006721fe5" name="mj1bb85cdbf7de3e53c2f4909006721fe5"></a><a name="t37"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t38"></a><h3 class="t3"><span class="cfett">14.5.7</span> Synchronisieren mit »synchronized«  <a href="#t2t39"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t37"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Schon seit Java 1.0 können kritische Abschnitte mit <span class="clisting">synchronized</span> geschützt werden. Im einfachsten Fall markiert der Modifizierer <span class="clisting">synchronized</span> die gesamte Methode. Ein betretender Thread setzt bei Objektmethoden den Monitor des <span class="clisting">this</span>-Objekts und bei statischen Methoden den Lock des dazugehörigen <span class="clisting">Class</span>-Objekts.</p>
<p>Betritt ein Thread A eine synchronisierte Methode eines Objekts O und versucht anschließend Thread B eine synchronisierte Methode des gleichen Objekts O aufzurufen, muss der nachfolgende Thread B so lange warten, bis A wieder aus dem synchronisierten Teil austritt. Das geschieht, wenn der erste Thread A die Methode verlässt, denn mit dem Verlassen einer Methode &#8211; oder auch einer Ausnahme &#8211; gibt die JVM automatisch den Lock frei. Die Dauer eines Locks hängt folglich mit der Dauer des Methodenaufrufs zusammen, was zur Konsequenz hat, dass längere kritische Abschnitte die Parallelität einschränken und zu längeren Wartezeiten führen. Eine Endlosschleife in der synchronisierten Methode gäbe den Lock niemals frei.</p>
<p>Das aus <span class="ckursiv">IPlusPlus.java</span> bekannte Problem mit dem <span class="clisting">i++</span> lässt sich mit <span class="clisting">synchronized</span> einfach lösen:</p>
<div class="listing"><pre class="prettyprint">synchronized void foo() { i++; }</pre></div>
<p>Bei einem Konflikt (mehrere Threads rufen <span class="clisting">foo()</span> auf) verhindert <span class="clisting">synchronized</span>, dass sich mehr als ein Thread gleichzeitig im kritischen Abschnitt, dem Rumpf der Methode <span class="clisting">foo()</span>, befinden kann. Dies bezieht sich nur auf mehrere Aufrufe von <span class="clisting">foo()</span> für dasselbe Objekt. Zwei verschiedene Threads können durchaus parallel die Methode <span class="clisting">foo()</span> für unterschiedliche Objekte ausführen.</p>
<p>Neben diesem speziellen Problem für atomares Verändern von Variablen lassen sich auch Klassen aus dem Paket <span class="clisting">java.util.concurrent.atomic</span> verwenden.</p>
<p><div class="eclipse"><img src="common/eclipseicon.gif" align="top" width="53" height="23" alt="Eclipse" title="Eclipse"></div>Bei einem orthografisch anspruchsvollen Wort wie <span class="clisting">synchronized</span> ist es praktisch, dass Eclipse auch Schlüsselwörter vervollständigt. Hier reicht ein Tippen von <span class="cfett">sync</span> und 
    <span class="tastenkappe">Strg</span>
  +Leertaste für einen Dialog.</p>
<h4 class="t4">Hat der aktuelle Thread den Lock? *</h4>
<p>Die statische Methode <span class="clisting">Thread.holdsLock()</span> zeigt an, ob der aktuelle Thread den Lock hält.</p>
<p class="tabunter"><strong>Listing 14.20    </strong>com/tutego/insel/thread/HoldsLockDemo.java, main()</p>
<div class="listing"><pre class="prettyprint">final Object obj = new Object();
System.out.println( Thread.holdsLock(obj) );     // false
synchronized ( obj )
{
  System.out.println( Thread.holdsLock(obj) );   // true
}</pre></div>
<p>Und <span class="clisting">Thread.holdsLock(this)</span> wird etwa in einer Objektmethode feststellen können, ob der Lock durch eine synchronisierte Methode oder einen <span class="clisting">synchronized(this)</span>-Block gelockt ist.</p><a id="mjcd4b04f6e98c720091cfe986e6ffbbcd" name="mjcd4b04f6e98c720091cfe986e6ffbbcd"></a><a name="t38"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t39"></a><h3 class="t3"><span class="cfett">14.5.8</span> Synchronized-Methoden der Klasse »StringBuffer« *  <a href="#t2t310"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t38"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Wir wollen uns anhand einiger Beispiele noch ansehen, an welchen Objekten der Monitor beziehungsweise Lock gespeichert wird. Zunächst betrachten wir die Methode <span class="clisting">charAt()</span> der Klasse <span class="clisting">StringBuffer</span> und versuchen zu verstehen, warum die Methode <span class="clisting">synchronized</span> ist.</p>
<div class="listing"><pre class="prettyprint">public synchronized char charAt( int index )
{
  if ( (index &lt; 0) || (index &gt;= count) )
    throw new StringIndexOutOfBoundsException( index );

  return value[index];
}</pre></div>
<p>Neben <span class="clisting">charAt()</span> sind noch eine ganze Reihe anderer Methoden synchronisiert, etwa <span class="clisting">getChars()</span>, <span class="clisting">setCharAt()</span> und <span class="clisting">append()</span>. Bei einer <span class="clisting">synchronized</span>-Methode wird also der Lock bei einem konkreten <span class="clisting">StringBuffer</span>-Objekt gespeichert. Wäre die Methode <span class="clisting">charAt()</span> nicht atomar, dann könnte es passieren, dass durch Multithreading zwei Threads das gleiche <span class="clisting">StringBuffer</span>-Objekt bearbeiten. Probleme können sich zum Beispiel dann ergeben, wenn ein Thread gerade den String verkleinert und gleichzeitig <span class="clisting">charAt()</span> aufgerufen wird. Auch wenn zuerst <span class="clisting">charAt()</span> einen gültigen Index feststellt, dann aber der <span class="clisting">StringBuffer</span> verkleinert wird, gibt es ein Problem. Dann wäre nämlich der Index ungültig und <span class="clisting">value[index]</span> fehlerhaft. Da aber <span class="clisting">charAt()</span> synchronisiert ist, kann kein anderer Thread dasselbe <span class="clisting">StringBuffer</span>-Objekt über synchronisierte Methoden modifizieren.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Das <span class="clisting">StringBuffer</span>-Objekt <span class="clisting">sb1</span> wird von zwei Threads T1 und T2 bearbeitet, indem synchronisierte Methoden genutzt werden. Bearbeitet Thread T1 den <span class="clisting">StringBuffer sb1</span> mit einer synchronisierten Methode, dann kann T2 erst dann eine synchronisierte Methode für <span class="clisting">sb1</span> aufrufen, wenn T1 die Methode abgearbeitet hat. Denn T1 setzt bei <span class="clisting">sb1</span> die Sperre, die T2 warten lässt. Gleichzeitig kann aber T2 synchronisierte Methoden für ein anderes <span class="clisting">StringBuffer</span>-Objekt <span class="clisting">sb2</span> aufrufen, da <span class="clisting">sb2</span> einen eigenen Monitor besitzt. Das macht noch einmal deutlich, dass die Locks zu einem Objekt gehören und nicht zur synchronisierten Methode.</p>
</td>
</tr>
</table><br><a id="mj06c1e7e183ad53dff9ca9f5f31845549" name="mj06c1e7e183ad53dff9ca9f5f31845549"></a><a name="t39"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t310"></a><h3 class="t3"><span class="cfett">14.5.9</span> Mit synchronized synchronisierte Blöcke  <a href="#t2t311"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t39"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Wenn wir mit <span class="clisting">Lock</span>-Objekten arbeiten, können wir den Block so fein wählen, wie es erforderlich ist. Mit <span class="clisting">synchronized</span> haben wir bisher nur eine gesamte Methode sperren können, was in manchen Fällen etwas viel ist. Dann kann eine allgemeinere Variante in Java eingesetzt werden, die nur einen Block synchronisiert. Dazu schreiben wir in Java Folgendes:</p>
<div class="listing"><pre class="prettyprint"><span class="cfett">synchronized (</span> objektMitDemMonitor<span class="cfett"> )</span>
{
  ...
}</pre></div>
<p>Der Block wird in die geforderten geschweiften Klammern gesetzt, und hinter dem Schlüsselwort in Klammern muss ein Objekt stehen, das den zu verwendenden Monitor besitzt. Die Konsequenz ist die Möglichkeit, über einen beliebigen Monitor zu synchronisieren und nicht unbedingt über den Monitor des Objekts, für das die synchronisierte Methode aufgerufen wurde, wie es bei synchronisierten Objektmethoden üblich ist.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Eine synchronisierte Objektmethode ist nichts anderes als eine Variante von:</p>
<div class="listing"><pre class="prettyprint"><span class="cfett">synchronized( this )</span>
{
  // Code der Methode.
}</pre></div>
</td>
</tr>
</table><br><h4 class="t4">Statisch synchronisierte Blöcke</h4>
<p>Nicht nur Objektmethoden, sondern auch Klassenmethoden können <span class="clisting">synchronized</span> sein. Doch die Nachbildung in einem Block sieht etwas anders aus, da es keine <span class="clisting">this</span>-Referenz gibt. Hier kann ein <span class="clisting">Object</span>-Exemplar für einen Lock herhalten, der extra für die Klasse angelegt wird. Dies ist eines der seltenen Beispiele, in denen ein Exemplar der Klasse <span class="clisting">Object</span> Sinn ergibt:</p>
<p class="tabunter"><strong>Listing 14.21    </strong>com/tutego/insel/thread/StaticSync.java</p>
<div class="listing"><pre class="prettyprint">package com.tutego.insel.thread;

class StaticSync
{
  private static final Object o = new Object();

  static void staticFoo()
  {
     synchronized( o )
     {
       // ...
     }
  }
}</pre></div>
<p>Alternativ könnten wir auch das zugehörige <span class="clisting">Class</span>-Objekt einsetzen. Wir müssen das entsprechende Klassenobjekt dann nur mittels <span class="clisting">StaticSync.class</span> erfragen. Würden wir gleich mit <span class="clisting">Lock</span>-Objekten arbeiten, stellte sich die Frage erst gar nicht.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Bei <span class="clisting">Lock</span>-Objekten oder <span class="clisting">synchronized</span>-Blöcken kann der zwingend synchronisierbare Teil in einem kleinen Abschnitt bleiben. Die JVM kann die anderen Teile parallel abarbeiten, und andere Threads dürfen die anderen Teile betreten. Als Resultat ergibt sich eine verbesserte Geschwindigkeit.</p>
</td>
</tr>
</table><br><a id="mj7dbd0ab9bb5f9d276c324109e3fca0e5" name="mj7dbd0ab9bb5f9d276c324109e3fca0e5"></a><a name="t310"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t311"></a><h3 class="t3"><span class="cfett">14.5.10</span> Dann machen wir doch gleich alles synchronisiert!  <a href="#t2t312"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t310"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>In nebenläufigen Programmen kann es schnell zu unerwünschten Nebeneffekten kommen. Das ist auch der Grund, warum Thread-lastige Programme schwer zu debuggen sind. Warum sollten wir also nicht alle Methoden synchronisieren? Wäre dann nicht das Problem aus der Welt geschafft? Prinzipiell würde das einige Probleme lösen, doch hätten wir uns damit andere Nachteile eingefangen:</p>
<ul class="gp">
<li>Methoden, die synchronisiert sind, müssen von der JVM besonders bedacht werden, damit keine zwei Threads die Methode für das gleiche Objekt ausführen. Wenn also ein zweiter Thread in die Methode eintreten möchte, kann er das nicht einfach machen, sondern muss vielleicht erst neben vielen anderen Threads warten. Es muss also eine Datenstruktur geben, in der wartende Threads eingetragen und ausgewählt werden. Das kostet zusätzlich Zeit und ist im Vergleich zu einem normalen Methodenaufruf teurer.</li>
</ul>
<ul class="gp">
<li>Zusätzlich kommt ein Problem hinzu, wenn eine nicht notwendigerweise, also überflüssig synchronisierte Methode eine Endlosschleife oder lange Operationen durchführt. Dann warten alle anderen Threads auf die Freigabe, und das kann im Fall der Endlosschleife ewig sein. Auch bei Multiprozessorsystemen profitieren wir nicht von dieser Programmiertechnik. Unnötig und falsch synchronisierte Blöcke machen die Vorteile von Mehrprozessormaschinen zunichte.</li>
</ul>
<ul class="gp">
<li>Wenn alle Methoden synchronisiert sind, steigt auch die Gefahr eines Deadlocks. In den folgenden Abschnitten erfahren wir etwas mehr über den Fall, dass zwei Threads wechselseitig auf Ressourcen eines jeweils anderen Threads zugreifen wollen und sich dabei im Wege stehen.</li>
</ul>
<p>Ist der gesamte Zugriff auf ein Objekt synchronisiert und kann kein zweiter Thread irgendwelche Eigenschaften parallel zu einem anderen Thread nutzen, nennt sich das Objekt <span class="ckursiv">voll synchronisiert</span> im Gegensatz zu <span class="ckursiv">teilsynchronisiert</span>. Sind einige Methoden der Klasse nicht synchronisiert, kann ein zweiter Thread parallel zu den synchronisierten Blöcken an die Eigenschaften gehen.</p><a id="mj7f86c2fcc6f66725145007cbca98aa8f" name="mj7f86c2fcc6f66725145007cbca98aa8f"></a><a name="t311"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t312"></a><h3 class="t3"><span class="cfett">14.5.11</span> Lock-Freigabe im Fall von Exceptions  <a href="#t2t313"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t311"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Kommt es innerhalb eines <span class="clisting">synchronized</span>-Blocks beziehungsweise innerhalb einer synchronisierten Methode zu einer nicht überprüften <span class="clisting">RuntimeException</span>, wird die JVM den Lock automatisch freigeben. Der Grund: Die Laufzeitumgebung gibt den Lock automatisch frei, wenn der Thread den synchronisierten Block verlässt, was bei einer Exception der Fall ist.</p>
<p>Werden die mit dem Schlüsselwort <span class="clisting">synchronized</span> geschützten Blöcke durch <span class="clisting">Lock</span>-Objekte umgesetzt, ist darauf zu achten, die Locks auch im Exception-Fall wieder freizugeben. Ein <span class="clisting">finally</span> mit <span class="clisting">unlock()</span> kommt da gerade recht, denn <span class="clisting">finally</span> wird ja immer ausgeführt, egal, ob es einen Fehler gab oder nicht:</p>
<p class="tabunter"><strong>Listing 14.22    </strong>com/tutego/insel/thread/concurrent/UnlockInFinally.java, main()</p>
<div class="listing"><pre class="prettyprint">ReentrantLock lock = new ReentrantLock();

try
{
  lock.lock();
  System.out.println( lock.getHoldCount() ); // 1

  try
  {
    System.out.println( 12 / 0 );
  }
 <span class="cfett"> finally</span>
 <span class="cfett"> {</span>
   <span class="cfett"> lock.unlock();</span>
 <span class="cfett"> }</span>
}
catch ( Exception e )
{
  System.out.println( e.getMessage() );    // / by zero
}
System.out.println( lock.getHoldCount() ); // 0</pre></div>
<p>Nach dem <span class="clisting">lock()</span> liefert <span class="clisting">getHoldCount()</span> 1, da ein Thread den Block betreten hat. Die Division durch null provoziert eine <span class="clisting">RuntimeException</span>, und <span class="clisting">finally</span> gibt den Lock frei. Die Ausnahme wird abgefangen, und <span class="clisting">getHoldCount()</span> liefert wieder 0, da <span class="clisting">finally</span> das <span class="clisting">unlock()</span> ausgeführt hat. Würden wir die Zeile mit <span class="clisting">unlock()</span> auskommentieren, so würde <span class="clisting">getHoldCount()</span> weiterhin 1 liefern, was ein Fehler ist.</p><a id="mj835189eac360de56887ed92c5c4ecde5" name="mj835189eac360de56887ed92c5c4ecde5"></a><a name="t312"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t313"></a><h3 class="t3"><span class="cfett">14.5.12</span> Deadlocks  <a href="#t2t314"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t312"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Ein <span class="ckursiv">Deadlock</span> (zu Deutsch etwa <span class="ckursiv">tödliche Umarmung</span>) kommt beispielsweise dann vor, wenn ein Thread A eine Ressource belegt, die ein anderer Thread B haben möchte und Thread B belegt eine Ressource, die A gerne bekommen würde. In dieser Situation können beide nicht vor und zurück und befinden sich in einem dauernden Wartezustand. Deadlocks können in Java-Programmen nicht erkannt und verhindert werden. Uns fällt also die Aufgabe zu, diesen ungünstigen Zustand gar nicht erst herbeizuführen.</p>
<div class="bildbox">
<p><a name="IDAPB0D"></a><a onClick="OpenWin('bilder/365_java_09_004.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein365_java_09_004.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p>Das nächste Beispiel soll über eine Verklemmung einen Deadlock provozieren. Zwei Threads wetteifern um die <span class="clisting">Lock</span>-Objekte <span class="clisting">lock1</span> und <span class="clisting">lock2</span>. Dabei kommt es zu einem Deadlock, da der eine genau den einen Lock besetzt, den der jeweils andere zum Weiterarbeiten benötigt:</p>
<p class="tabunter"><strong>Listing 14.23    </strong>com/tutego/insel/thread/Deadlock.java</p>
<div class="listing"><pre class="prettyprint">package com.tutego.insel.thread;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.*;

class Deadlock
{
  static Lock lock1 = new ReentrantLock(),
              lock2 = new ReentrantLock();

  static class T1 extends Thread
  {
    @Override
    public void run()
    {
      lock1.lock();
      System.out.println( "T1: Lock auf lock1 bekommen" );

      try { TimeUnit.SECONDS.sleep( 1 ); } catch ( InterruptedException e ) { }

      lock2.lock();
      System.out.println( "T1: Lock auf lock2 bekommen" );

      lock2.unlock();
      lock1.unlock();
    }
  }

  static class T2 extends Thread
  {
    @Override
    public void run()
    {
      lock2.lock();
      System.out.println( "T2: Lock auf lock2 bekommen" );

      lock1.lock();
      System.out.println( "T2: Lock auf lock1 bekommen" );

      lock1.unlock();
      lock2.unlock();
    }
  }

  public static void main( String[] args )
  {
    new T1().start();
    new T2().start();
  }
}</pre></div>
<p>In der Ausgabe sehen wir nur zwei Zeilen, und schon hängt das gesamte Programm:</p>
<div class="listing"><pre class="prettyprint">T1: Lock auf lock1 bekommen
T2: Lock auf lock2 bekommen</pre></div>
<p>Eine Lösung des Problems wäre, bei geschachteltem Synchronisieren auf mehrere Objekte diese immer in der gleichen Reihenfolge zu belegen, also etwa immer erst <span class="clisting">lock1</span>, dann <span class="clisting">lock2</span>. Bei unbekannten, dynamisch wechselnden Objekten muss dann unter Umständen eine willkürliche Ordnung festgelegt werden.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Das JDK von Oracle verfügt über eine eingebaute Deadlock-Erkennung, die auf der Konsole aktiviert werden kann. Dazu ist unter Windows die Tastenkombination 
    <span class="tastenkappe">Strg</span>
  +
    <span class="tastenkappe">Pause</span>
   zu drücken und unter Linux oder Solaris 
    <span class="tastenkappe">Strg</span>
  +
    <span class="tastenkappe">\</span>
  .</p>
</td>
</tr>
</table><br><a id="mjac6b857b6e9b19e0ddd6f7047deb1927" name="mjac6b857b6e9b19e0ddd6f7047deb1927"></a><a name="t313"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t314"></a><h3 class="t3"><span class="cfett">14.5.13</span> Mit »synchronized« nachträglich synchronisieren *  <a href="#t2t315"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t313"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Einige Java-Methoden in der Standardbibliothek sind synchronisiert, bei anderen haben die Entwickler auf eine Synchronisierung verzichtet. Nicht-synchronisierte Methoden bilden eindeutig die Mehrheit. Wenn keine ausdrücklichen Gründe für die Synchronisierung vorliegen und im Allgemeinen nur maximal ein Thread die Methode gleichzeitig aufruft, muss der Entwickler eine Absicherung nicht standardmäßig in Erwägung ziehen. Synchronisierung führt zu Geschwindigkeitsverlusten, und warum sollten wir &#8211; wenn keine Parallelität üblich ist &#8211; für etwas bezahlen, was keiner bestellt hat?</p>
<p>Im ersten Beispiel haben wir die Initialisierung eines <span class="clisting">Point</span>-Objekts betrachtet. Dass der direkte Zugriff auf zwei Variablen nicht atomar sein kann, ist klar. Doch auch der Methodenaufruf über die nicht-synchronisierte Methode <span class="clisting">setLocation()</span> bringt uns nicht weiter, weil ein Thread in dieser Methode unterbrochen werden könnte.</p>
<p>Wollen wir nachträglich sichergehen, dass <span class="clisting">setLocation()</span> atomar ist, können wir über zwei Dinge nachdenken:</p>
<ul class="gp">
<li>Wir verwenden ein <span class="clisting">Lock</span>-Objekt, das allen Threads zugänglich ist. Das Objekt nutzen sie zur Synchronisation.</li>
</ul>
<ul class="gp">
<li>Wir besorgen uns einen Monitor auf das <span class="clisting">Point</span>-Objekt und synchronisieren über diesen.</li>
</ul>
<p>Die erste Variante haben wir schon gesehen, sodass wir uns ein Beispiel für die zweite Variante anschauen:</p>
<div class="listing"><pre class="prettyprint">Point p = new Point();<span class="cfett">
synchronized( p )</span>
{
  p.setLocation( 1, 2 );
}</pre></div>
<p>Auf diese Weise kann jeder Aufruf einer nicht-synchronisierten Methode nachträglich synchronisiert werden. Jedoch muss dann jeder Zugriff wiederum mit einem <span class="clisting">synchronized</span>-Block geschützt sein, sonst besteht keine Sicherheit, weil <span class="clisting">setLocation()</span> selbst auf keinen Monitor achtet. Ruft demnach ein anderer Thread <span class="clisting">setLocation()</span> außerhalb des <span class="clisting">synchronized</span>-Blocks auf, ist die atomare Bearbeitung nichtig.</p>
<h4 class="t4">Wrapper</h4>
<p>Einen anderen Weg gehen komplette Wrapper, die sich durch Delegation oder Vererbung implementieren lassen. Für unseren Punkt können wir zum Beispiel eine Unterklasse <span class="clisting">SynchronizedPoint</span> implementieren, die alle kritischen Methoden überschreibt, die Signatur mit <span class="clisting">synchronized</span> erweitert und im Rumpf ein <span class="clisting">super.methode()</span> durchführt. Wrapper gibt es für Datenstrukturen aus der Collection-API mit statischen Methoden der Art <span class="clisting">synchronized</span><span class="clistingk">Datenstruktur</span><span class="clisting">(Datenstruktur)</span> &#8211; etwa für Listen:</p>
<div class="listing"><pre class="prettyprint">List list = Collections.synchronizedList( myList );</pre></div><a id="mjef386e0ad0e4f81d20c24fc7013063a6" name="mjef386e0ad0e4f81d20c24fc7013063a6"></a><a name="t314"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t315"></a><h3 class="t3"><span class="cfett">14.5.14</span> Monitore sind reentrant &#8211; gut für die Geschwindigkeit *  <a href="#t2t316"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t314"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Betritt das Programm eine synchronisierte Methode, bekommt es den Monitor des aufrufenden Objekts. Wenn diese Methode eine andere aufruft, die am gleichen Objekt synchronisiert ist, kann sie sofort eintreten und muss nicht warten. Diese Eigenschaft heißt <span class="ckursiv">reentrant</span>. Ohne diese Möglichkeit würde Rekursion nicht funktionieren!</p>
<p>Wenn das Programm den synchronisierten Block betritt, reserviert er den Monitor und kann alle synchronisierten Methoden ohne weitere Überprüfungen ausführen. Im Allgemeinen reduziert diese Technik aber auch die Parallelität, da der kritische Abschnitt künstlich vergrößert wird. Die Technik kann geschwindigkeitssteigernd sein, wenn viele synchronisierte Methoden hintereinander aufgerufen werden.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" rowspan="2">
<p class="BStandard"><span class="cfett">Beispiel   </span>In <span class="clisting">StringBuffer</span> sind viele Methoden synchronisiert. Dies bedeutet, dass bei jedem Aufruf einer Methode der Monitor reserviert werden muss. Das kostet natürlich eine Kleinigkeit, und als Lösung bietet es sich an, die Aufrufe in einem eigenen synchronisierten Block zu bündeln.</p>
<div class="listing"><pre class="prettyprint">StringBuffer sb = new StringBuffer();<span class="cfett">
synchronized( sb )
{</span>
  sb.append( "Transpirations-" );
  sb.append( "Illustration" );
  sb.append( "\t" );
  sb.append( "Röstreizstoffe" );<span class="cfett">
}</span></pre></div>
<p class="BStandard">Wir können uns vorstellen, dass bei der Klasse ein kleiner Zähler ist, der bei jedem Betreten inkrementiert und beim Verlassen dekrementiert wird. Ist der Zähler null, befindet sich kein Thread im Block. Ist er größer null, haben wir einen reentranten Zugriff.</p>
</td>
</tr>
</table><br><p>Die Klasse <span class="clisting">ReentrantLock</span> verwaltet den Zähler &#8211; er geht bis 2<sup>31  </sup> &#8211; selbst, und einige Methoden geben Zugriff auf die Informationen, die meistens zum Testen nützlich sind. Mit <span class="clisting">isLocked()</span> finden wir heraus, ob der Lock frei ist oder nicht. <span class="clisting">isHeldByCurrentThread()</span> liefert <span class="clisting">true</span>, wenn der ausführende Thread den Lock verwendet. <span class="clisting">getHoldCount()</span> liefert die Anzahl der Anfragen, die der aktuelle Thread an den Lock gestellt hat. Ist die Rückgabe null, so schließt der aktuelle Thread nicht ab, doch könnte dies wohl ein anderer Thread erledigen. <span class="clisting">getQueueLength()</span> gibt eine (durch <span class="ckursiv">race conditions</span> mögliche) Schätzung über die Anzahl der wartenden Threads ab, die <span class="clisting">lock()</span> aufgerufen haben.</p><a id="mj971b2acd022777011b0152eaa4837a24" name="mj971b2acd022777011b0152eaa4837a24"></a><a name="t315"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t316"></a><h3 class="t3"><span class="cfett">14.5.15</span> Synchronisierte Methodenaufrufe zusammenfassen *  <img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"><a href="#t2t315"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Synchronisierte Methoden stellen sicher, dass bei mehreren parallel ausführenden Threads die Operationen atomar ausgeführt werden. Das gilt jedoch ausschließlich für jede synchronisierte Methode, aber nicht für eine Sequenz von synchronisierten Methoden. Wir wissen zum Beispiel, dass <span class="clisting">StringBuffer</span> alle Methoden synchronisiert und daher der <span class="clisting">StringBuffer</span> bei parallelen Zugriffen keine inkonsistenten Zustände erzeugt. Was geschieht, wenn zwei Threads auf den folgenden Block zugreifen, wobei <span class="clisting">sb</span> eine Variable ist, die auf einen gemeinsamen <span class="clisting">StringBuffer</span> zeigt?</p>
<div class="listing"><pre class="prettyprint">for ( char c = 'a'; c &lt;= 'z'; c++ )
  sb.append( c );</pre></div>
<p>Greifen zwei Threads &#8211; nennen wir sie <span class="ckursiv">T1</span> und <span class="cfett">T2</span> &#8211; auf <span class="clisting">sb</span> zu, erzeugen möglicherweise beide zusammen die folgende Zeichenkette: <span class="ckursiv">abc</span><span class="cfett">abcdefg</span><span class="ckursiv">d</span><span class="cfett">hi</span><span class="ckursiv">hij</span>... Das Ergebnis ist logisch, denn <span class="clisting">synchronized</span> bedeutet nur, dass zwei Threads eine einzelne Operation atomar ausführen, aber kein Bündel.</p>
<p>Diese Aufgabe löst ein synchronisierter Block ausgezeichnet:</p>
<div class="listing"><pre class="prettyprint">synchronized ( sb )
{
  for ( char c = 'a'; c &lt;= 'z'; c++ )
    sb.append( c );
}</pre></div>
<p>Betritt der erste Thread den synchronisierten Block, schließt er ab, sodass andere Threads warten müssen. Der betretende Thread selbst kann aber, weil er den Monitor des <span class="clisting">StringBuffer</span> schon besitzt, reentrant die anderen synchronisierten Methoden aufrufen.</p>
<p>Das Beispiel zeigt, wie gut sich ein <span class="clisting">synchronized</span>-Block nutzen lässt, wenn an anderen Objekten synchronisiert wird. Mit einem <span class="clisting">Lock</span>-Objekt könnten wir hier nicht arbeiten, weil es zwar die einzelnen <span class="clisting">append()</span>-Aufrufe zusammenfasst, aber von außen eine Unterbrechung nicht verhindern kann. Wenn ein zweiter Thread sich in die Aufrufkette mogelt, kann er jedes Mal, wenn ein <span class="clisting">append()</span> verlassen und dabei der Monitor frei wird, ein neues <span class="clisting">append()</span> aufrufen und so außerhalb des <span class="clisting">lock()</span>/<span class="clisting">unlock()</span>-Blocks eintreten.</p><br><hr><a name="kommentar"></a><h3>Ihr Kommentar</h3>
                       Wie hat Ihnen das &lt;openbook&gt; gefallen? Wir freuen uns immer über Ihre freundlichen und kritischen Rückmeldungen.
                       <form action="http://www.galileo-press.de/feedback/openbook" method="post" style="text-align: center; margin-top: 10px;"><input type="hidden" name="openbookurl" value="javainsel9/.htm"><input type="hidden" name="buchtitel" value="Java ist auch eine Insel"><input type="hidden" name="Kapitel" value="14.5 Synchronisation über kritische Abschnitte"><table border="0">
<tr>
<td><label for="name">Name</label><br></td>
<td><input type="text" name="name" id="name" size="40"><br></td>
</tr>
<tr>
<td><label for="email">E-Mail</label><br></td>
<td><input type="text" name="email" id="email" size="40"><br></td>
</tr>
<tr>
<td valign="top"><label for="comment">Ihr Kommentar</label><br></td>
<td><textarea name="comment" id="comment" rows="10" cols="40"></textarea><br></td>
</tr>
<tr>
<td>
</td>
<td><input type="submit" value="Kommentar absenden"></td>
</tr>
</table>
</form>
</div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="javainsel_14_004.htm" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a class="navnav" href="#">&lt;top&gt;</a></div></td>
<td align="right" width="25%"><div align="right"><a href="javainsel_14_006.htm" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
</table>
</div></td>
<td width="10" valign="top">  </td>
<td width="160" valign="top">
<table border="0" cellpadding="0" cellspacing="0" width="160">
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2">
&nbsp;<a href="http://www.galileocomputing.de/katalog/buecher/?GPP=opjiVIV" class="autor">
<strong>Zum Katalog</strong></a>

</td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2">
<img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV">
<img src="common/9783836215060_s.gif" width="119" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Java ist auch eine Insel" title="Zum Katalog: Java ist auch eine Insel">
<br><br><br><br><br><br><strong>Java ist auch eine Insel</strong><br><img src="common/pfeil_rechts5.gif" border="0" alt="">Jetzt bestellen</a><br /><br />
</td>
</tr>
</table>
</td>

</tr>
</table>
</td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2"><span class="autor"><strong>&nbsp;Ihre Meinung?</strong></a></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">

<table cellspacing="3">
<tr>
<td>Wie hat Ihnen das &lt;openbook&gt; gefallen?<br><a href="#kommentar"><img src="common/pfeil_rechts5.gif" border="0" alt="">Ihre Meinung</a>
<br><br></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>

<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>
<tr>
<td>
</td>
</tr>

<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2">&nbsp;<a href="http://www.galileocomputing.de/katalog/buecher/?GPP=opjiVIV" class="autor"><strong>Buchempfehlungen</strong></a></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2285?GPP=opjiVIV">
<img src="common/9783836215275_s.gif" width="102" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Computergeschichte(n) – nicht nur für Geeks" title="Zum Katalog: Computergeschichte(n) – nicht nur für Geeks"><br><br><br><br><br><br>&nbsp;Computergeschichte(n)<br>&nbsp;nicht nur für Geeks</a><br><br></td>
</tr>

<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/1949?GPP=opjiVIV">
<img src="common/9783836213080_s.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Java und XML" title="Zum Katalog: Java und XML"><br><br><br><br><br><br><br>&nbsp;Java und XML</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2346?GPP=opjiVIV">
<img src="common/9783836215688_s.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Einstieg in Java" title="Zum Katalog: Einstieg in Java"><br><br><br><br><br><br><br>&nbsp;Einstieg<br>&nbsp;in Java</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2051?GPP=opjiVIV">

<img src="common/9783836213677_s.gif" width="112" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Einstieg in XML" title="Zum Katalog: Einstieg in XML"><br><br><br><br><br><br><br>&nbsp;Einstieg<br>&nbsp;in XML</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2322?GPP=opjiVIV">
<img src="common/9783836215527_s.gif" width="112" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Visual C# 2010" title="Zum Katalog: Visual C# 2010"><br><br><br><br><br><br><br>&nbsp;Visual C# 2010</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2212?GPP=opjiVIV">
<img src="common/9783836214742_s.gif" width="119" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Professionell entwickeln mit Visual C# 2010" title="Zum Katalog: Professionell entwickeln mit Visual C# 2010"><br><br><br><br><br><br><br>&nbsp;Professionell<br>&nbsp;entwickeln mit<br>&nbsp;Visual C# 2010</a><br><br></td>
</tr>

<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2156?GPP=opjiVIV">
<img src="common/9783836214292_s.gif" width="108" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C++ von A bis Z" title="Zum Katalog: C++ von A bis Z"><br><br><br><br><br><br><br>&nbsp;C++ von A bis Z</a><br><br></td>
</tr>
</table></td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>

<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2"><span class="autor"><strong>&nbsp;Shopping</strong></span></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><b>Versandkostenfrei</b> bestellen in Deutschland und &Ouml;sterreich<br><a href="http://www.galileocomputing.de/hilfe/Shop/?GPP=opjiVIV"><img src="common/pfeil_rechts5.gif" border="0" alt="Info">Info</a><br><br></td>

</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table><br><br><hr width="70%" align="center">
<div align="center">
<p class="standard"><strong>Copyright © Galileo Press 2011</strong><br>
        Für Ihren privaten Gebrauch dürfen Sie die Online-Version natürlich ausdrucken.
        Ansonsten unterliegt das &lt;openbook&gt; denselben Bestimmungen, wie die
        gebundene Ausgabe: Das Werk einschließlich aller seiner Teile ist urheberrechtlich
        geschützt. Alle Rechte vorbehalten einschließlich der Vervielfältigung, Übersetzung,
        Mikroverfilmung sowie Einspeicherung und Verarbeitung in elektronischen Systemen.</p><br><a href="http://www.galileocomputing.de/">[Galileo Computing]</a><br><br>
      Galileo Press, Rheinwerkallee 4, 53227 Bonn, Tel.: 0228.42150.0, Fax 0228.42150.77, <a href="mailto:info@galileo-press.de">info@galileo-press.de</a></div><br><br></body>
</html>
