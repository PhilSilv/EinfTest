<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Galileo Computing :: Java ist auch eine Insel – 17.2 Basisklassen für die Ein-/Ausgabe</title>
<meta name="title" content="Galileo Computing :: Java ist auch eine Insel - 17.2 Basisklassen für die Ein-/Ausgabe">
<meta name="author" content="Christian Ullenboom ">
<meta name="publisher" content="Galileo Press 2011">
<meta name="copyright" content="Galileo Press 2011">
<meta name="Description" content="Java ist auch eine Insel - Das umfassende Handbuch – 17.2 Basisklassen für die Ein-/Ausgabe">
<meta name="audience" content="Alle">
<meta name="robots" content="INDEX,FOLLOW">
<meta http-equiv="content-language" content="de">
<link rel="stylesheet" type="text/css" href="common/galileo_open.css">
<link rel="prev" href=".htm">
<link rel="next" href=".htm"><script type="text/javascript"><!--
    function OpenWin(url,name,height,width)
    {
      var InfoWin = window.open(url,name,"directories=0,height="+height+",width=" + width + ",hotkeys=0,location=0,menubar=0,resizable=1,screenX=150,screenY=10,left=150,top=10,scrollbars=1,status=1,titlebar=0,toolbar=0");
      InfoWin.focus();
    }
    //--></script><link href="common/prettify.css" type="text/css" rel="stylesheet"><script type="text/javascript" src="common/prettify.js"></script></head>
<body vlink="#000099" link="#000099" alink="#000099" onload="prettyPrint()">
<table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#000066">
<tr>
<td height="74" valign="bottom" colspan="2"><a href="http://www.galileocomputing.de/katalog/openbook?GPP=opjiVIV"><img src="common/galileocomputing_openbook.gif" width="200" height="56" border="0" alt="Galileo Computing < openbook >" title="Galileo Computing < openbook >"></a></td>
<td width="80" height="74"><a href="http://www.galileocomputing.de/?GPP=opjiVIV"><img src="common/galileocomputing.gif" border="0" alt="Galileo Computing - Professionelle Bücher. Auch für Einsteiger." title="Galileo Computing - Professionelle Bücher. Auch für Einsteiger."></a></td>
</tr>
</table>
<div align="right"><a href="http://www.galileocomputing.de/?GPP=opjiVIV" class="navnav">Professionelle Bücher. Auch für Einsteiger.</a></div><br><table class="tbl" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="190" valign="top">
<table class="tbl1" border="0" cellpadding="3" cellspacing="0" width="190" align="left">
<tr>
<td class="tbl2"><a class="nav" href="index.htm#_top">Inhaltsverzeichnis</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_00_001.htm#mj58b119301920569a446c9c510503f310">Vorwort</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_01_001.htm#mja8fc5b7ad19fc7332bc66b09a8fda26e">1 Java ist auch eine Sprache</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_02_001.htm#mj313f67c98dc9ecaddfa2d8b80f057fd2">2 Sprachbeschreibung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_03_001.htm#mjcd3b5720e8605484942e3476a1075bdf">3 Klassen und Objekte</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_04_001.htm#mj71fbc84ad33a281b9352b0b19fae2fb2">4 Der Umgang mit Zeichenketten</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_05_001.htm#mj005cd8e604aefc3ae72b92880fcee5c6">5 Eigene Klassen schreiben</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_06_001.htm#mj6f6b47453043c38837bfc32154a97968">6 Exceptions</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_07_001.htm#mjc4a1f6f3499a02fb64fe89046739edca">7 Generics&lt;T&gt;</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_08_001.htm#mj46e914488628367f5dfc0a62c3a78a53">8 Äußere.innere Klassen</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_09_001.htm#mj94af2b90e8a2dad6c1ef67255f89a137">9 Besondere Klassen der Java SE</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_10_001.htm#mjcae20f50ffbc015d0b66861e7087af9b">10 Architektur, Design und angewandte Objektorientierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_11_001.htm#mj60bc6a007ae9b8657949f3e91d96df3d">11 Die Klassenbibliothek</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_12_001.htm#mj0ce00eb41aae2b084534019cf6edc3b6">12 Bits und Bytes und Mathematisches</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_13_001.htm#mj245f5f8d5a858b46462d64e9b9c0786b">13 Datenstrukturen und Algorithmen</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_14_001.htm#mj8c6f381221d805dd6fbe480731ac0c58">14 Threads und nebenläufige Programmierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_15_001.htm#mjbe3ed0989722396930966f95deeb2497">15 Raum und Zeit</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_16_001.htm#mj78bd405fb0de0cff099c06255fe36853">16 Dateien, Verzeichnisse und Dateizugriffe</a></td>
</tr>
<tr>
<td><a class="navh" href="javainsel_17_001.htm#mjb420b02f4ccf65226f7271e48cefa05d">17 Datenströme</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_18_001.htm#mjedab16f1a9cc168eda4a24416359e0b9">18 Die eXtensible Markup Language (XML)</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_19_001.htm#mjc8f47f7f51ac3795c46c4544f391b02e">19 Grafische Oberflächen mit Swing</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_20_001.htm#mj25cc7d47e476b8b1a183a10ee741dbaa">20 Grafikprogrammierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_21_001.htm#mjea7bcdd596c8bd25b078a00221a01a75">21 Netzwerkprogrammierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_22_001.htm#mjde622db61608a627262a27ecb377d675">22 Verteilte Programmierung mit RMI</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_23_001.htm#mj23bf599d65364bcd05d06a34cb5593bf">23 JavaServer Pages und Servlets</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_24_001.htm#mja621f3b4a74c7fa576b4a58b1614041e">24 Datenbankmanagement mit JDBC</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_25_001.htm#mja2e217bf5724cc65eba184a2af8b79cf">25 Reflection und Annotationen</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_26_001.htm#mjb47dd6e0a309b7e78cad68f6b5de9319">26 Dienstprogramme für die Java-Umgebung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_27_001.htm#mjf59db36d9280a70e0d3d196e9bf160f5">A Die Begleit-DVD</a></td>
</tr>
<tr>
<td><a class="navnav" href="stichwort.htm#_top">Stichwort</a></td>
</tr>
<tr>
<td><br><a href="http://download2.galileo-press.de/openbook/galileocomputing_javainsel9.zip" class="navnav"><strong>Download:</strong><br>- ZIP, ca. 20,5 MB</a></td>
</tr>
<tr>
<td><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV" class="navnav">Buch bestellen</a></td>
</tr>
<tr>
<td><a class="navnav" href="#kommentar">Ihre Meinung?</a><br><br></td>
</tr>
</table>
</td>
<td width="10"><img src="common/spacer10.gif" width="10" height="10" alt="Spacer"></td>
<td width="85%" valign="top" align="center"><div align="center">
<table width="98%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="javainsel_17_001.htm" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a href="http://www.galileocomputing.de/?GPP=opjiVIV" class="navnav">Galileo Computing /</a><a href="http://www.galileocomputing.de/katalog/openbook/?GPP=opjiVIV" class="navnav"> &lt;openbook&gt; /</a><a href="index.htm" class="navnav"> Java-Insel</a></div></td>
<td align="right" width="25%"><div align="right"><a href="javainsel_17_003.htm" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" valign="top"><table width="100%" border="0" cellpadding="10" cellspacing="0" class="box">
<tr>
<td colspan="2"><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV" class="buchtitel">Java ist auch eine Insel</a><span class="autor"> von Christian Ullenboom </span><br><span class="untertitel">Das umfassende Handbuch</span></td>
</tr>
<tr>
<td valign="top" width="211"><dl>
<dt><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV" class="navnav"><img src="common/9783836215060.gif" border="0" alt="Buch: Java ist auch eine Insel" title="Buch: Java ist auch eine Insel"></a></dt>
<dd><br><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV"><span class="autor"><strong>Java ist auch eine Insel</strong><br>geb., mit DVD<br>1482 S., 49,90 Euro<br>Galileo Computing<br>ISBN 978-3-8362-1506-0</span></a></dd>
</dl></td>
<td width="80%"><table border="0">
<tr>
<td valign="baseline"><img src="common/pfeil_u.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="3" class="kap"><strong><a href="javainsel_17_001.htm#mjb420b02f4ccf65226f7271e48cefa05d" class="navnav">17 Datenströme</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_17_001.htm#mj7a324cf69fbedec30392b88f514c1531" class="navnav">17.1 Stream-Klassen und Reader/Writer am Beispiel von Dateien</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_001.htm#mj87f7ea8c7b8051417049399df2c5782a" class="navnav">17.1.1 Mit dem FileWriter Texte in Dateien schreiben</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_001.htm#mj5716136ecff252fbd4596261b9080831" class="navnav">17.1.2 Zeichen mit der Klasse »FileReader« lesen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_001.htm#mjb01e1a0c69c28aad4f4d7eeee1de357d" class="navnav">17.1.3 Kopieren mit »FileOutputStream« und »FileInputStream«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_001.htm#mjbdc9ce90e6d512ae0291a2ed6232d72a" class="navnav">17.1.4 Das FileDescriptor-Objekt *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="#mj9a4cc18f2e2c6f801a5cc621aa15984f" class="navh">17.2 Basisklassen für die Ein-/Ausgabe</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj203b54d682c73aada147e1b57c01662f" class="navh">17.2.1 Die abstrakten Basisklassen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj7a1dda9729bd603bcadebc990609f10f" class="navh">17.2.2 Übersicht über Ein-/Ausgabeklassen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjd34b697cdf6ea75732127f6a06fc88b0" class="navh">17.2.3 Die abstrakte Basisklasse »OutputStream«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj2202e460fa14e6ecb6820f4ef86a77f8" class="navh">17.2.4 Die Schnittstellen »Closeable« und »Flushable«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj25199db178b60bddb59bd9defea22c22" class="navh">17.2.5 Ein Datenschlucker *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj534fca11b85556e6eec99b4fdd7a4553" class="navh">17.2.6 Die abstrakte Basisklasse »InputStream«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjc2905c008847dad671feaa7501f0d82f" class="navh">17.2.7 Ressourcen aus dem Klassenpfad und aus Jar–Archiven laden</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj8c65b2939c83b858ed311032513e29b4" class="navh">17.2.8 Ströme mit SequenceInputStream zusammensetzen *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjb3889bbefb776f81c16212ee860a5b81" class="navh">17.2.9 Die abstrakte Basisklasse »Writer«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj8bdb238857679cf8eede58d00850de6b" class="navh">17.2.10 Die Schnittstelle »Appendable« *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj923c62d6bac3e8a5c5b75c58df0b0bd3" class="navh">17.2.11 Die abstrakte Basisklasse »Reader«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_17_003.htm#mjb6060f6cd569b28d5768b131b007f8c8" class="navnav">17.3 Formatierte Textausgaben</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_003.htm#mj3573ae904c53fd07e28b8d6dc4973fc8" class="navnav">17.3.1 Die Klassen »PrintWriter« und »PrintStream«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_003.htm#mjc6e7c16fc76cbc87e02a674ecb288cbf" class="navnav">17.3.2 »System.out«, »System.err« und »System.in«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_17_004.htm#mj52686ccc039a7d0b9fdf13da77f25534" class="navnav">17.4 Schreiben und Lesen aus Strings und Byte-Feldern</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_004.htm#mj97a3eda7509a5b9a017d7b03763042ee" class="navnav">17.4.1 Mit dem »StringWriter« ein String-Objekt füllen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_004.htm#mj94b85a8029a72b2ead03272e22027344" class="navnav">17.4.2 CharArrayWriter</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_004.htm#mj1fbd4214555249440ffa5a256c369d52" class="navnav">17.4.3 »StringReader« und »CharArrayReader«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_004.htm#mjb453ad9336694734eec75f9d0145cc03" class="navnav">17.4.4 Mit »ByteArrayOutputStream« in ein Byte-Feld schreiben</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_004.htm#mje1eff635da76d0cbd2c4c316ee940cfb" class="navnav">17.4.5 Mit »ByteArrayInputStream« aus einem Byte-Feld lesen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_17_005.htm#mjafc99f810e12c276ba2a4b6fc3c009c3" class="navnav">17.5 Datenströme filtern und verketten</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_005.htm#mj4466c357c7508a8eb1ceaaaa7a22f5ed" class="navnav">17.5.1 Streams als Filter verketten (verschalen)</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_005.htm#mj3a1085565ee3f519c058eb06e024f57a" class="navnav">17.5.2 Gepufferte Ausgaben mit »BufferedWriter«/»BufferedOutputStream«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_005.htm#mjd7529c220ef65a0b793a27365ea5de14" class="navnav">17.5.3 Gepufferte Eingaben mit »BufferedReader«/»BufferedInputStream«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_005.htm#mj019dc3443d19cfbdda730582336dc29d" class="navnav">17.5.4 »LineNumberReader« zählt automatisch Zeilen mit *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_005.htm#mj46d4c0c0873fbee2cbb4dbbf6aacfb92" class="navnav">17.5.5 Daten mit der Klasse »PushbackReader« zurücklegen *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_005.htm#mjeee25cb2d512bd9c6098a285327bb9de" class="navnav">17.5.6 DataOutputStream/DataInputStream *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_005.htm#mj5ca3c8f350c3026418585f4f6765a4a7" class="navnav">17.5.7 Basisklassen für Filter *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_005.htm#mj9f0672d3026eda914c090ee852a9042f" class="navnav">17.5.8 Die Basisklasse »FilterWriter« *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_005.htm#mjcf7a24a8d32eab395c95b5a1a055ee61" class="navnav">17.5.9 Ein LowerCaseWriter *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_005.htm#mj4744fe492703c6ebebb6a59fc1ecab41" class="navnav">17.5.10 Eingaben mit der Klasse »FilterReader« filtern *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_005.htm#mjbb86eafceec41ba0b8b469e325491f65" class="navnav">17.5.11 Anwendungen für »FilterReader« und »FilterWriter« *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_17_006.htm#mj23b9709abc382e2f5711eb2fa2afe62a" class="navnav">17.6 Vermittler zwischen Byte-Streams und Unicode-Strömen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_006.htm#mj3d46af3cebae8a6b48a1b86f51aa9a9a" class="navnav">17.6.1 Datenkonvertierung durch den »OutputStreamWriter«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_006.htm#mj144d7a0549a2ce1fab9915120fb31b22" class="navnav">17.6.2 Automatische Konvertierungen mit dem »InputStreamReader«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_17_007.htm#mjfe86e50114d12487bf98150109f0c80e" class="navnav">17.7 Kommunikation zwischen Threads mit Pipes *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_007.htm#mj5543b5920d0846d094719457aed5af2d" class="navnav">17.7.1 »PipedOutputStream« und »PipedInputStream«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_007.htm#mj59d39f069c9dee074ea833ee91cdb61d" class="navnav">17.7.2 »PipedWriter« und »PipedReader«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_17_008.htm#mjbbc77ec964ae1ebbe66c5eb2007a8b82" class="navnav">17.8 Datenkompression *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_008.htm#mj3a803e5a22241029d6675e5d613ea7e2" class="navnav">17.8.1 Java-Unterstützung beim Komprimieren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_008.htm#mj7fca467b6415e4b9fe73aee4c8e16a50" class="navnav">17.8.2 Datenströme komprimieren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_008.htm#mje0c8562dbd63f757609825045dddf21d" class="navnav">17.8.3 Zip-Archive</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_008.htm#mjd663fcaaa21f8f86000c0a811e58b9f1" class="navnav">17.8.4 Jar-Archive</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_17_009.htm#mj7b8d560bda25a4f29394a149b2c3d535" class="navnav">17.9 Prüfsummen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_009.htm#mje3d5968795a85089bfd586581f1b781a" class="navnav">17.9.1 Die Schnittstelle Checksum</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_009.htm#mj9cdca16397ae80dcd9d85adf2cf3cc2f" class="navnav">17.9.2 Die Klasse »CRC32«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_009.htm#mj50d1509644070e5a1d40daa4faa61fa9" class="navnav">17.9.3 Die Adler32-Klasse</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_17_010.htm#mjfbe8cb1105d7dfaf6adbc23f31c81b93" class="navnav">17.10 Persistente Objekte und Serialisierung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_010.htm#mj69bf799342565da382851751b8405c7a" class="navnav">17.10.1 Objekte mit der Standard-Serialisierung speichern und lesen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_010.htm#mj9d80b91a6c19f204a99e533d4b06d998" class="navnav">17.10.2 Zwei einfache Anwendungen der Serialisierung *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_010.htm#mj4cfaf8e1986ce009185bb267467eb491" class="navnav">17.10.3 Die Schnittstelle »Serializable«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_010.htm#mjcafe7062d212cfb4fcf71bb901c8099c" class="navnav">17.10.4 Nicht serialisierbare Attribute aussparen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_010.htm#mjd107c87fbdb86f55755ffc6b4039e012" class="navnav">17.10.5 Das Abspeichern selbst in die Hand nehmen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_010.htm#mjb643b06ff5b465827ea26c24669f7289" class="navnav">17.10.6 Tiefe Objektkopien *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_010.htm#mj263338363082753d9e0405edbfce3f51" class="navnav">17.10.7 Versionenverwaltung und die SUID</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_010.htm#mj07f5c3cb185628598b5c79a3729d9f9d" class="navnav">17.10.8 Wie die »ArrayList« serialisiert *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_010.htm#mjfcd0e0b26ebafe7b761d60df5980a4cd" class="navnav">17.10.9 Probleme mit der Serialisierung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_17_011.htm#mj127a190a2c34664de897acc631316756" class="navnav">17.11 Alternative Datenaustauschformate</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_011.htm#mjf9ee0e42eb705d67748dc15d0336cb3f" class="navnav">17.11.1 Serialisieren in XML-Dateien</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_011.htm#mje0da83ef3a9c48ec1e3010dacb6e808f" class="navnav">17.11.2 XML-Serialisierung von JavaBeans mit JavaBeans Persistence *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_011.htm#mja49e87eb234ecf53ab600822784dddcb" class="navnav">17.11.3 Open-Source Bibliothek XStream *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_17_012.htm#mja2c8f5a4b1baf6bb787a020787e01cc9" class="navnav">17.12 Tokenizer *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_17_012.htm#mjd6c5137e5c1c6b9e9b82dbd43f2c974a" class="navnav">17.12.1 StreamTokenizer</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_17_013.htm#mj4a4cb19892fe3082f19af7d71ff8b2e5" class="navnav">17.13 Zum Weiterlesen</a></strong></td>
</tr>
</table><br></td>
</tr>
</table>
<table width="100%" cellpadding="20" cellspacing="0" border="0" bgcolor="#eeeeee">
<tr>
<td><div class="main"><a id="mj9a4cc18f2e2c6f801a5cc621aa15984f" name="mj9a4cc18f2e2c6f801a5cc621aa15984f"></a><a name="t21"></a><a name="t2t31"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div>
<h2 class="t2"><span class="cfett">17.2</span> Basisklassen für die Ein-/Ausgabe  <a href="#t2t32"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><img src="common/15x15leer.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></h2>
<p>Das ganze <span class="clisting">java.io</span> Paket ist um drei zentrale Prinzipien aufgebaut:</p>
<table width="100%" border="0">
<tr>
<td valign="top" width="10"><strong>1.</strong></td>
<td valign="top" width="100%" align="left"> Es gibt abstrakte Basisklassen, die Operationen für Ein-/Ausgabe vorschreiben.</td>
</tr>
<tr>
<td valign="baseline" width="16">     </td>
<td valign="top" width="100%" align="left">     </td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="top" width="10"><strong>2.</strong></td>
<td valign="top" width="100%" align="left"> Die abstrakten Basisklassen gibt es einmal für Unicode-Zeichen und einmal für Bytes.</td>
</tr>
<tr>
<td valign="baseline" width="16">     </td>
<td valign="top" width="100%" align="left">     </td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="top" width="10"><strong>3.</strong></td>
<td valign="top" width="100%" align="left"> Die Implementierungen der abstrakten Basisklassen realisieren entweder die konkrete Ein-/Ausgabe in eine bestimmte Ressource (etwa Datei oder auch Bytefeld) oder sind Filter.</td>
</tr>
<tr>
<td valign="baseline" width="16">     </td>
<td valign="top" width="100%" align="left">     </td>
</tr>
</table><a id="mj203b54d682c73aada147e1b57c01662f" name="mj203b54d682c73aada147e1b57c01662f"></a><a name="t31"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t32"></a><h3 class="t3"><span class="cfett">17.2.1</span> Die abstrakten Basisklassen  <a href="#t2t33"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t31"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Die konkreten Eingabe-/Ausgabe-Klassen wie <span class="clisting">FileInputStream</span>, <span class="clisting">FileOutputStream</span>, <span class="clisting">FileWriter</span> oder <span class="clisting">BufferedWriter</span> erweitern abstrakte Oberklassen. Im Allgemeinen können wir vier Kategorien bilden: Klassen zur Ein-/Ausgabe von Bytes (oder Byte-Arrays) und Klassen zur Ein-/Ausgabe von Unicode-Zeichen (Arrays oder Strings).</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 17.2    </strong>Basisklassen für Ein- und Ausgabe</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">Basisklasse für</span>
</td>
<td class="tabellenkopf"><span class="cfett">Bytes (oder Byte-Arrays)</span>
</td>
<td class="tabellenkopf"><span class="cfett">Zeichen (oder Zeichen-Arrays)</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p>Eingabe</p>
</td>
<td class="tabellentext">
<p><span class="clisting">InputStream</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">Reader</span></p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p>Ausgabe</p>
</td>
<td class="tabellentext">
<p><span class="clisting">OutputStream</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">Writer</span></p>
</td>
</tr>
</table><br><p>Die Klassen <span class="clisting">InputStream</span> und <span class="clisting">OutputStream</span> bilden die Basisklassen für alle byte-orientierten Klassen und dienen somit als Bindeglied bei Methoden, die als Parameter ein Eingabe- und Ausgabe-Objekt verlangen. So ist ein <span class="clisting">InputStream</span> nicht nur für Dateien denkbar, sondern auch für Daten, die über das Netzwerk kommen. Das Gleiche gilt für <span class="clisting">Reader</span> und <span class="clisting">Writer</span>; sie sind die abstrakten Basisklassen zum Lesen und Schreiben von Unicode-Zeichen und Unicode-Zeichenfolgen. Die Basisklassen geben abstrakte <span class="clisting">read()</span>- oder <span class="clisting">write()</span>-Methoden vor, die Unterklassen überschreiben, da nur sie wissen, wie etwas tatsächlich gelesen oder geschrieben wird.</p><a id="mj7a1dda9729bd603bcadebc990609f10f" name="mj7a1dda9729bd603bcadebc990609f10f"></a><a name="t32"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t33"></a><h3 class="t3"><span class="cfett">17.2.2</span> Übersicht über Ein-/Ausgabeklassen  <a href="#t2t34"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t32"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Während die abstrakten Basisklassen von keiner konkreten Datenquelle lesen oder in keine Ressource schreiben, implementieren die Unterklassen eine ganz bestimmte Strategie für eine Ressource. So weiß zum Beispiel ein <span class="clisting">FileWriter</span>, wie für Dateien die abstrakte Klasse <span class="clisting">Writer</span> zu implementieren ist, also wie Unicode-Zeichen in eine Datei geschrieben werden.</p>
<p>Die folgenden Tabellen vermitteln einen Überblick über die wichtigsten Unterklassen von <span class="clisting">InputStream</span>/<span class="clisting">OutputStream</span> und <span class="clisting">Reader</span>/<span class="clisting">Writer</span>. Die erste Tabelle listet die Eingabeklassen auf &#8211; und stellt die byte-orientierten und zeichenorientierten Klassen gegenüber &#8211;, und die zweite Tabelle zeigt die wesentlichen Ausgabeklassen.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 17.3    </strong>Wichtige Eingabeklassen. Die mit † markierten Klassen sind veraltet (deprecated)</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">Byte-Stream-Klasse für
die Eingabe</span>
</td>
<td class="tabellenkopf"><span class="cfett">Zeichen-Stream-Klasse
für die Eingabe</span>
</td>
<td class="tabellenkopf"><span class="cfett">Beschreibung</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">InputStream</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">Reader</span></p>
</td>
<td class="tabellentext">
<p>Abstrakte Klasse für Zeicheneingabe und Byte-Arrays</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">BufferedInputStream</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">BufferedReader</span></p>
</td>
<td class="tabellentext">
<p>Puffert die Eingabe.</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">LineNumberInputStream†</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">LineNumberReader</span></p>
</td>
<td class="tabellentext">
<p>Merkt sich Zeilennummern beim Lesen.</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">ByteArrayInputStream</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">CharArrayReader</span></p>
</td>
<td class="tabellentext">
<p>Liest Zeichen-Arrays oder Byte-Arrays</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p>(keine Entsprechung)</p>
</td>
<td class="tabellentext">
<p><span class="clisting">InputStreamReader</span></p>
</td>
<td class="tabellentext">
<p>Wandelt einen Byte-Stream in einen Zeichen-Stream um. Sie ist das Bindeglied zwischen Byte und Zeichen.</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">DataInputStream</span></p>
</td>
<td class="tabellentext">
<p>(keine Entsprechung)</p>
</td>
<td class="tabellentext">
<p>Liest Primitive und auch UTF-8.</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">FilterInputStream</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">FilterReader</span></p>
</td>
<td class="tabellentext">
<p>abstrakte Klasse für gefilterte Eingabe</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">PushbackInputStream</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">PushbackReader</span></p>
</td>
<td class="tabellentext">
<p>Erlaubt, gelesene Zeichen wieder in den Stream zu geben.</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">PipedInputStream</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">PipedReader</span></p>
</td>
<td class="tabellentext">
<p>Liest von einem <span class="clisting">PipedWriter</span> oder <span class="clisting">PipedOutputStream</span>.</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">StringBufferInputStream†</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">StringReader</span></p>
</td>
<td class="tabellentext">
<p>Liest aus Strings.</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">SequenceInputStream</span></p>
</td>
<td class="tabellentext">
<p>(keine Entsprechung)</p>
</td>
<td class="tabellentext">
<p>Verbindet mehrere <span class="clisting">InputStream</span>.</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">TelepathicInputStream</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">TelepathicWriter</span></p>
</td>
<td class="tabellentext">
<p>Überträgt Daten mittels Telepathie [Noch in der Entwicklung.]</p>
</td>
</tr>
</table><br><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 17.4    </strong>Wichtige Ausgabeklassen.</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">Byte-Stream-Klasse für die
Ausgabe</span>
</td>
<td class="tabellenkopf"><span class="cfett">Zeichen-Stream-Klasse für die Ausgabe</span>
</td>
<td class="tabellenkopf"><span class="cfett">Beschreibung</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">OutputStream</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">Writer</span></p>
</td>
<td class="tabellentext">
<p>abstrakte Klasse für Zeichenausgabe oder Byte-Ausgabe</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">BufferedOutputStream</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">BufferedWriter</span></p>
</td>
<td class="tabellentext">
<p>Ausgabe des Puffers. Nutzt passendes Zeilenendezeichen.</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">ByteArrayOutputStream</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">CharArrayWriter</span></p>
</td>
<td class="tabellentext">
<p>Schreibt in Arrays.</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">DataOutputStream</span></p>
</td>
<td class="tabellentext">
<p>(keine Entsprechung)</p>
</td>
<td class="tabellentext">
<p>Schreibt Primitive und auch UTF-8.</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p>(keine Entsprechung)</p>
</td>
<td class="tabellentext">
<p><span class="clisting">OutputStreamWriter</span></p>
</td>
<td class="tabellentext">
<p>Übersetzt Zeichen-Streams in Byte-Streams.</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">FileOutputStream</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">FileWriter</span></p>
</td>
<td class="tabellentext">
<p>Schreibt in eine Datei.</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">PrintStream</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">PrintWriter</span></p>
</td>
<td class="tabellentext">
<p>Konvertiert primitive Datentypen in Strings, und schreibt sie in einen Ausgabestrom.</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">PipedOutputStream</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">PipedWriter</span></p>
</td>
<td class="tabellentext">
<p>Schreibt in eine Pipe.</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p>(keine Entsprechung)</p>
</td>
<td class="tabellentext">
<p><span class="clisting">StringWriter</span></p>
</td>
<td class="tabellentext">
<p>Schreibt in einen String.</p>
</td>
</tr>
</table><br><p>Die beiden vorangehenden Tabellen sind segmentiert nach Eingabe- und Ausgabeklassen. Die Klassen lassen sich aber auch anders sortieren, etwa nach der Ressource:</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 17.5    </strong>Ein-/Ausgabeklassen nach Ressourcenzugehörigkeit</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">Ressource</span>
</td>
<td class="tabellenkopf"><span class="cfett">Zeichenorientierte Klasse</span>
</td>
<td class="tabellenkopf"><span class="cfett">Byteorientierte Klasse</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p>Datei</p>
</td>
<td class="tabellentext">
<p><span class="clisting">FileReader
FileWriter</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">FileInputStream
FileOutputStream</span></p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p>Speicher</p>
</td>
<td class="tabellentext">
<p><span class="clisting">CharArrayReader
CharArrayWriter
StringReader
StringWriter</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">ByteArrayInputStream
ByteArrayOutputStream</span>
&#8211;
&#8211;</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p>Pipe</p>
</td>
<td class="tabellentext">
<p><span class="clisting">PipeReader
PipeWriter</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">PipeInputStream
PipeOutputStream</span></p>
</td>
</tr>
</table><br><a id="mjd34b697cdf6ea75732127f6a06fc88b0" name="mjd34b697cdf6ea75732127f6a06fc88b0"></a><a name="t33"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t34"></a><h3 class="t3"><span class="cfett">17.2.3</span> Die abstrakte Basisklasse »OutputStream«  <a href="#t2t35"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t33"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Der Clou bei allen Datenströmen ist nun, dass spezielle Unterklassen wissen, wie sie genau die vorgeschriebene Funktionalität implementieren. Wenn wir uns den <span class="clisting">OutputStream</span> anschauen, dann sehen wir auf den ersten Blick, dass hier alle wesentlichen Operationen um das Schreiben versammelt sind. Das heißt, dass ein konkreter Stream, der in Dateien schreibt, nun weiß, wie er Bytes in Dateien schreiben wird. Java ist auf der unteren Ebene mit seiner Plattformunabhängigkeit am Ende, und native Methoden schreiben die Bytes.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">abstract class java.io.<span class="cfett">OutputStream</span>
implements Closeable, Flushable</pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">abstract void write( int b ) throws IOException</span>
Schreibt ein einzelnes Byte in den Datenstrom.</li>
</ul>
<ul class="gp">
<li><span class="clisting">void write( byte[] b ) throws IOException</span>
Schreibt die Bytes aus dem Array in den Strom.</li>
</ul>
<ul class="gp">
<li><span class="clisting">void write( byte[] b, int off, int len ) throws IOException</span>
Schreibt Teile des Byte-Feldes, nämlich <span class="clisting">len</span> Byte ab der Position <span class="clisting">off</span>, in den Ausgabestrom.</li>
</ul>
<ul class="gp">
<li><span class="clisting">void close() throws IOException</span>
Schließt den Datenstrom. Einzige Methode aus <span class="clisting">Closeable</span>.</li>
</ul>
<ul class="gp">
<li><span class="clisting">void flush() throws IOException</span>
Schreibt noch im Puffer gehaltene Daten. Einzige Methode aus der Schnittstelle <span class="clisting">Flushable</span>.</li>
</ul>
<p>Die <span class="clisting">IOException</span> ist keine <span class="clisting">RuntimeException</span>, muss also behandelt werden.</p>
<p>Zwei Eigenschaften lassen sich an den Methoden ablesen: zum einen, dass nur Bytes geschrieben werden, und zum anderen, dass nicht wirklich alle Methoden <span class="clisting">abstract</span> sind. Nicht alle diese Methoden sind wirklich elementar, müssen also nicht von allen Ausgabeströmen überschrieben werden. Wir entdecken, dass nur <span class="clisting">write(int)</span> abstrakt ist. Das würde aber bedeuten, dass alle anderen Methoden konkret wären. Gleichzeitig stellt sich die Frage, wie ein <span class="clisting">OutputStream</span>, der die Eigenschaften für alle erdenklichen Ausgabeströme vorschreibt, denn wissen kann, wie ein spezieller Ausgabestrom etwa geschlossen (<span class="clisting">close()</span>) wird oder seine gepufferten Bytes schreibt (<span class="clisting">flush()</span>). Das weiß er natürlich nicht, aber die Entwickler haben sich dazu entschlossen, eine leere Implementierung anzugeben. Der Vorteil besteht darin, dass Programmierer von Unterklassen nicht verpflichtet werden, immer die Methoden zu überschreiben, auch wenn sie sie gar nicht nutzen wollen.</p>
<h4 class="t4">Über konkrete und abstrakte Schreibmethoden *</h4>
<p>Es fällt auf, dass es zwar drei Schreibmethoden gibt, aber nur eine davon wirklich abstrakt ist. Das ist trickreich, denn tatsächlich lassen sich die Methoden, die ein Byte-Feld schreiben, auf die Methode abbilden, die ein einzelnes Byte schreibt. Wir werfen einen Blick in den Quellcode der Bibliothek:</p>
<div class="listing"><pre class="prettyprint">public void write(byte[] b) throws IOException {
  write(b, 0, b.length);
}

public void write(byte[] b, int off, int len) throws IOException {
  if (b == null)
    throw new NullPointerException();
  else if ((off &lt; 0) || (off &gt; b.length) || (len &lt; 0) ||
    ((off + len) &gt; b.length) || ((off + len) &lt; 0)) {
    throw new IndexOutOfBoundsException();
  } else if (len == 0)
    return;
  for (int i = 0 ; i &lt; len ; i++)
    write(b[off + i]);
}</pre></div>
<p>An beiden Implementierungen ist zu erkennen, dass sie die Arbeit sehr bequem an andere Methoden verschieben. Doch diese Implementierung ist nicht optimal! Stellen wir uns vor, ein Dateiausgabestrom überschreibt nur die eine abstrakte Methode, die nötig ist. Und nehmen wir weiterhin an, dass unser Programm nun immer ganze Byte-Felder schreibt, etwa eine 5-MB-Datei, die im Speicher steht. Dann werden für jedes Byte im Byte-Array in einer Schleife alle Bytes der Reihe nach an eine vermutlich native Methode übergeben. Wenn es so implementiert wäre, könnten wir die Geschwindigkeit des Mediums überhaupt nicht nutzen, zumal jedes Dateisystem Funktionen bereitstellt, mit denen sich ganze Blöcke übertragen lassen. Glücklicherweise sieht die Implementierung nicht so aus, da wir in dem Modell vergessen haben, dass die Unterklasse zwar die abstrakte Methode implementieren muss, aber immer noch andere Methoden überschreiben kann. Ein späterer Blick auf die Klasse <span class="clisting">FileOutputStream</span> bestätigt dies.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Ruft eine Oberklasse eine abstrakte Methode auf, die in der Unterklasse implementiert wird, ist das ein Entwurfsmuster mit dem Namen <span class="ckursiv">Schablonen-Muster</span> oder englisch »<span class="ckursiv">template pattern</span>«.</p>
</td>
</tr>
</table><br><a id="mj2202e460fa14e6ecb6820f4ef86a77f8" name="mj2202e460fa14e6ecb6820f4ef86a77f8"></a><a name="t34"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t35"></a><h3 class="t3"><span class="cfett">17.2.4</span> Die Schnittstellen »Closeable« und »Flushable«  <a href="#t2t36"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t34"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p><span class="clisting">Closeable</span> wird von allen lesenden und schreibenden Datenstrom-Klassen implementiert, die geschlossen werden können. Das sind alle <span class="clisting">Reader</span>/<span class="clisting">Writer</span>- und <span class="clisting">InputStream</span>/<span class="clisting">OutputStream</span>-Klassen und weitere Klassen wie <span class="clisting">Socket</span>.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">interface java.io.<span class="cfett">Closeable</span>
extends AutoClosable</pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">void close() throws IOException</span>
Schließt den Datenstrom. Einen geschlossenen Strom noch einmal zu schließen, hat keine Konsequenz.</li>
</ul>
<p>Die Schnittstelle <span class="clisting">Closeable</span> erweitert <span class="clisting">java.lang.AutoCloseable</span>, sodass alles, was <span class="clisting">Closeable</span> implementiert damit vom Typ <span class="clisting">AutoCloseable</span> ist und als Variable in einem ARM-Block verwendet werden kann.</p>
<p><span class="clisting">Flushable</span> findet sich nur bei schreibenden Klassen und ist insbesondere bei denen wichtig, die Daten puffern.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">interface java.io.<span class="cfett">Flushable</span></pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">void flush() throws IOException</span>
Schreibt gepufferte Daten in den Strom.</li>
</ul>
<p>Die Basisklassen <span class="clisting">Reader</span> und <span class="clisting">OutputStream</span> implementieren diese Schnittstelle, aber auch <span class="clisting">Formatter</span>.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Jeder <span class="clisting">InputStream</span>, <span class="clisting">OutputStream</span>, <span class="clisting">Reader</span> und <span class="clisting">Writer</span> implementiert <span class="clisting">close()</span> und mit dem <span class="clisting">close()</span> auch den Zwang, eine geprüfte <span class="clisting">IOException</span> zu behandeln. Bei einem Eingabestrom ist die Exception nahezu wertlos und kann auch tatsächlich ignoriert werden. Bei einem Ausgabestrom ist die Exception schon deutlich wertvoller. Das liegt in der Aufgabe vom <span class="clisting">close()</span>, die nicht nur darin besteht, die Ressource zu schließen, sondern vorher noch gepufferte Daten zu schreiben. Somit ist ein <span class="clisting">close()</span> oft ein indirektes <span class="clisting">write()</span>, und hier es ist es sehr wohl wichtig, zu wissen, ob alle Restdaten korrekt geschrieben wurden. Die Ausnahme sollte auf keinen Fall ignoriert werden und der <span class="clisting">catch</span>-Block einfach leer bleiben; Logging ist hier das mindeste.</p>
</td>
</tr>
</table><br><a id="mj25199db178b60bddb59bd9defea22c22" name="mj25199db178b60bddb59bd9defea22c22"></a><a name="t35"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t36"></a><h3 class="t3"><span class="cfett">17.2.5</span> Ein Datenschlucker *  <a href="#t2t37"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t35"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Damit wir sehen können, wie alle Unterklassen prinzipiell mit <span class="clisting">OutputStream</span> umgehen, wollen wir eine Klasse entwerfen, die alle ihre gesendeten Daten verwirft. Die Klasse ist mit dem Unix-Device /<span class="ckursiv">dev</span>/<span class="ckursiv">null</span> vergleichbar. Die Implementierung ist die einfachste, die sich denken lässt, denn alle <span class="clisting">write()</span>-Methoden machen nichts:</p>
<p class="tabunter"><strong>Listing 17.4    </strong>com/tutego/insel/io/stream/NullOutputStream.java</p>
<div class="listing"><pre class="prettyprint">package com.tutego.insel.io.stream;

public final class NullOutputStream extends java.io.OutputStream
{
  @Override public void write( byte[] b ) { /* Empty */ }
  @Override public void write( byte[] b, int off, int len ) { /* Empty */ }
  @Override public void write( int b ) { /* Empty */ }
}</pre></div>
<p>Da <span class="clisting">close()</span> und <span class="clisting">flush()</span> ohnehin schon mit einem leeren Block implementiert sind, brauchen wir sie nicht noch einmal zu überschreiben. Aus Effizienzgründen (!) geben wir auch eine Implementierung für die Schreib-Feld-Methoden an.</p><a id="mj534fca11b85556e6eec99b4fdd7a4553" name="mj534fca11b85556e6eec99b4fdd7a4553"></a><a name="t36"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t37"></a><h3 class="t3"><span class="cfett">17.2.6</span> Die abstrakte Basisklasse »InputStream«  <a href="#t2t38"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t36"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Das Gegenstück zu <span class="clisting">OutputStream</span> ist <span class="clisting">InputStream</span>; jeder binäre Eingabestrom wird durch die abstrakte Klasse <span class="clisting">InputStream</span> repräsentiert. Die Konsoleneingabe <span class="clisting">System.in</span> ist vom Typ <span class="clisting">InputStream</span>.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">abstract class java.io.<span class="cfett">InputStream</span>
implements Closeable</pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">int available() throws IOException</span>
Gibt die Anzahl der verfügbaren Zeichen im Datenstrom zurück, die sofort ohne Blockierung gelesen werden können.</li>
</ul>
<ul class="gp">
<li><span class="clisting">int read() throws IOException</span>
Liest ein Byte als Integer aus dem Datenstrom. Ist das Ende des Datenstroms erreicht, wird <span class="clisting">&#8211;1</span> übergeben. Die Methode ist überladen, wie die nächsten Signaturen zeigen.</li>
</ul>
<ul class="gp">
<li><span class="clisting">int read( byte[] b ) throws IOException</span>
Liest mehrere Bytes in ein Feld. Die tatsächliche Länge der gelesenen Bytes wird zurückgegeben und muss nicht <span class="clisting">b.length()</span> sein.</li>
</ul>
<ul class="gp">
<li><span class="clisting">int read( byte[] b, int off, int len ) throws IOException</span>
Liest den Datenstrom in ein Byte-Feld, schreibt ihn aber erst an der Stelle <span class="clisting">off</span> in das Byte-Feld. Zudem begrenzt <span class="clisting">len</span> die maximale Anzahl der zu lesenden Zeichen.</li>
</ul>
<ul class="gp">
<li><span class="clisting">long skip( long n ) throws IOException</span>
Überspringt eine Anzahl von Zeichen. Die Rückgabe gibt die tatsächlich gesprungenen Bytes zurück, was nicht mit <span class="clisting">n</span> identisch sein muss.</li>
</ul>
<ul class="gp">
<li><span class="clisting">void close() throws IOException</span>
Schließt den Datenstrom. Operation aus der Schnittstelle <span class="clisting">Closeable</span>.</li>
</ul>
<ul class="gp">
<li><span class="clisting">boolean markSupported()</span>
Gibt einen Wahrheitswert zurück, ob der Datenstrom das Merken und Zurücksetzen von Positionen gestattet. Diese Markierung ist ein Zeiger, der auf bestimmte Stellen in der Eingabedatei zeigen kann.</li>
</ul>
<ul class="gp">
<li><span class="clisting">void mark( int readlimit )</span>
Merkt sich eine Position im Datenstrom.</li>
</ul>
<ul class="gp">
<li><span class="clisting">void reset() throws IOException</span>
Springt wieder zu der Position zurück, die mit <span class="clisting">mark()</span> gesetzt wurde.</li>
</ul>
<p>Auffällig ist, dass bis auf <span class="clisting">mark()</span> und <span class="clisting">markSupported()</span> alle Methoden im Fehlerfall eine <span class="clisting">IOException</span> auslösen.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span><span class="clisting">available()</span> liefert die Anzahl Bytes, die ohne Blockierung gelesen werden können (blockieren bedeutet, dass die Methode nicht sofort zurückkehrt, sondern erst wartet, bis neue Daten vorhanden sind). Die Rückgabe von <span class="clisting">available()</span> sagt nichts darüber aus, wie viele Zeichen der <span class="clisting">InputStream</span> insgesamt hergibt. Während aber bei <span class="clisting">FileInputStream</span> die Methode <span class="clisting">available()</span> üblicherweise doch die Dateilänge liefert, ist dies bei den Netzwerk-Streams im Allgemeinen nicht der Fall.</p>
</td>
</tr>
</table><br><a id="mjc2905c008847dad671feaa7501f0d82f" name="mjc2905c008847dad671feaa7501f0d82f"></a><a name="t37"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t38"></a><h3 class="t3"><span class="cfett">17.2.7</span> Ressourcen aus dem Klassenpfad und aus Jar–Archiven laden  <a href="#t2t39"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t37"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Um Ressourcen wie Grafiken oder Konfigurationsdateien aus Jar-Archiven zu laden, ist die Methode <span class="clisting">getResourceAsStream()</span> beziehungsweise <span class="clisting">getResource()</span> ideal. Beide sind Methoden des <span class="clisting">Class</span>-Objekts. <span class="clisting">getResource()</span> gibt ein <span class="clisting">URL</span>-Objekt für die Ressource zurück. Da oft der Inhalt des Datenstroms interessant ist, liefert <span class="clisting">getResourceAsStream()</span> einen <span class="clisting">InputStream</span>. Intern wird aber nichts anderes gemacht, als <span class="clisting">getResource()</span> aufzurufen und mit <span class="clisting">openStream()</span> ein Eingabe-Objekt zu holen. Nur <span class="clisting">getResourceAsStream()</span> fängt eine eventuelle <span class="clisting">IOException</span> ab und liefert dann die Rückgabe <span class="clisting">null</span>.</p>
<p>Da der Klassenlader die Ressource findet, entdeckt er alle Dateien, die im Pfad des Klassenladers eingetragen sind. Das gilt auch für Jar-Archive, weil dort vom Klassenlader alles verfügbar ist. Konnte die Quelle nicht aufgelöst werden, liefern die Methoden <span class="clisting">null</span>. Die Methode <span class="clisting">getResourceAsStream()</span> liefert auch <span class="clisting">null</span>, wenn die Sicherheitsrichtlinien das Lesen verbieten.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Besorge einen Eingabestrom <span class="clisting">in1</span> auf die Datei <span class="ckursiv">kullin_fun.txt</span> und einen zweiten Eingabestrom <span class="clisting">in2</span> auf die Datei <span class="ckursiv">hirse_fun.jpg</span> innerhalb der eigenen Methode <span class="clisting">init()</span>:</p>
<div class="listing"><pre class="prettyprint">class Classi
{
  InputStream in1 = Classi.<span class="cfett">class.getResourceAsStream</span>( "kullin_fun.txt" );
  void init()
  {
    InputStream in2 = <span class="cfett">getClass().getResourceAsStream</span>( "hirse_fun.jpg" );
  }
}</pre></div>
</td>
</tr>
</table><br><p>Da zum Nutzen der <span class="clisting">getResourceXXX()</span>-Methoden ein <span class="clisting">Class</span>-Objekt nötig ist, zeigt das Beispiel zum einen, dass über <span class="clisting">Classi.class</span> das <span class="clisting">Class</span>-Objekt zu bekommen ist, und zum anderen, dass in einer Objektmethode ebenfalls die geerbte <span class="clisting">Object</span>-Methode <span class="clisting">getClass()</span> ein <span class="clisting">Class</span>-Objekt liefert.</p><a id="mj8c65b2939c83b858ed311032513e29b4" name="mj8c65b2939c83b858ed311032513e29b4"></a><a name="t38"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t39"></a><h3 class="t3"><span class="cfett">17.2.8</span> Ströme mit SequenceInputStream zusammensetzen *  <a href="#t2t310"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t38"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Ein <span class="clisting">SequenceInputStream</span>-Filter hängt mehrere Eingabeströme zu einem großen Eingabestrom zusammen. Nützlich ist dies, wenn wir aus Strömen lesen wollen und es uns egal ist, was für ein Strom es ist, wo er startet und wo er aufhört. Der <span class="clisting">SequenceInputStream</span> lässt sich erzeugen, indem im Konstruktor zwei <span class="clisting">InputStream</span>-Objekte mitgegeben werden. Soll aus zwei Dateien ein zusammengesetzter Datenstrom gebildet werden, benutzen wir folgende Programmzeilen:</p>
<div class="listing"><pre class="prettyprint">InputStream s1 = new FileInputStream( "teil1.txt" );
InputStream s2 = new FileInputStream( "teil2.txt" );
InputStream s  = new SequenceInputStream( s1, s2 );</pre></div>
<p>Ein Aufruf irgendeiner <span class="clisting">read()</span>-Methode liest nun erst Daten aus <span class="clisting">s1</span>. Liefert <span class="clisting">s1</span> keine Daten mehr, kommen die Daten aus <span class="clisting">s2</span>. Liegen keine Daten mehr an <span class="clisting">s2</span>, aber wieder an <span class="clisting">s1</span>, ist es zu spät.</p>
<p>Für drei Ströme kann eine Kette aus zwei <span class="clisting">SequenceInputStream</span>-Objekten gebaut werden:</p>
<div class="listing"><pre class="prettyprint">InputStream in = new SequenceInputStream( stream1,
  new SequenceInputStream(stream2, stream3) );</pre></div>
<p>Sollen mehr als zwei Ströme miteinander verbunden werden, kann auch eine <span class="clisting">Enumeration</span> im Konstruktor übergeben werden. Die <span class="clisting">Enumeration</span> einer Datenstruktur gibt dann die zu kombinierenden Datenströme zurück. Wir haben eine Datenstruktur, die sich hier gut anbietet: <span class="clisting">Vector</span> (<span class="clisting">List</span> geht leider nicht, da diese nur einen <span class="clisting">Iterator</span>, aber keine <span class="clisting">Enumeration</span> liefert).</p>
<div class="listing"><pre class="prettyprint">Vector&lt;InputStream&gt; v = new Vector&lt;InputStream&gt;();
v.addElement( stream1 );
v.addElement( stream2 );
v.addElement( stream3 );
InputStream seq = new SequenceInputStream( v.elements() );</pre></div>
<p>Wir verstauen alle Eingabeströme in einen <span class="clisting">Vector</span> und nutzen dann die <span class="clisting">elements()</span>-Methode für die Aufzählung.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">class java.io.<span class="cfett">SequenceInputStream</span>
extends InputStream</pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">SequenceInputStream( InputStream s1, InputStream s2 )</span>
Erzeugt einen <span class="clisting">SequenceInputStream</span> aus zwei einzelnen <span class="clisting">InputStream</span>-Objekten. Zuerst werden die Daten aus <span class="clisting">s1</span> gelesen und dann aus <span class="clisting">s2</span>.</li>
</ul>
<ul class="gp">
<li><span class="clisting">SequenceInputStream( Enumeration&lt;? extends InputStream&gt; e )</span>
Die Eingabeströme für den <span class="clisting">SequenceInputStream</span> werden aus der <span class="clisting">Enumeration</span> mit <span class="clisting">nextElement()</span> geholt. Ist ein Strom ausgesaugt, wird die <span class="clisting">close()</span>-Methode aufgerufen und der nächste vorhandene Strom geöffnet.</li>
</ul>
<ul class="gp">
<li><span class="clisting">int available() throws IOException</span>
Liefert die Anzahl der Zeichen, die gelesen werden können. Die Daten betreffen immer den aktuellen Strom.</li>
</ul>
<ul class="gp">
<li><span class="clisting">int read() throws IOException</span>
Liefert das Zeichen oder &#8211;1, wenn das Ende aller Datenströme erreicht ist.</li>
</ul>
<ul class="gp">
<li><span class="clisting">int read( byte[] b, int off, int len ) throws IOException</span>
Liest Zeichen in ein Feld und gibt die Anzahl tatsächlich gelesener Zeichen oder &#8211;1 zurück.</li>
</ul>
<ul class="gp">
<li><span class="clisting">void close() throws IOException</span>
Schließt alle Ströme, die vom <span class="clisting">SequenceInputStream</span>-Objekt eingebunden sind.</li>
</ul>
<p>Der folgende Programmausschnitt legt mit einem <span class="clisting">SequenceInputStream</span> den Datenstrom eines <span class="clisting">ByteArrayInputStream</span> mit einem Datei-Datenstrom zusammen. Es werden anschließend Zeilennummern und Zeileninhalt ausgegeben, wobei sehr schön deutlich wird, dass erst der String und dann die Datei ausgelesen wird. Die Datei muss sich im Pfad befinden, da sie sonst nicht gefunden werden kann:</p>
<p class="tabunter"><strong>Listing 17.5    </strong>com/tutego/insel/io/stream/SequenceInputStreamDemo.java, main()</p>
<div class="listing"><pre class="prettyprint">String s = "Gezeitenrechnung\nfür\nSchlickrutscher\n";
<span class="cfett">
InputStream bais</span> = new ByteArrayInputStream( s.getBytes() );<span class="cfett">
InputStream reis</span> = SequenceInputStreamDemo.class.getResourceAsStream( 
                   "/lyrics.txt" );
<span class="cfett">
InputStream</span>     <span class="cfett"> sis = new SequenceInputStream( bais, reis );</span>
LineNumberReader lnr = new LineNumberReader( new InputStreamReader(sis) );

for ( String line; (line = lnr.readLine()) != null; )
  System.out.printf( "%2d:%s%n", lnr.getLineNumber(), line );</pre></div>
<p>Zum Ausgeben der Zeilen nutzt das Programm einen <span class="clisting">LineNumberReader</span>, der neben der Methode <span class="clisting">readLine()</span> auch die Methode <span class="clisting">getLineNumber()</span> anbietet. Um für Unicode-Zeichen einen <span class="clisting">LineNumberReader</span> aber überhaupt verwenden zu können &#8211; und keinen veralteten <span class="clisting">LineNumberInputStream</span> für Bytes &#8211;, konvertiert ein <span class="clisting">InputStreamReader</span> die <span class="clisting">byte</span> des <span class="clisting">SequenceInputStream</span> in <span class="clisting">char</span> für den Reader; es gibt leider keinen <span class="clisting">SequenceReader</span>.</p><a id="mjb3889bbefb776f81c16212ee860a5b81" name="mjb3889bbefb776f81c16212ee860a5b81"></a><a name="t39"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t310"></a><h3 class="t3"><span class="cfett">17.2.9</span> Die abstrakte Basisklasse »Writer«  <a href="#t2t311"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t39"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Die Basis für alle wichtigen Klassen ist die abstrakte Basisklasse <span class="clisting">Writer</span>.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">abstract class java.io.<span class="cfett">Writer</span>
implements Appendable, Closeable, Flushable</pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">protected Writer( Object lock )</span>
Erzeugt einen <span class="clisting">Writer</span>-Stream, der sich mit dem übergebenen Synchronisationsobjekt initialisiert. Ist die Referenz <span class="clisting">null</span>, so gibt es eine <span class="clisting">NullPointerException</span>.</li>
</ul>
<ul class="gp">
<li><span class="clisting">protected Writer()</span>
Erzeugt einen <span class="clisting">Writer</span>-Stream, der sich selbst als Synchronisationsobjekt nutzt. Der Konstruktor ist für die Unterklassen interessant, die kein eigenes <span class="clisting">Lock</span>-Objekt zuordnen wollen.</li>
</ul>
<ul class="gp">
<li><span class="clisting">void write( int c ) throws IOException</span>
Schreibt ein einzelnes Zeichen. Von der 32-Bit-Ganzzahl wird der niedrige Teil (16 Bit des <span class="clisting">int</span>) geschrieben.</li>
</ul>
<ul class="gp">
<li><span class="clisting">void write( char[] cbuf ) throws IOException</span>
Schreibt ein Feld von Zeichen.</li>
</ul>
<ul class="gp">
<li><span class="clisting">abstract void write( char[] cbuf, int off, int len ) throws IOException</span>
Schreibt <span class="clisting">len</span> Zeichen des Felds <span class="clisting">cbuf</span> ab der Position <span class="clisting">off</span>.</li>
</ul>
<ul class="gp">
<li><span class="clisting">void write( String str ) throws IOException</span>
Schreibt einen String.</li>
</ul>
<ul class="gp">
<li><span class="clisting">void write( String str, int off, int len ) throws IOException</span>
Schreibt <span class="clisting">len</span> Zeichen der Zeichenkette <span class="clisting">str</span> ab der Position <span class="clisting">off</span>.</li>
</ul>
<ul class="gp">
<li><span class="clisting">Writer append( char c ) throws IOException</span>
Hängt ein Zeichen an. Verhält sich wie <span class="clisting">write(c)</span>, nur liefert es, wie die Schnittstelle <span class="clisting">Appendable</span> verlangt, ein <span class="clisting">Appendable</span> zurück. <span class="clisting">Writer</span> ist ein passendes <span class="clisting">Appendable</span>.</li>
</ul>
<ul class="gp">
<li><span class="clisting">Writer append( CharSequence csq ) throws IOException</span>
Hängt eine Zeichenfolge an. Auch aus der Schnittstelle <span class="clisting">Appendable</span>.</li>
</ul>
<ul class="gp">
<li><span class="clisting">abstract void flush() throws IOException</span>
Schreibt den internen Puffer. Hängt verschiedene <span class="clisting">flush()</span>-Aufrufe zu einer Kette zusammen, die sich aus der Abhängigkeit der Objekte ergibt. So werden alle Puffer geschrieben. Aus der Schnittstelle <span class="clisting">Flushable</span>.</li>
</ul>
<ul class="gp">
<li><span class="clisting">abstract void close() throws IOException</span>
Schreibt den gepufferten Strom und schließt ihn. Nach dem Schließen durchgeführte <span class="clisting">write()</span>- oder <span class="clisting">flush()</span>-Aufrufe bringen eine <span class="clisting">IOException</span> mit sich. Ein zusätzliches <span class="clisting">close()</span> löst keine Exception aus. Aus der Schnittstelle <span class="clisting">Closeable</span>.</li>
</ul>
<h4 class="t4">Wie die abstrakten Methoden genutzt und überschrieben werden *</h4>
<p>Uns fällt auf, dass von den sieben Methoden lediglich <span class="clisting">flush()</span>, <span class="clisting">close()</span> und <span class="clisting">write(char[], int, int)</span> abstrakt sind. Zum einen bedeutet dies, dass konkrete Unterklassen nur diese Methoden implementieren müssen, und zum anderen, dass die übrigen <span class="clisting">write()</span>-Methoden auf die eine überschriebene Implementierung zurückgreifen. Werfen wir daher einen Blick auf die Nutznießer:</p>
<div class="listing"><pre class="prettyprint">public void write( int c ) throws IOException
{
  synchronized ( lock ) {
    if ( writeBuffer == null )
      writeBuffer = new char[ writeBufferSize ];

    writeBuffer[0] = (char) c;
    write( writeBuffer, 0, 1 );
  }
}</pre></div>
<p>Wird ein Zeichen geschrieben, so wird zunächst einmal nachgesehen, ob schon früher ein temporärer Puffer eingerichtet wurde (ein schöner Trick, denn Speicherbeschaffung ist nicht ganz billig). Wenn nicht, dann erzeugt die Methode zunächst ein Array mit der Größe von 1.024 Zeichen (dies ist die eingestellte Puffer-Größe). Dann schreibt <span class="clisting">write(int)</span> das Zeichen in den Puffer und ruft die abstrakte Methode auf &#8211; die ja in einer Unterklasse implementiert wird. Ist der Parameter ein Feld, so muss lediglich die Größe an die abstrakte Methode übergeben werden. Alle Schreiboperationen sind mit einem <span class="clisting">lock</span>-Objekt synchronisiert und können sich demnach nicht in die Quere kommen. Die Synchronisation wird entweder durch ein eigenes <span class="clisting">lock</span>-Objekt durchgeführt, das dann im Konstruktor angegeben werden muss, oder die Klasse verwendet das <span class="clisting">this</span>-Objekt der <span class="clisting">Writer</span>-Klasse als Sperrobjekt.</p><a id="mj8bdb238857679cf8eede58d00850de6b" name="mj8bdb238857679cf8eede58d00850de6b"></a><a name="t310"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t311"></a><h3 class="t3"><span class="cfett">17.2.10</span> Die Schnittstelle »Appendable« *  <a href="#t2t312"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t310"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Alle <span class="clisting">Writer</span> und auch die Klassen <span class="clisting">PrintStream</span>, <span class="clisting">CharBuffer</span> sowie <span class="clisting">StringBuffer</span> und <span class="clisting">StringBuilder</span> implementierten die Schnittstelle <span class="clisting">Appendable</span>, die drei Methoden vorschreibt:</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">interface java.io.<span class="cfett">Appendable</span></pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">Appendable append( char c )</span>
Hängt das Zeichen <span class="clisting">c</span> an das aktuelle <span class="clisting">Appendable</span> an und liefert das aktuelle Objekt vom Typ <span class="clisting">Appendable</span> wieder zurück.</li>
</ul>
<ul class="gp">
<li><span class="clisting">Appendable append( CharSequence csq )</span>
Hängt die Zeichenfolge an dieses <span class="clisting">Appendable</span> an und liefert es wieder zurück.</li>
</ul>
<ul class="gp">
<li><span class="clisting">Appendable append( CharSequence csq, int start, int end )</span>
Hängt einen Teil der Zeichenfolge an dieses <span class="clisting">Appendable</span> an und liefert es wieder zurück.</li>
</ul>
<h4 class="t4">Kovariante Rückgabe in »Writer« von »Appendable«</h4>
<p>Die Klasse <span class="clisting">Writer</span> demonstriert gut einen kovarianten Rückgabetyp, alsodass der Rückgabetyp einer überschriebenen oder implementierten Methode ebenfalls ein Untertyp sein kann. So verfährt auch <span class="clisting">Writer</span>, der die Schnittstelle <span class="clisting">Appendable</span> implementiert. Die Methode <span class="clisting">append()</span> in <span class="clisting">Writer</span> besitzt nicht einfach den Rückgabetyp <span class="clisting">Appendable</span> aus der Schnittstelle <span class="clisting">Appendable</span>, sondern konkretisiert ihn zu <span class="clisting">Writer</span>, was ein <span class="clisting">Appendable</span> ist.</p>
<div class="listing"><pre class="prettyprint">public<span class="cfett"> Writer</span> append( char c ) throws IOException
{
  write( c );
  return this;
}</pre></div><a id="mj923c62d6bac3e8a5c5b75c58df0b0bd3" name="mj923c62d6bac3e8a5c5b75c58df0b0bd3"></a><a name="t311"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t312"></a><h3 class="t3"><span class="cfett">17.2.11</span> Die abstrakte Basisklasse »Reader«  <img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"><a href="#t2t311"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Die abstrakte Klasse <span class="clisting">Reader</span> dient zum Lesen von Zeichen aus einem zeichengebenden Eingabestrom. Die einzigen Methoden, die Unterklassen implementieren müssen, sind <span class="clisting">read(char[], int, int)</span> und <span class="clisting">close()</span>. Dies entspricht dem Vorgehen bei den <span class="clisting">Writer</span>-Klassen, die auch nur <span class="clisting">close()</span> und <span class="clisting">write(char[], int, int)</span> implementieren müssen. Eine abstrakte <span class="clisting">flush()</span>-Methode, wie sie <span class="clisting">Writer</span> besitzt, kann <span class="clisting">Reader</span> nicht haben. Es bleiben demnach für die <span class="clisting">Reader</span>-Klasse zwei abstrakte Methoden übrig. Die Unterklassen implementieren jedoch auch andere Methoden aus Geschwindigkeitsgründen neu.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">abstract class java.io.<span class="cfett">Reader</span>
implements Readable, Closeable</pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">protected Reader()</span>
Erzeugt einen neuen Reader, der sich mit sich selbst synchronisiert.</li>
</ul>
<ul class="gp">
<li><span class="clisting">protected Reader( Object lock )</span>
Erzeugt einen neuen Reader, der mit dem Objekt <span class="clisting">lock</span> synchronisiert ist.</li>
</ul>
<ul class="gp">
<li><span class="clisting">abstract int read( char[] cbuf, int off, int len ) throws IOException</span>
Liest <span class="clisting">len</span> Zeichen in den Puffer <span class="clisting">cbuf</span> ab der Stelle <span class="clisting">off</span>. Wenn <span class="clisting">len</span> Zeichen nicht vorhanden sind, wartet der Reader. Gibt die Anzahl gelesener Zeichen zurück oder &#8211;1, wenn das Ende des Stroms erreicht wurde.</li>
</ul>
<ul class="gp">
<li><span class="clisting">int read( CharBuffer target ) throws IOException</span>
Liest Zeichen in den <span class="clisting">CharBuffer</span>. Die Methode schreibt die Schnittstelle <span class="clisting">Readable</span> vor.</li>
</ul>
<ul class="gp">
<li><span class="clisting">int read() throws IOException</span>
Die parameterlose Methode liest das nächste Zeichen aus dem Eingabestrom. Die Methode wartet, wenn kein Zeichen im Strom bereitliegt. Der Rückgabewert ist ein <span class="clisting">int</span> im Bereich 0 bis 65.635 (0x0000&#8211;0xFFFF). Warum dann der Rückgabewert aber <span class="clisting">int</span> und nicht <span class="clisting">char</span> ist, kann leicht damit erklärt werden, dass die Methode den Rückgabewert &#8211;1 (0xFFFFFFFF) kodieren muss, falls keine Daten anliegen.</li>
</ul>
<ul class="gp">
<li><span class="clisting">int read( char[] cbuf ) throws IOException</span>
Liest Zeichen aus dem Strom und schreibt sie in ein Feld. Die Methode wartet, bis Eingaben anliegen. Der Rückgabewert ist die Anzahl der gelesenen Zeichen oder &#8211;1, wenn das Ende des Datenstroms erreicht wurde.</li>
</ul>
<ul class="gp">
<li><span class="clisting">abstract void close() throws IOException</span>
Schließt den Strom. Folgt anschließend noch ein Aufruf von <span class="clisting">read()</span>, <span class="clisting">ready()</span>, <span class="clisting">mark()</span> oder <span class="clisting">reset()</span>, lösen diese eine <span class="clisting">IOException</span> aus. Ein doppelt geschlossener Stream hat keinen weiteren Effekt.</li>
</ul>
<h4 class="t4">Weitere Methoden</h4>
<p>Zu diesen notwendigen Methoden, die bei der Klasse <span class="clisting">Reader</span> gegeben sind, kommen noch weitere interessante Methode hinzu, die den Status abfragen und Positionen setzen lassen. Die Methode <span class="clisting">ready()</span> liefert als Rückgabe <span class="clisting">true</span>, wenn ein <span class="clisting">read()</span> ohne Blockierung der Eingabe möglich ist. Die Standard-Implementierung der abstrakten Klasse <span class="clisting">Reader</span> gibt immer <span class="clisting">false</span> zurück.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Zum Lesern aller Zeichen muss so lange der Datenstrom ausgesaugt werden, bis keine Daten mehr verfügbar sind. Der Endetest kann auf zwei Arten geschehen: einmal über <span class="clisting">ready()</span> und einmal auf den Test der Rückgabe von <span class="clisting">read()</span>, auf &#8211;1. Die erste Variante:</p>
<div class="listing"><pre class="prettyprint">while ( reader.ready()
  System.out.println( reader.read() );</pre></div>
</td>
</tr>
<tr>
<td class="tabellentext">
<p class="BStandard">Und die zweite:</p>
<div class="listing"><pre class="prettyprint">for ( int c; (c = reader.read()) != &#8211;1;
  System.out.println( (char) c );</pre></div>
<p class="BStandard">Die erste Lösung wirkt aufgeräumter.</p>
</td>
</tr>
</table><br><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">abstract class java.io.<span class="cfett">Reader</span>
implements Readable, Closeable</pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">public boolean ready() throws IOException</span>
Liefert <span class="clisting">true</span>, wenn aus dem Stream direkt gelesen werden kann. Das heißt allerdings nicht, dass <span class="clisting">false</span> immer Blocken bedeutet.</li>
</ul><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span><span class="clisting">InputStream</span> und <span class="clisting">Reader</span> sind sich zwar sehr ähnlich, aber ein <span class="clisting">InputStream</span> deklariert keine Methode <span class="clisting">ready()</span>. Dafür gibt es in <span class="clisting">InputStream</span> eine Methode <span class="clisting">available()</span>, die sagt, wie viele Bytes ohne Blockierung gelesen werden können, die es wiederum im <span class="clisting">Reader</span> nicht gibt.</p>
</td>
</tr>
</table><br><h4 class="t4">Sprünge und Markierungen</h4>
<p>Mit der Methode <span class="clisting">mark()</span> lässt sich eine bestimmte Position innerhalb des Eingabestroms markieren. Die Methode sichert dabei die Position. Mit beliebigen <span class="clisting">reset()</span>-Aufrufen lässt sich diese konkrete Stelle zu einem späteren Zeitpunkt wieder anspringen. <span class="clisting">mark()</span> besitzt einen Ganzzahl-Parameter, der angibt, wie viele Zeichen gelesen werden dürfen, bevor die Markierung nicht mehr gültig ist. Die Zahl ist wichtig, da sie die interne Größe des Puffers bezeichnet, der für den Strom angelegt werden muss. Nicht jeder Datenstrom unterstützt dieses Hin- und Herspringen. Die Klasse <span class="clisting">StringReader</span> unterstützt etwa die Markierung einer Position, die Klasse <span class="clisting">FileReader</span> dagegen nicht. Daher sollte vorher mit <span class="clisting">markSupported()</span> überprüft werden, ob das Markieren auch unterstützt wird. Wenn der Datenstrom es nicht unterstützt und wir diese Warnung ignorieren, werden wir eine <span class="clisting">IOException</span> bekommen. Denn <span class="clisting">Reader</span> implementiert <span class="clisting">mark()</span> und <span class="clisting">reset()</span> ganz einfach und muss von uns im Bedarfsfall überschrieben werden:</p>
<div class="listing"><pre class="prettyprint">public void mark( int readAheadLimit ) throws IOException {
  throw new IOException("mark() not supported");
}
public void reset() throws IOException {
  throw new IOException("reset() not supported");
}</pre></div>
<p>Daher gibt <span class="clisting">markSupported()</span> auch in der <span class="clisting">Reader</span>-Klasse <span class="clisting">false</span> zurück.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">abstract class java.io.<span class="cfett">Reader</span>
implements Readable, Closeable</pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">long skip( long n ) throws IOException</span>
Überspringt <span class="clisting">n</span> Zeichen. Blockt, bis Zeichen vorhanden sind. Gibt die Anzahl der wirklich übersprungenen Zeichen zurück.</li>
</ul>
<ul class="gp">
<li><span class="clisting">boolean markSupported()</span>
Der Stream unterstützt die <span class="clisting">mark()</span>-Operation.</li>
</ul>
<ul class="gp">
<li><span class="clisting">void mark( int readAheadLimit ) throws IOException</span>
Markiert eine Position im Stream. Der Parameter bestimmt, nach wie vielen Zeichen die Markierung ungültig wird, mit anderen Worten: Er gibt die Puffergröße an.</li>
</ul>
<ul class="gp">
<li><span class="clisting">void reset() throws IOException</span>
Falls eine Markierung existiert, setzt der Stream an der Markierung an. Wurde die Position vorher nicht gesetzt, dann wird eine <span class="clisting">IOException</span> mit dem String »Stream not marked« ausgelöst.</li>
</ul>
<p><span class="clisting">Reader</span> implementiert die schon bekannte Schnittstelle <span class="clisting">Closeable</span> mit der Methode <span class="clisting">close()</span>. Und so, wie ein <span class="clisting">Writer</span> die Schnittstelle <span class="clisting">Appendable</span> implementiert, so implementiert ein <span class="clisting">Reader</span> die Schnittstelle <span class="clisting">Readable</span> und damit die Operation <span class="clisting">int read(CharBuffer target) throws IOException</span>.</p><br><hr><a name="kommentar"></a><h3>Ihr Kommentar</h3>
                       Wie hat Ihnen das &lt;openbook&gt; gefallen? Wir freuen uns immer über Ihre freundlichen und kritischen Rückmeldungen.
                       <form action="http://www.galileo-press.de/feedback/openbook" method="post" style="text-align: center; margin-top: 10px;"><input type="hidden" name="openbookurl" value="javainsel9/.htm"><input type="hidden" name="buchtitel" value="Java ist auch eine Insel"><input type="hidden" name="Kapitel" value="17.2 Basisklassen für die Ein-/Ausgabe"><table border="0">
<tr>
<td><label for="name">Name</label><br></td>
<td><input type="text" name="name" id="name" size="40"><br></td>
</tr>
<tr>
<td><label for="email">E-Mail</label><br></td>
<td><input type="text" name="email" id="email" size="40"><br></td>
</tr>
<tr>
<td valign="top"><label for="comment">Ihr Kommentar</label><br></td>
<td><textarea name="comment" id="comment" rows="10" cols="40"></textarea><br></td>
</tr>
<tr>
<td>
</td>
<td><input type="submit" value="Kommentar absenden"></td>
</tr>
</table>
</form>
</div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="javainsel_17_001.htm" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a class="navnav" href="#">&lt;top&gt;</a></div></td>
<td align="right" width="25%"><div align="right"><a href="javainsel_17_003.htm" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
</table>
</div></td>
<td width="10" valign="top">  </td>
<td width="160" valign="top">
<table border="0" cellpadding="0" cellspacing="0" width="160">
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2">
&nbsp;<a href="http://www.galileocomputing.de/katalog/buecher/?GPP=opjiVIV" class="autor">
<strong>Zum Katalog</strong></a>

</td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2">
<img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV">
<img src="common/9783836215060_s.gif" width="119" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Java ist auch eine Insel" title="Zum Katalog: Java ist auch eine Insel">
<br><br><br><br><br><br><strong>Java ist auch eine Insel</strong><br><img src="common/pfeil_rechts5.gif" border="0" alt="">Jetzt bestellen</a><br /><br />
</td>
</tr>
</table>
</td>

</tr>
</table>
</td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2"><span class="autor"><strong>&nbsp;Ihre Meinung?</strong></a></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">

<table cellspacing="3">
<tr>
<td>Wie hat Ihnen das &lt;openbook&gt; gefallen?<br><a href="#kommentar"><img src="common/pfeil_rechts5.gif" border="0" alt="">Ihre Meinung</a>
<br><br></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>

<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>
<tr>
<td>
</td>
</tr>

<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2">&nbsp;<a href="http://www.galileocomputing.de/katalog/buecher/?GPP=opjiVIV" class="autor"><strong>Buchempfehlungen</strong></a></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2285?GPP=opjiVIV">
<img src="common/9783836215275_s.gif" width="102" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Computergeschichte(n) – nicht nur für Geeks" title="Zum Katalog: Computergeschichte(n) – nicht nur für Geeks"><br><br><br><br><br><br>&nbsp;Computergeschichte(n)<br>&nbsp;nicht nur für Geeks</a><br><br></td>
</tr>

<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/1949?GPP=opjiVIV">
<img src="common/9783836213080_s.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Java und XML" title="Zum Katalog: Java und XML"><br><br><br><br><br><br><br>&nbsp;Java und XML</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2346?GPP=opjiVIV">
<img src="common/9783836215688_s.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Einstieg in Java" title="Zum Katalog: Einstieg in Java"><br><br><br><br><br><br><br>&nbsp;Einstieg<br>&nbsp;in Java</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2051?GPP=opjiVIV">

<img src="common/9783836213677_s.gif" width="112" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Einstieg in XML" title="Zum Katalog: Einstieg in XML"><br><br><br><br><br><br><br>&nbsp;Einstieg<br>&nbsp;in XML</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2322?GPP=opjiVIV">
<img src="common/9783836215527_s.gif" width="112" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Visual C# 2010" title="Zum Katalog: Visual C# 2010"><br><br><br><br><br><br><br>&nbsp;Visual C# 2010</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2212?GPP=opjiVIV">
<img src="common/9783836214742_s.gif" width="119" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Professionell entwickeln mit Visual C# 2010" title="Zum Katalog: Professionell entwickeln mit Visual C# 2010"><br><br><br><br><br><br><br>&nbsp;Professionell<br>&nbsp;entwickeln mit<br>&nbsp;Visual C# 2010</a><br><br></td>
</tr>

<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2156?GPP=opjiVIV">
<img src="common/9783836214292_s.gif" width="108" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C++ von A bis Z" title="Zum Katalog: C++ von A bis Z"><br><br><br><br><br><br><br>&nbsp;C++ von A bis Z</a><br><br></td>
</tr>
</table></td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>

<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2"><span class="autor"><strong>&nbsp;Shopping</strong></span></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><b>Versandkostenfrei</b> bestellen in Deutschland und &Ouml;sterreich<br><a href="http://www.galileocomputing.de/hilfe/Shop/?GPP=opjiVIV"><img src="common/pfeil_rechts5.gif" border="0" alt="Info">Info</a><br><br></td>

</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table><br><br><hr width="70%" align="center">
<div align="center">
<p class="standard"><strong>Copyright © Galileo Press 2011</strong><br>
        Für Ihren privaten Gebrauch dürfen Sie die Online-Version natürlich ausdrucken.
        Ansonsten unterliegt das &lt;openbook&gt; denselben Bestimmungen, wie die
        gebundene Ausgabe: Das Werk einschließlich aller seiner Teile ist urheberrechtlich
        geschützt. Alle Rechte vorbehalten einschließlich der Vervielfältigung, Übersetzung,
        Mikroverfilmung sowie Einspeicherung und Verarbeitung in elektronischen Systemen.</p><br><a href="http://www.galileocomputing.de/">[Galileo Computing]</a><br><br>
      Galileo Press, Rheinwerkallee 4, 53227 Bonn, Tel.: 0228.42150.0, Fax 0228.42150.77, <a href="mailto:info@galileo-press.de">info@galileo-press.de</a></div><br><br></body>
</html>
