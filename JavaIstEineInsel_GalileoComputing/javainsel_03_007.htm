<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Galileo Computing :: Java ist auch eine Insel – 3.7 Arrays</title>
<meta name="title" content="Galileo Computing :: Java ist auch eine Insel - 3.7 Arrays">
<meta name="author" content="Christian Ullenboom ">
<meta name="publisher" content="Galileo Press 2011">
<meta name="copyright" content="Galileo Press 2011">
<meta name="Description" content="Java ist auch eine Insel - Das umfassende Handbuch – 3.7 Arrays">
<meta name="audience" content="Alle">
<meta name="robots" content="INDEX,FOLLOW">
<meta http-equiv="content-language" content="de">
<link rel="stylesheet" type="text/css" href="common/galileo_open.css">
<link rel="prev" href=".htm">
<link rel="next" href=".htm"><script type="text/javascript"><!--
    function OpenWin(url,name,height,width)
    {
      var InfoWin = window.open(url,name,"directories=0,height="+height+",width=" + width + ",hotkeys=0,location=0,menubar=0,resizable=1,screenX=150,screenY=10,left=150,top=10,scrollbars=1,status=1,titlebar=0,toolbar=0");
      InfoWin.focus();
    }
    //--></script><link href="common/prettify.css" type="text/css" rel="stylesheet"><script type="text/javascript" src="common/prettify.js"></script></head>
<body vlink="#000099" link="#000099" alink="#000099" onload="prettyPrint()">
<table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#000066">
<tr>
<td height="74" valign="bottom" colspan="2"><a href="http://www.galileocomputing.de/katalog/openbook?GPP=opjiVIV"><img src="common/galileocomputing_openbook.gif" width="200" height="56" border="0" alt="Galileo Computing < openbook >" title="Galileo Computing < openbook >"></a></td>
<td width="80" height="74"><a href="http://www.galileocomputing.de/?GPP=opjiVIV"><img src="common/galileocomputing.gif" border="0" alt="Galileo Computing - Professionelle Bücher. Auch für Einsteiger." title="Galileo Computing - Professionelle Bücher. Auch für Einsteiger."></a></td>
</tr>
</table>
<div align="right"><a href="http://www.galileocomputing.de/?GPP=opjiVIV" class="navnav">Professionelle Bücher. Auch für Einsteiger.</a></div><br><table class="tbl" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="190" valign="top">
<table class="tbl1" border="0" cellpadding="3" cellspacing="0" width="190" align="left">
<tr>
<td class="tbl2"><a class="nav" href="index.htm#_top">Inhaltsverzeichnis</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_00_001.htm#mj58b119301920569a446c9c510503f310">Vorwort</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_01_001.htm#mja8fc5b7ad19fc7332bc66b09a8fda26e">1 Java ist auch eine Sprache</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_02_001.htm#mj313f67c98dc9ecaddfa2d8b80f057fd2">2 Sprachbeschreibung</a></td>
</tr>
<tr>
<td><a class="navh" href="##mjcd3b5720e8605484942e3476a1075bdf">3 Klassen und Objekte</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_04_001.htm#mj71fbc84ad33a281b9352b0b19fae2fb2">4 Der Umgang mit Zeichenketten</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_05_001.htm#mj005cd8e604aefc3ae72b92880fcee5c6">5 Eigene Klassen schreiben</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_06_001.htm#mj6f6b47453043c38837bfc32154a97968">6 Exceptions</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_07_001.htm#mjc4a1f6f3499a02fb64fe89046739edca">7 Generics&lt;T&gt;</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_08_001.htm#mj46e914488628367f5dfc0a62c3a78a53">8 Äußere.innere Klassen</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_09_001.htm#mj94af2b90e8a2dad6c1ef67255f89a137">9 Besondere Klassen der Java SE</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_10_001.htm#mjcae20f50ffbc015d0b66861e7087af9b">10 Architektur, Design und angewandte Objektorientierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_11_001.htm#mj60bc6a007ae9b8657949f3e91d96df3d">11 Die Klassenbibliothek</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_12_001.htm#mj0ce00eb41aae2b084534019cf6edc3b6">12 Bits und Bytes und Mathematisches</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_13_001.htm#mj245f5f8d5a858b46462d64e9b9c0786b">13 Datenstrukturen und Algorithmen</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_14_001.htm#mj8c6f381221d805dd6fbe480731ac0c58">14 Threads und nebenläufige Programmierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_15_001.htm#mjbe3ed0989722396930966f95deeb2497">15 Raum und Zeit</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_16_001.htm#mj78bd405fb0de0cff099c06255fe36853">16 Dateien, Verzeichnisse und Dateizugriffe</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_17_001.htm#mjb420b02f4ccf65226f7271e48cefa05d">17 Datenströme</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_18_001.htm#mjedab16f1a9cc168eda4a24416359e0b9">18 Die eXtensible Markup Language (XML)</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_19_001.htm#mjc8f47f7f51ac3795c46c4544f391b02e">19 Grafische Oberflächen mit Swing</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_20_001.htm#mj25cc7d47e476b8b1a183a10ee741dbaa">20 Grafikprogrammierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_21_001.htm#mjea7bcdd596c8bd25b078a00221a01a75">21 Netzwerkprogrammierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_22_001.htm#mjde622db61608a627262a27ecb377d675">22 Verteilte Programmierung mit RMI</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_23_001.htm#mj23bf599d65364bcd05d06a34cb5593bf">23 JavaServer Pages und Servlets</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_24_001.htm#mja621f3b4a74c7fa576b4a58b1614041e">24 Datenbankmanagement mit JDBC</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_25_001.htm#mja2e217bf5724cc65eba184a2af8b79cf">25 Reflection und Annotationen</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_26_001.htm#mjb47dd6e0a309b7e78cad68f6b5de9319">26 Dienstprogramme für die Java-Umgebung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_27_001.htm#mjf59db36d9280a70e0d3d196e9bf160f5">A Die Begleit-DVD</a></td>
</tr>
<tr>
<td><a class="navnav" href="stichwort.htm#_top">Stichwort</a></td>
</tr>
<tr>
<td><br><a href="http://download2.galileo-press.de/openbook/galileocomputing_javainsel9.zip" class="navnav"><strong>Download:</strong><br>- ZIP, ca. 20,5 MB</a></td>
</tr>
<tr>
<td><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV" class="navnav">Buch bestellen</a></td>
</tr>
<tr>
<td><a class="navnav" href="#kommentar">Ihre Meinung?</a><br><br></td>
</tr>
</table>
</td>
<td width="10"><img src="common/spacer10.gif" width="10" height="10" alt="Spacer"></td>
<td width="85%" valign="top" align="center"><div align="center">
<table width="98%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="javainsel_03_006.htm" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a href="http://www.galileocomputing.de/?GPP=opjiVIV" class="navnav">Galileo Computing /</a><a href="http://www.galileocomputing.de/katalog/openbook/?GPP=opjiVIV" class="navnav"> &lt;openbook&gt; /</a><a href="index.htm" class="navnav"> Java-Insel</a></div></td>
<td align="right" width="25%"><div align="right"><a href="javainsel_03_008.htm" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" valign="top"><table width="100%" border="0" cellpadding="10" cellspacing="0" class="box">
<tr>
<td colspan="2"><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV" class="buchtitel">Java ist auch eine Insel</a><span class="autor"> von Christian Ullenboom </span><br><span class="untertitel">Das umfassende Handbuch</span></td>
</tr>
<tr>
<td valign="top" width="211"><dl>
<dt><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV" class="navnav"><img src="common/9783836215060.gif" border="0" alt="Buch: Java ist auch eine Insel" title="Buch: Java ist auch eine Insel"></a></dt>
<dd><br><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV"><span class="autor"><strong>Java ist auch eine Insel</strong><br>geb., mit DVD<br>1482 S., 49,90 Euro<br>Galileo Computing<br>ISBN 978-3-8362-1506-0</span></a></dd>
</dl></td>
<td width="80%"><table border="0">
<tr>
<td valign="baseline"><img src="common/pfeil_u.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="3" class="kap"><strong><a href="javainsel_03_001.htm#mjcd3b5720e8605484942e3476a1075bdf" class="navnav">3 Klassen und Objekte</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_03_001.htm#mj14adccb998e49849e4cf60fea8a67179" class="navnav">3.1 Objektorientierte Programmierung (OOP)</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_001.htm#mjb0eec540c2ccdc740aab19214a1f693f" class="navnav">3.1.1 Warum überhaupt OOP?</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_001.htm#mj69adbf2f11e355d1e7d031e8ad309320" class="navnav">3.1.2 Denk ich an Java, denk ich an Wiederverwendbarkeit</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_03_002.htm#mj5b619d9f15dfdb8c74f6dd581e8ae52e" class="navnav">3.2 Eigenschaften einer Klasse</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_002.htm#mj6d290cc6103e146af08763c9458a4f6e" class="navnav">3.2.1 Die Klasse Point</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_03_003.htm#mj120069350af17581cd54657a662eac08" class="navnav">3.3 Die UML (Unified Modeling Language) *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_003.htm#mj4a927ff99dbea7d0e3cc439fffbcbad4" class="navnav">3.3.1 Hintergrund und Geschichte zur UML</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_003.htm#mjfc37567f1830529a886ff45e660849f1" class="navnav">3.3.2 Wichtige Diagrammtypen der UML</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_003.htm#mj2cb798ef9fd7e336d385ba789fb4c16f" class="navnav">3.3.3 UML-Werkzeuge</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_03_004.htm#mj188cb023a2e250d061fbf7c4d5c358e2" class="navnav">3.4 Neue Objekte erzeugen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_004.htm#mjfb7e8fdd741bd1a69915f536838150a6" class="navnav">3.4.1 Ein Exemplar einer Klasse mit dem new-Operator anlegen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_004.htm#mjc322bfcdc7b9d9ca13c2f7fea535fac3" class="navnav">3.4.2 Garbage-Collector (GC) &#8211; Es ist dann mal weg</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_004.htm#mj8e78f63eedef225017005b13f5547df6" class="navnav">3.4.3 Deklarieren von Referenzvariablen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_004.htm#mj0b5cf146c1b62f723db236bd7ebc5245" class="navnav">3.4.4 Zugriff auf Variablen und Methoden mit dem ».«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_004.htm#mja82dea77b8e3be5715de3f263f3f1798" class="navnav">3.4.5 Konstruktoren nutzen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_03_005.htm#mjaf1a068d749bd6f94d968e3de46e70dc" class="navnav">3.5 Mit Referenzen arbeiten, Identität und Gleichheit</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_005.htm#mj21b86db09c28ddf9b92b692620c00cdb" class="navnav">3.5.1 Die null-Referenz</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_005.htm#mj5b75348c12a8a76224c3a28c7148b211" class="navnav">3.5.2 null-Referenzen testen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_005.htm#mj095218f6687d829b7b8cbf2f5dca4bf5" class="navnav">3.5.3 Zuweisungen bei Referenzen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_005.htm#mj6fe8d2344da520f9a0e1f3d482613f14" class="navnav">3.5.4 Methoden mit nicht-primitiven Parametern</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_005.htm#mj5ce8c0d2c9d1e78654a284dc9d91dacd" class="navnav">3.5.5 Identität von Objekten</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_005.htm#mj4e22a27f86fe89bff20e4581e87c5c65" class="navnav">3.5.6 Gleichheit und die Methode »equals()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_03_006.htm#mjcb5ba14934515b667f05cac0be6da85b" class="navnav">3.6 Kompilationseinheiten, Imports und Pakete schnüren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_006.htm#mj5d25bb73620d12f4c40fc1e7ff537fad" class="navnav">3.6.1 Volle Qualifizierung und import-Deklaration</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_006.htm#mjf76adfcb77237accb6dd9a07caca8ed8" class="navnav">3.6.2 Mit import p1.p2.* alle Typen eines Pakets erreichen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_006.htm#mj1e65252e2f478166362e30ea3f74c456" class="navnav">3.6.3 Hierarchische Strukturen über Pakete</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_006.htm#mj69f88a3bc5adac9bede26abe6fa3c166" class="navnav">3.6.4 Die package-Deklaration</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_006.htm#mj36d2326bddd0f478fa0882b5a27d6230" class="navnav">3.6.5 Unbenanntes Paket (default package)</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_006.htm#mj929793f794e65ac195413a8ba075bac3" class="navnav">3.6.6 Klassen mit gleichen Namen in unterschiedlichen Paketen *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_006.htm#mj2fa9205c29a0f239d6e8fcb591e3be3e" class="navnav">3.6.7 Compilationseinheit (Compilation Unit)</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_006.htm#mj6dc709bf9e6ebef1937ea0c49e6585a2" class="navnav">3.6.8 Statischer Import</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_006.htm#mj3931543d527206ffd3e586ef443e087b" class="navnav">3.6.9 Eine Verzeichnisstruktur für eigene Projekte *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="#mj11a4689950bdbe50e0c6342eb22737a6" class="navh">3.7 Arrays</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj23a745f6df230125f0760b9755f8996e" class="navh">3.7.1 Deklaration von Arrays</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjc64e20fbebf1d1caf31860939b5d54eb" class="navh">3.7.2 Arrays mit Inhalt</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj1f442b91fd4893d74e1fff78ea7a8b76" class="navh">3.7.3 Die Länge eines Arrays über das Attribut length auslesen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjd5d447739968e0cd80112c7eb6cbbb3e" class="navh">3.7.4 Zugriff auf die Elemente über den Index</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj5cde73b74f5421b00c5119616a69ac0b" class="navh">3.7.5 Array-Objekte mit new erzeugen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj7d78b8e145bd133cc355b5ccd3e276b9" class="navh">3.7.6 Fehler bei Arrays</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mja25a7f5d459dfc1dc052d23b42c40371" class="navh">3.7.7 Die erweiterte for-Schleife</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj96f432d89b981f10f8c3be24373779ec" class="navh">3.7.8 Arrays mit nicht-primitiven Elementen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj2627223aa77094452c665b55e7640b8b" class="navh">3.7.9 Mehrdimensionale Arrays *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj7100c45624457324338529ef85e21324" class="navh">3.7.10 Vorinitialisierte Arrays *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj83719cf25a616582d6a0ae43dc356cc6" class="navh">3.7.11 Mehrere Rückgabewerte *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj7da5fd18833c690818519a0c82e8be6e" class="navh">3.7.12 Methode mit variabler Argumentanzahl (Vararg)</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjd0a6c6bf70eb16174a7c44411d2afbf4" class="navh">3.7.13 Klonen kann sich lohnen &#8211; Arrays vermehren *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mja91938f74923b4f8ab51724e9530e8cb" class="navh">3.7.14 Feldinhalte kopieren *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj84d959216ad1aa6d5c9ccf5c270e4545" class="navh">3.7.15 Die Klasse Arrays zum Vergleichen, Füllen und Suchen nutzen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_03_008.htm#mj7795b13ad8d0d5a6aef1cfcc54ae1245" class="navnav">3.8 Der Einstiegspunkt für das Laufzeitsystem: »main()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_008.htm#mj1f3849b282fa092f3e15359abec6f7ed" class="navnav">3.8.1 Kommandozeilenargumente verarbeiten</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_008.htm#mj9236ac97667f672f1ca5bc79ac371e3f" class="navnav">3.8.2 Der Rückgabewert von »main()« und »System.exit()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_03_009.htm#mj670406e2fdaac338f8527952d3305745" class="navnav">3.9 Annotationen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_03_009.htm#mj118f79ae762b7f700a379a4588737dd0" class="navnav">3.9.1 Annotationstypen @Override, @Deprecated, @SuppressWarnings</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_03_010.htm#mj4c916b181f9b9d4767c8acb844fe8bf8" class="navnav">3.10 Zum Weiterlesen</a></strong></td>
</tr>
</table><br></td>
</tr>
</table>
<table width="100%" cellpadding="20" cellspacing="0" border="0" bgcolor="#eeeeee">
<tr>
<td><div class="main"><a id="mj11a4689950bdbe50e0c6342eb22737a6" name="mj11a4689950bdbe50e0c6342eb22737a6"></a><a name="t21"></a><a name="t2t31"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div>
<h2 class="t2"><span class="cfett">3.7</span> Arrays  <a href="#t2t32"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><img src="common/15x15leer.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></h2>
<p>Ein <span class="ckursiv">Array</span> (auch <span class="ckursiv">Feld</span> oder <span class="ckursiv">Reihung</span> genannt) ist ein spezieller Datentyp, der mehrere Werte zu einer Einheit zusammenfasst. Er ist mit einem Setzkasten vergleichbar, in dem die Plätze durchnummeriert sind. Angesprochen werden die Elemente über einen ganzzahligen Index. Jeder Platz (etwa für Schlümpfe) nimmt immer Werte des gleichen Typs auf (nur Schlümpfe und keine Pokémons). Normalerweise liegen die Plätze eines Arrays (seine Elemente) im Speicher hintereinander, doch ist dies ein für Programmierer nicht sichtbares Implementierungsdetail der virtuellen Maschine.</p>
<p>Jedes Array beinhaltet Werte nur eines bestimmten Datentyps bzw. Grundtyps. Dies können sein:</p>
<ul class="gp">
<li>elementare Datentypen wie <span class="clisting">int</span>, <span class="clisting">byte</span>, <span class="clisting">long</span> und so weiter</li>
</ul>
<ul class="gp">
<li>Referenztypen</li>
</ul>
<ul class="gp">
<li>Referenztypen anderer Arrays, um mehrdimensionale Arrays zu realisieren</li>
</ul><a id="mj23a745f6df230125f0760b9755f8996e" name="mj23a745f6df230125f0760b9755f8996e"></a><a name="t31"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t32"></a><h3 class="t3"><span class="cfett">3.7.1</span> Deklaration von Arrays  <a href="#t2t33"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t31"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Eine Array-Variablendeklaration ähnelt einer gewöhnlichen Deklaration, nur dass nach dem Datentyp die Zeichen »<span class="clisting">[</span>« und »<span class="clisting">]</span>« gesetzt werden:</p>
<div class="listing"><pre class="prettyprint">int<span class="cfett">[]</span>   primes;
Point<span class="cfett">[]</span> points;</pre></div>
<p>Eine Variable wie <span class="clisting">primes</span> hat jetzt den Typ »ist Feld« und »speichert <span class="clisting">int</span>-Elemente«, also eigentlich zwei Typen.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Die eckigen Klammern lassen sich bei der Deklaration einer Array-Variablen auch hinter den Namen setzen, doch ganz ohne Unterschied ist die Deklaration nicht. Das zeigt sich spätestens dann, wenn mehr als eine Variable deklariert wird:</p>
<div class="listing"><pre class="prettyprint">int []primes,
    matrix[], threeDimMatrix[][];</pre></div>
<p class="BStandard">entspricht der Deklaration</p>
<div class="listing"><pre class="prettyprint">int primes[], matrix[]<span class="cfett">[]</span>, threeDimMatrix[][]<span class="cfett">[]</span>;</pre></div>
<p class="BStandard">Damit Irrtümer dieser Art ausgeschlossen werden, sollten Sie in jeder Zeile nur eine Deklaration eines Typs schreiben. Nach reiner Java-Lehre gehören die Klammern jedenfalls hinter den Typbezeichner, so hat es Java-Schöpfer James Gosling gewollt.</p>
</td>
</tr>
</table><br><a id="mjc64e20fbebf1d1caf31860939b5d54eb" name="mjc64e20fbebf1d1caf31860939b5d54eb"></a><a name="t32"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t33"></a><h3 class="t3"><span class="cfett">3.7.2</span> Arrays mit Inhalt  <a href="#t2t34"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t32"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Die bisherigen Deklarationen von Array-Variablen erzeugen noch lange kein Array-Objekt, das die einzelnen Array-Elemente aufnehmen kann. Wenn allerdings die Einträge direkt mit Werten belegt werden sollen, gibt es in Java eine Abkürzung, die ein Array-Objekt anlegt und zugleich mit Werten belegt.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Wertebelegung eines Felds:</p>
<div class="listing"><pre class="prettyprint">int[] primes = { 2, 3, 5, 7, 7 + 4, };
String[] nouns = {
  "Haus", "Maus",
  "dog".toUpperCase(),    // DOG
  new java.awt.Point().toString()
};</pre></div>
</td>
</tr>
</table><br><p>In diesem Fall wird ein Feld mit passender Größe angelegt, und die Elemente, die in der Aufzählung genannt sind, werden in das Feld kopiert. Innerhalb der Aufzählung kann abschließend ein Komma stehen, wie die Aufzählung bei <span class="clisting">primes</span> demonstriert.</p><a id="mj1f442b91fd4893d74e1fff78ea7a8b76" name="mj1f442b91fd4893d74e1fff78ea7a8b76"></a><a name="t33"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t34"></a><h3 class="t3"><span class="cfett">3.7.3</span> Die Länge eines Arrays über das Attribut length auslesen  <a href="#t2t35"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t33"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Die Anzahl der Elemente, die ein Array aufnehmen kann, wird <span class="ckursiv">Größe</span> beziehungsweise <span class="ckursiv">Länge</span> genannt und ist für jedes Array-Objekt in der frei zugänglichen Objektvariablen <span class="clisting">length</span> gespeichert. <span class="clisting">length</span> ist eine <span class="clisting">public final int</span>-Variable, deren Wert entweder positiv oder null ist. Die Größe lässt sich später nicht mehr ändern.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Ein Feld und Ausgabe der Länge:</p>
<div class="listing"><pre class="prettyprint">int[] primes = { 2, 3, 5, 7, 7 + 4, };
System.out.println( <span class="cfett">primes.length</span> );          // 5</pre></div>
</td>
</tr>
</table><br><h4 class="t4">Feldlängen sind final</h4>
<p>Das Attribut <span class="clisting">length</span> eines Felds ist nicht nur öffentlich (<span class="clisting">public</span>) und vom Typ <span class="clisting">int</span>, sondern natürlich auch <span class="clisting">final</span>. Schreibzugriffe sind nicht gestattet. (Was sollten sie bewirken? Eine dynamische Vergrößerung des Felds?) Ein Schreibzugriff führt zu einem Übersetzungsfehler.</p><a id="mjd5d447739968e0cd80112c7eb6cbbb3e" name="mjd5d447739968e0cd80112c7eb6cbbb3e"></a><a name="t34"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t35"></a><h3 class="t3"><span class="cfett">3.7.4</span> Zugriff auf die Elemente über den Index  <a href="#t2t36"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t34"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Der Zugriff auf die Elemente eines Felds erfolgt mithilfe der eckigen Klammern <span class="clisting">[]</span>, die hinter die Referenz an das Array-Objekt gesetzt werden. In Java beginnt ein Array beim Index 0 (und nicht bei einer frei wählbaren Untergrenze wie in PASCAL). Da die Elemente eines Arrays ab 0 nummeriert werden, ist der letzte gültige Index um 1 kleiner als die Länge des Felds. Bei einem Array <span class="clisting">a</span> der Länge <span class="clisting">n</span> ist der gültige Bereich somit <span class="clisting">a[0]</span> bis <span class="clisting">a[n</span> &#8211; <span class="clisting">1]</span>.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Greife auf das erste und letzte Zeichen aus dem Feld zu:</p>
<div class="listing"><pre class="prettyprint">char[] name  = { 'C', 'h', 'r', 'i', 's' };
char   first = name[ 0 ];                       // C
char   last  = name[ name.length &#8211; 1 ];         // s</pre></div>
</td>
</tr>
</table><br><p>Da der Zugriff auf die Variablen über einen Index erfolgt, werden diese Variablen auch <span class="ckursiv">indexierte Variablen</span> genannt.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Laufe das Feld der ersten Primzahlen komplett ab:</p>
<div class="listing"><pre class="prettyprint">int[] primes = { 2, 3, 5, 7, 7 + 4, };
for ( int i = 0; i &lt; primes.length; i++ )   // Index: 0 &lt;= i &lt; 5 = primes.length
  System.out.println( primes[ i ] );</pre></div>
</td>
</tr>
</table><br><h4 class="t4">Über den Typ des Index *</h4>
<p>Innerhalb der eckigen Klammern steht ein positiver Ganzzahl-Ausdruck vom Typ <span class="clisting">int</span>, der sich zur Laufzeit berechnen lassen muss. <span class="clisting">long</span>-Werte, <span class="clisting">boolean</span>, Gleitkommazahlen oder Referenzen sind nicht möglich; durch <span class="clisting">int</span> verbleiben aber mehr als zwei Milliarden Elemente. Bei Gleitkommazahlen bliebe die Frage nach der Zugriffstechnik. Hier müssten wir den Wert auf ein Intervall herunterrechnen.</p>
<h4 class="t4">Strings sind keine Arrays *</h4>
<p>Ein Array von <span class="clisting">char</span>-Zeichen hat einen ganz anderen Typ als ein <span class="clisting">String</span>-Objekt. Während bei Feldern eckige Klammern erlaubt sind, bietet die <span class="clisting">String-</span>Klasse (bisher) kein Zugriff auf Zeichen über <span class="clisting">[]</span>. Die Klasse <span class="clisting">String</span> bietet jedoch einen Konstruktor an, sodass aus einem Feld mit Zeichen ein <span class="clisting">String</span>-Objekt erzeugt werden kann. Alle Zeichen des Felds werden kopiert, sodass anschließend Feld und String keine Verbindung mehr besitzen. Dies bedeutet: Wenn sich das Feld ändert, ändert sich der String nicht automatisch mit. Das kann er auch nicht, da Strings unveränderlich sind.</p><a id="mj5cde73b74f5421b00c5119616a69ac0b" name="mj5cde73b74f5421b00c5119616a69ac0b"></a><a name="t35"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t36"></a><h3 class="t3"><span class="cfett">3.7.5</span> Array-Objekte mit new erzeugen  <a href="#t2t37"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t35"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Ein Array muss mit dem <span class="clisting">new</span>-Operator unter Angabe einer festen Größe erzeugt werden. Das Anlegen der Variablen allein erzeugt noch kein Feld mit einer bestimmten Länge. In Java ist das Anlegen des Felds genauso dynamisch wie die Objekterzeugung. Dies drückt auch der <span class="clisting">new</span>-Operator aus. [Programmiersprachen wie C(++) bieten bei der Felderzeugung Abkürzungen wie <span class="clisting">int array[100]</span>. Das führt in Java zu einem Compilerfehler.
]  Die Länge des Felds wird in eckigen Klammern angegeben. Hier kann ein beliebiger Integer-Wert stehen, auch eine Variable. Selbst 0 ist möglich.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Erzeuge ein Feld für zehn Elemente:</p>
<div class="listing"><pre class="prettyprint">int[] values;
values = <span class="cfett">new int[ 10 ]</span>;</pre></div>
<p class="BStandard">Die Feld-Deklaration ist auch zusammen mit der Initialisierung möglich:</p>
<div class="listing"><pre class="prettyprint">double[] values = <span class="cfett">new double[ 10 ]</span>;</pre></div>
<p class="BStandard">Die Felder mit den primitiven Werten sind mit 0, 0.0 oder <span class="clisting">false</span> und bei Verweisen mit <span class="clisting">null</span> initialisiert.</p>
</td>
</tr>
</table><br><p>Dass Arrays Objekte sind, zeigen einige Indizien:</p>
<ul class="gp">
<li>Eine spezielle Form des <span class="clisting">new</span>-Operators erzeugt ein Exemplar der Array-Klasse; <span class="clisting">new</span> erinnert uns immer daran, dass ein Objekt zur Laufzeit aufgebaut wird.</li>
</ul>
<ul class="gp">
<li>Ein Array-Objekt kennt das Attribut <span class="clisting">length</span>, und auf dem Array-Objekt sind Methoden &#8211; wie <span class="clisting">clone()</span> und alles, was <span class="clisting">java.lang.Object</span> hat &#8211; definiert.</li>
</ul>
<ul class="gp">
<li>Die Operatoren <span class="clisting">==</span> und <span class="clisting">!=</span> haben ihre Objekt-Bedeutung: Sie vergleichen lediglich, ob zwei Variablen auf das gleiche Array-Objekt verweisen, aber auf keinen Fall die Inhalte der Arrays (das kann aber <span class="clisting">Arrays.equals()</span>).</li>
</ul>
<p>Der Zugriff auf die Array-Elemente über die eckigen Klammern <span class="clisting">[]</span> lässt sich als versteckter Aufruf über geheime Methoden wie <span class="clisting">array.get(index)</span> verstehen. Der <span class="clisting">[]</span>-Operator wird bei anderen Objekten nicht angeboten.</p>
<h4 class="t4">Der Index vom Typ »char« ist auch ein» int« *</h4>
<p>Der Index eines Felds muss von einem Typ sein, der ohne Verlust in <span class="clisting">int</span> konvertierbar ist. Dazu gehören <span class="clisting">byte</span>, <span class="clisting">short</span> und <span class="clisting">char</span>. Günstig ist ein Index vom Typ <span class="clisting">char</span>, zum Beispiel als Laufvariable, wenn Felder von Zeichenketten generiert werden:</p>
<div class="listing"><pre class="prettyprint">char[] alphabet = new char[ 'z' &#8211; 'a' + 1 ]; // 'a' entspricht 97 und 'z' 122
for ( char c = 'a'; c &lt;= 'z'; c++ )
  alphabet[ c &#8211; 'a' ] = c;            // alphabet[0]='a', alphabet[1]='b', usw.</pre></div>
<p>Genau genommen haben wir es auch hier mit Indexwerten vom Typ <span class="clisting">int</span> zu tun, weil mit den <span class="clisting">char</span>-Werten vorher noch gerechnet wird.</p><a id="mj7d78b8e145bd133cc355b5ccd3e276b9" name="mj7d78b8e145bd133cc355b5ccd3e276b9"></a><a name="t36"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t37"></a><h3 class="t3"><span class="cfett">3.7.6</span> Fehler bei Arrays  <a href="#t2t38"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t36"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Beim Zugriff auf ein Array-Element können Fehler auftreten. Zunächst einmal kann das Array-Objekt fehlen, sodass die Referenzierung fehlschlägt &#8211; etwa im folgenden Fall, bei dem der Compiler den Fehler nicht bemerkt: [Obwohl er sich bei nicht initialisierten lokalen Variablen auch beschwert.
] </p>
<div class="listing"><pre class="prettyprint">int[] array = null;
array[ 1 ] = 1;     // <img src="common/totenkopf.gif" border="0" align="bottom" alt="Fehler"> NullPointerException zur Laufzeit, nicht zur Compilierzeit</pre></div>
<p>Die Strafe ist eine <span class="clisting">NullPointerException</span>.</p>
<p>Weitere Fehler können im Index begründet sein. Dieser könnte negativ sein oder über der maximalen Länge liegen. Jeder Zugriff auf das Feld wird zur Laufzeit getestet. Auch bei Operationen, die für den Compiler entscheidbar wären, wird dieser Weg eingeschlagen, etwa bei den folgenden Zeilen:</p>
<div class="listing"><pre class="prettyprint">int[] array = new int[<span class="cfett"> 100</span> ];
array[<span class="cfett"> &#8211;10</span> ] = 1;          // <img src="common/totenkopf.gif" border="0" align="bottom" alt="Fehler"> Fehler zur Laufzeit, nicht zur Compilierzeit
array[<span class="cfett"> 100</span> ] = 1;          // <img src="common/totenkopf.gif" border="0" align="bottom" alt="Fehler"> Fehler zur Laufzeit, nicht zur Compilierzeit</pre></div>
<p>Hier könnte der Compiler theoretisch Alarm schlagen, was aber kaum ein Compiler bisher tut, denn der Zugriff auf Elemente mit einem ungültigen Index ist syntaktisch und statisch semantisch völlig in Ordnung.</p>
<p>Ist der Index negativ [Ganz anders verhalten sich da Python oder Perl. Dort wird ein negativer Index dazu verwendet, ein Feldelement relativ zum letzten Array-Eintrag anzusprechen. Und auch bei C ist ein negativer Index durchaus möglich und praktisch.
]  oder zu groß, dann hagelt es eine <span class="clisting">IndexOutOfBoundsException</span>. Wird diese nicht abgefangen, bricht das Laufzeitsystem das Programm mit einer Fehlermeldung ab. Dass die Feldgrenzen überprüft werden, ist Teil von Javas Sicherheit und lässt sich nicht abstellen. Es ist aber heute kein großes Performance-Problem mehr, da die Laufzeitumgebung nicht jeden Index prüfen muss, um sicherzustellen, dass ein Block mit Feldzugriff korrekt ist.</p>
<h4 class="t4">Spielerei: Index und das Inkrement *</h4>
<p>Wir haben beim Inkrement schon ein Phänomen wie <span class="clisting">i = i++</span> betrachtet. Ebenso ist auch die Anweisung bei einem Feldzugriff zu behandeln:</p>
<div class="listing"><pre class="prettyprint">array[<span class="cfett"> i</span> ] =<span class="cfett"> i++</span>;</pre></div>
<p>Bei der Position <span class="clisting">array[i]</span> wird <span class="clisting">i</span> gesichert und anschließend die Zuweisung vorgenommen. Wenn wir eine Schleife darum konstruieren, erweitern wir dies zu einer Initialisierung:</p>
<div class="listing"><pre class="prettyprint">int[] array = new int[ 4 ];
int i = 0;
while ( i &lt; array.length )
  array[ i ] = i++;</pre></div>
<p>Die Ausgabe ergibt 0, 1, 2 und 3. Von der Anwendung ist wegen mangelnder Übersicht abzuraten.</p><a id="mja25a7f5d459dfc1dc052d23b42c40371" name="mja25a7f5d459dfc1dc052d23b42c40371"></a><a name="t37"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t38"></a><h3 class="t3"><span class="cfett">3.7.7</span> Die erweiterte for-Schleife  <a href="#t2t39"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t37"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p><span class="clisting">for</span>-Schleifen laufen oft Felder oder Datenstrukturen ab. Nehmen wir als Beispiel einige Zeilen, die von einem Feld <span class="clisting">array</span> mit Fließkommazahlen den Mittelwert berechnen. (Das Feld muss mindestens ein Element besitzen, sonst gibt es bei der Division eine Ausnahme.)</p>
<div class="listing"><pre class="prettyprint">double sum = 0;
for ( int<span class="cfett"> i</span> = 0;<span class="cfett"> i</span> &lt; array.length;<span class="cfett"> i</span>++ )
  sum += array[<span class="cfett"> i</span> ];
double arg = sum / array.length;</pre></div>
<p>Die Schleifenvariable <span class="clisting">i</span> hat lediglich als Index ihre Berechtigung; nur damit lässt sich das Element an einer bestimmten Stelle im Feld ansprechen.</p>
<p>Weil das komplette Durchlaufen von Feldern häufig ist, wurde in Java 5 eine Abkürzung für solche Iterationen in die Sprache eingeführt:</p>
<div class="listing"><pre class="prettyprint">for (<span class="cfett"> Typ Bezeichner</span> :<span class="cfett"> Feld</span> )
  ...</pre></div>
<p>Die erweiterte Form der <span class="clisting">for</span>-Schleife löst sich vom Index und erfragt jedes Element des Felds. Das können Sie sich als Durchlauf einer Menge vorstellen, denn der Doppelpunkt liest sich als »in«. Rechts vom Doppelpunkt steht immer ein Feld oder, wie wir später sehen werden, etwas vom Typ <span class="clisting">Iterable</span>, wie eine Datenstruktur. Links wird eine lokale Variable deklariert, die später beim Ablauf jedes Element der Sammlung annehmen wird.</p>
<p>Die Berechnung des Durchschnitts lässt sich nun umschreiben. Die statische Methode <span class="clisting">avg()</span> soll den Mittelwert der Elemente eines Felds bestimmen. Eine Ausnahme zeigt an, ob der Feldverweis <span class="clisting">null</span> ist oder das Feld keine Elemente enthält:</p>
<p class="tabunter"><strong>Listing 3.7    </strong>Avg.java, avg()</p>
<div class="listing"><pre class="prettyprint">static double avg( double[] array )
{
  if ( array == null || array.length == 0 )
    throw new IllegalArgumentException( "Illegal array!" );
  double sum = 0;

 <span class="cfett"> for ( double n : array )</span>
    sum += n;

  return sum / array.length;
}</pre></div>
<p>Zu lesen ist die <span class="clisting">for</span>-Zeile demnach als »Für jedes Element <span class="clisting">n</span> vom Typ <span class="clisting">double</span> in <span class="clisting">array</span> tue ...«. Eine Variable für den Schleifenindex ist nicht mehr nötig.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Rechts vom Doppelpunkt lässt sich auf die Schnelle ein Feld aufbauen, über das das erweiterte <span class="clisting">for</span> dann laufen kann.</p>
<p class="tabunter"><strong>Listing 3.8    </strong>FirstPrimes.java, main()</p>
<div class="listing"><pre class="prettyprint">for ( int prime : new int[]{ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41} )
  System.out.println( prime );</pre></div>
</td>
</tr>
</table><br><h4 class="t4">Umsetzung und Einschränkung</h4>
<p>Intern setzt der Compiler diese erweiterte <span class="clisting">for</span>-Schleife ganz klassisch um, sodass der Bytecode unter beiden Varianten gleich ist. Nachteile der Variante sind jedoch:</p>
<ul class="gp">
<li>Das erweiterte <span class="clisting">for</span> läuft immer das ganze Feld ab. Anfang- und Ende-Index können nicht ausdrücklich gesetzt werden.</li>
</ul>
<ul class="gp">
<li>Die Ordnung ist immer von vorn nach hinten.</li>
</ul>
<ul class="gp">
<li>Der Index ist nicht sichtbar.</li>
</ul>
<ul class="gp">
<li>Die Schleife liefert ein Element, kann aber nicht in das Feld schreiben.</li>
</ul>
<p>Abbrechen lässt sich die Schleife mit einem <span class="clisting">break</span>. Bestehen andere Anforderungen, kann weiterhin nur eine klassische <span class="clisting">for</span>-Schleife helfen.</p><a id="mj96f432d89b981f10f8c3be24373779ec" name="mj96f432d89b981f10f8c3be24373779ec"></a><a name="t38"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t39"></a><h3 class="t3"><span class="cfett">3.7.8</span> Arrays mit nicht-primitiven Elementen  <a href="#t2t310"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t38"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Der Datentyp der Array-Elemente muss nicht zwingend ein primitiver sein. Auch ein Array von Objektreferenzen kann deklariert werden. Dieses Array besteht dann nur aus Referenzen auf die eigentlichen Objekte, die in dem Array abgelegt werden sollen. Die Größe des Arrays im Speicher errechnet sich demnach aus der Länge des Felds, multipliziert mit dem Speicherbedarf einer Referenz. Nur das Array-Objekt selbst wird angelegt, nicht aber die Objekte, die das Array aufnehmen soll. Dies lässt sich einfach damit begründen, dass der Compiler auch gar nicht wüsste, welchen Konstruktor er aufrufen sollte.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" rowspan="2">
<p class="BStandard"><span class="cfett">Beispiel   </span>Ein nicht-primitives Feld mit fünf Punkt-Objekten:</p>
<div class="listing"><pre class="prettyprint">Point[] points = new Point[ 5 ];</pre></div>
<p class="BStandard">Hier wird Platz für fünf Verweise auf Punkt-Objekte geschaffen, aber kein einziges <span class="clisting">Point</span>-Objekt angelegt. Standardmäßig werden die Array-Elemente mit der <span class="clisting">null</span>-Referenz initialisiert, sodass <span class="clisting">System.out.println(points[0])</span> die Ausgabe »null« auf den Bildschirm gibt. Später würde das Feld etwa mit <span class="clisting">points[0] = new Point()</span> gefüllt.</p>
</td>
</tr>
</table><br><p>Fünf Punkte sollen angelegt und mit willkürlichen Werten gefüllt werden. Die Zufallszahlen erzeugt die mathematische Methode <span class="clisting">Math.random()</span>. Da die statische Methode jedoch Fließkommazahlen zwischen 0 und 1 liefert, werden die Zahlen zunächst durch Multiplikation frisiert und dann abgeschnitten:</p>
<div class="listing"><pre class="prettyprint">Point[] points = new Point[ 5 ];
for ( int i = 0; i &lt; points.length; i++ )
  points[ i ] = new Point( (int)(Math.random() * 100),
                           (int)(Math.random() * 100) );
for ( Point p : points )
  System.out.println( p );</pre></div>
<p>Die Ausgabe erzeugt zum Beispiel Folgendes:</p>
<div class="listing"><pre class="prettyprint">java.awt.Point[x=59,y=77]
java.awt.Point[x=47,y=86]
java.awt.Point[x=18,y=71]
java.awt.Point[x=55,y=97]
java.awt.Point[x=12,y=70]</pre></div><a id="mj2627223aa77094452c665b55e7640b8b" name="mj2627223aa77094452c665b55e7640b8b"></a><a name="t39"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t310"></a><h3 class="t3"><span class="cfett">3.7.9</span> Mehrdimensionale Arrays *  <a href="#t2t311"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t39"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Java realisiert mehrdimensionale Arrays durch Arrays von Arrays. Sie können etwa für die Darstellung von mathematischen Matrizen oder Rasterbildern Verwendung finden.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Ebenso wie bei eindimensionalen Feldern lassen sich mehrdimensionale Felder gleich beim Anlegen initialisieren:</p>
<div class="listing"><pre class="prettyprint">int[][] A3x2 = { {1, 2}, {2, 3},    {3, 4} };
int[][] B    = { {1, 2}, {2, 3, 4}, {5} };</pre></div>
<p class="BStandard">Der zweite Fall lässt erkennen, dass das Feld nicht unbedingt rechteckig sein muss.</p>
</td>
</tr>
</table><br><p>Die folgende Zeile deklariert ein zweidimensionales Feld mit dem Platz für 32 Zellen, angeordnet in vier Zeilen und acht Spalten:</p>
<div class="listing"><pre class="prettyprint">int[][] A = new int[ 4 ][ 8 ];</pre></div>
<p>Zwei alternative Deklarationen sind:</p>
<div class="listing"><pre class="prettyprint">int A[][] = new int[ 4 ][ 8 ];    // Der Typ von A ist ein zweidimensionales Array
int[] A[] = new int[ 4 ][ 8 ];    // mit dem Elementtyp int</pre></div>
<p>Einzelne Elemente spricht der Ausdruck <span class="clisting">A[i][j]</span> an. [Die in Pascal übliche Notation <span class="clisting">A[i,j]</span> wird in Java nicht unterstützt. Die Notation wäre im Prinzip möglich, da Java im Gegensatz zu C(++) den Komma-Operator nur in <span class="clisting">for</span>-Schleifen zulässt.
]  Der Zugriff erfolgt mit so vielen Klammerpaaren, wie die Dimension des Arrays angibt. Obwohl mehrdimensionale Arrays im Prinzip Arrays mit Arrays als Elementen sind, lassen sie sich leicht deklarieren.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Der Aufbau von zweidimensionalen Feldern ist vergleichbar mit einer Matrix beziehungsweise Tabelle. Dann lässt sich der Eintrag im Feld <span class="clisting">a[x][y]</span> in folgender Tabelle ablesen:</p>
<div class="listing"><pre class="prettyprint">a[0][0]  a[0][1]  a[0][2]  a[0][3]  a[0][4]  a[0][5]  ...
a[1][0]  a[1][1]  a[1][2]  a[1][3]  a[1][4]  a[1][5]
a[2][0]  a[2][1]  a[2][2]  a[2][3]  a[2][4]  a[2][5]
...</pre></div>
</td>
</tr>
</table><br><h4 class="t4">Nichtrechteckige Felder</h4>
<p>Da in Java mehrdimensionale Arrays als Arrays von Arrays implementiert sind, müssen diese nicht zwingend rechteckig sein. Jede Zeile im Feld kann eine eigene Größe haben.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Ein dreieckiges Array mit Zeilen der Länge 1, 2 und 3:</p>
<div class="listing"><pre class="prettyprint">int[][] a = new int[ 3 ][];
for ( int i = 0; i &lt; 3; i++ )
  a[ i ] = new int[ i + 1 ];</pre></div>
</td>
</tr>
</table><br><h4 class="t4">Initialisierung von mehrdimensionalen Feldern</h4>
<p>Wenn wir ein mehrdimensionales Feld deklarieren, erzeugen versteckte Schleifen automatisch die inneren Felder. Im Vergleich von</p>
<div class="listing"><pre class="prettyprint">int[][] a = new int[ 3 ][ 4 ];
int[][] a = new int[ 3 ][];</pre></div>
<p>erzeugt die Laufzeitumgebung die passenden Unterfelder automatisch. Dies ist im zweiten Fall nicht so. Hier müssen wir selbst die Unterfelder initialisieren, bevor wir auf die Elemente zugreifen:</p>
<div class="listing"><pre class="prettyprint">for ( int i = 0; i &lt; a.length; i++ )
  a[ i ] = new int[ 4 ];</pre></div>
<p>PS: <span class="clisting">int[][] m = new int[][4];</span> funktioniert natürlich nicht!</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Verschiedene Möglichkeiten, ein mehrdimensionales Array zu initialisieren:</p>
<div class="listing"><pre class="prettyprint">int[][] A3x2 = { {1,2}, {2,3}, {3,4} };</pre></div>
<p class="BStandard">beziehungsweise</p>
<div class="listing"><pre class="prettyprint">int[][] A3x2 = new int[][]{ {1,2}, {2,3}, {3,4} };</pre></div>
</td>
</tr>
<tr>
<td class="tabellentext">
<p class="BStandard">beziehungsweise</p>
<div class="listing"><pre class="prettyprint">int[][] A3x2 = new int[][]{ new int[]{1,2}, new int[]{2,3}, new int[]{3,4} };</pre></div>
</td>
</tr>
</table><br><h4 class="t4">Das pascalsche Dreieck</h4>
<p>Das folgende Beispiel zeigt eine weitere Anwendung von nichtrechteckigen Arrays, in der das pascalsche Dreieck nachgebildet wird. Das Dreieck ist so aufgebaut, dass die Elemente unter einer Zahl genau die Summe der beiden direkt darüberstehenden Zahlen bilden. Die Ränder sind mit Einsen belegt.</p>
<p class="tabunter"><strong>Listing 3.9    </strong>Das pascalsche Dreieck</p>
<div class="listing"><pre class="prettyprint">            1
          1   1
        1   2   1
      1   3   3   1
    1   4   6   4   1
  1   5  10  10   5   1
1   6  15  20  15   6   1</pre></div>
<p>In der Implementierung wird zu jeder Ebene dynamisch ein Feld mit der passenden Länge angefordert. Die Ausgabe tätigt <span class="clisting">printf()</span> mit einigen Tricks mit dem Formatspezifizierer, da wir auf diese Weise ein führendes Leerzeichen bekommen:</p>
<p class="tabunter"><strong>Listing 3.10    </strong>PascalsTriangle.java</p>
<div class="listing"><pre class="prettyprint">class PascalsTriangle
{
  public static void main( String[] args )
  {
    int[][] triangle = new int[7][];

    for ( int row = 0; row &lt; triangle.length; row++ )
    {
      System.out.printf( "%." + (14 &#8211; row*2) +"s", "              " );

      triangle[row] = new int[row + 1];

      for ( int col = 0; col &lt;= row; col++ )
      {
        if ( (col == 0) || (col == row) )
           triangle[row][col] = 1;
        else
           triangle[row][col] = triangle[row &#8211; 1][col &#8211; 1] + triangle[row &#8211; 1][col];

        System.out.printf( "%3d ", triangle[row][col] );
      }

      System.out.println();
    }
  }
}</pre></div>
<p>Die Anweisung <span class="clisting">System.out.printf("%." + (14</span> &#8211; <span class="clisting">row*2) +"s", "</span>              <span class="clisting">")</span> produziert Einrückungen. Ohne die Konkatenation liest es sich einfacher:</p>
<p><span class="clisting">System.out.printf( "%.14s", "</span>              <span class="clisting">" )</span> führt zu <span class="clisting">"</span>              <span class="clisting">"</span></p>
<p><span class="clisting">System.out.printf( "%.12s", "</span>              <span class="clisting">" )</span> führt zu <span class="clisting">"</span>            <span class="clisting">"</span></p>
<p><span class="clisting">System.out.printf( "%.10s", "</span>              <span class="clisting">" )</span> führt zu <span class="clisting">"</span>          <span class="clisting">"</span></p>
<p>usw.</p>
<h4 class="t4">Andere Anwendungen</h4>
<p>Auf diese Art und Weise ist die Verwaltung von symmetrischen Matrizen einfach, da eine solche Matrix symmetrisch zur Diagonalen gleiche Elemente enthält. Daher kann entweder die obere oder die untere Dreiecksmatrix entfallen. Besonders nützlich ist der Einsatz dieser effizienten Speicherform für Adjazenzmatrizen [Eine Adjazenzmatrix stellt eine einfache Art dar, Graphen zu speichern. Sie besteht aus einem zweidimensionalen Array, das die Informationen über vorhandene Kanten im (gerichteten) Graphen enthält. Existiert eine Kante von einem Knoten zum anderen, so befindet sich in der Zelle ein Eintrag: entweder <span class="clisting">true</span>/<span class="clisting">false</span> für »Ja, die beiden sind verbunden« oder ein Ganzzahlwert für eine Gewichtung (Kantengewicht).
]  bei ungerichteten Graphen.</p><a id="mj7100c45624457324338529ef85e21324" name="mj7100c45624457324338529ef85e21324"></a><a name="t310"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t311"></a><h3 class="t3"><span class="cfett">3.7.10</span> Vorinitialisierte Arrays *  <a href="#t2t312"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t310"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Wenn wir in Java ein Array-Objekt erzeugen und gleich mit Werten initialisieren wollen, dann schreiben wir etwa:</p>
<div class="listing"><pre class="prettyprint">int[] primes = { 2, 3, 5, 7, 11, 13 };</pre></div>
<p>Sollen die Feldinhalte erst nach der Variablendeklaration initialisiert oder das Feld auch ohne Variable genutzt werden, so erlaubt Java dies nicht, und ein Versuch wie der folgende schlägt fehl:</p>
<div class="listing"><pre class="prettyprint">int[] primes;
primes = { 2, 5, 7, 11, 13 }; // <img src="common/totenkopf.gif" border="0" align="bottom" alt="Fehler"> Array constants can only be used in 
                              // initializers
avg( { 1.23, 4.94, 9.33, 3.91, 6.34 } );   // <img src="common/totenkopf.gif" border="0" align="bottom" alt="Fehler"> Ebenfalls Compilerfehler</pre></div>
<p>Zur Lösung gibt es zwei Ansätze. Der erste ist die Einführung einer neuen Variablen:</p>
<div class="listing"><pre class="prettyprint">int[] primes;
int[] tmpprimes = { 2, 5, 7, 11, 13 };
primes = tmpprimes;</pre></div>
<p>Dann gibt es eine Variante des <span class="clisting">new</span>-Operators, der durch ein Paar eckiger Klammern erweitert wird. Es folgen in geschweiften Klammern die Initialwerte des Arrays. Die Größe des Arrays entspricht genau der Anzahl der Werte. Für die oberen Beispiele ergibt sich folgende Schreibweise:</p>
<div class="listing"><pre class="prettyprint">int[] primes;
primes =<span class="cfett"> new int[]</span>{ 2, 5, 7, 11, 13 };
avg(<span class="cfett"> new double[]</span>{ 1.23, 4.94, 9.33, 3.91, 6.34 } );</pre></div>
<p>Da, wie im zweiten Beispiel, ein initialisiertes Feld mit Werten gleich an die Methode übergeben und keine zusätzliche Variable benutzt wird, heißt diese Art der Arrays »anonyme Arrays«. Eigentlich gibt es auch sonst anonyme Arrays, wie <span class="clisting">new int[2000].length</span> zeigt, doch wird in diesem Fall das Feld nicht mit Werten initialisiert.</p>
<h4 class="t4">Die Wahrheit über die Array-Initialisierung</h4>
<p>So schön die kompakte Initialisierung der Feldelemente ist, so laufzeit- und speicherintensiv ist sie auch. Da Java eine dynamische Sprache ist, passt das Konzept der Array-Initialisierung nicht ganz in das Bild. Daher wird die Initialisierung auch erst zur Laufzeit durchgeführt. Unser Primzahlfeld</p>
<div class="listing"><pre class="prettyprint">int[] primes = { 2, 3, 5, 7, 11, 13 };</pre></div>
<p>wird vom Java-Compiler umgeformt und analog zu Folgendem behandelt:</p>
<div class="listing"><pre class="prettyprint">int[] primes = new int[ 6 ];
primes[ 0 ] = 2;
primes[ 1 ] = 3;
primes[ 2 ] = 5;
primes[ 3 ] = 7;
primes[ 4 ] = 11;
primes[ 5 ] = 13;</pre></div>
<p>Erst nach kurzem Überlegen wird das Ausmaß sichtbar: Zunächst ist es der Speicherbedarf für die Methoden. Ist das Feld <span class="clisting">primes</span> in einer Methode deklariert und mit Werten initialisiert, kostet die Zuweisung Laufzeit, da wir viele Zugriffe haben, die auch alle schön durch die Index-Überprüfung gesichert sind. Da zudem der Bytecode für eine einzelne Methode wegen diverser Beschränkungen in der JVM nur beschränkt lang sein darf, kann dieser Platz für richtig große Arrays schnell erschöpft sein. Daher ist davon abzuraten, etwa Bilder oder große Tabellen im Programmcode zu speichern. Unter C war es populär, ein Programm einzusetzen, das eine Datei in eine Folge von Array-Deklarationen verwandelte. Ist dies in Java wirklich nötig, sollten wir Folgendes in Betracht ziehen:</p>
<ul class="gp">
<li>Wir verwenden ein statisches Feld (eine Klassenvariable), sodass das Array nur einmal während des Programmlaufs initialisiert werden muss.</li>
</ul>
<ul class="gp">
<li>Sind die Werte im Byte-Bereich, können wir sie in einen String konvertieren und später den String in ein Feld umwandeln. Das ist eine sehr clevere Methode, um Binärdaten einfach unterzubringen.</li>
</ul><a id="mj83719cf25a616582d6a0ae43dc356cc6" name="mj83719cf25a616582d6a0ae43dc356cc6"></a><a name="t311"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t312"></a><h3 class="t3"><span class="cfett">3.7.11</span> Mehrere Rückgabewerte *  <a href="#t2t313"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t311"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Wenn wir in Java Methoden schreiben, dann haben sie über <span class="clisting">return</span> höchstens einen Rückgabewert. Wollen wir aber mehr als einen Wert zurückgeben, müssen wir eine andere Lösung suchen. Zwei Ideen lassen sich verwirklichen:</p>
<ul class="gp">
<li>Behälter wie Arrays oder andere Sammlungen fassen Werte zusammen und liefern sie als Rückgabe.</li>
</ul>
<ul class="gp">
<li>Spezielle Behälter werden übergeben, in denen die Methode Rückgabewerte platziert; eine <span class="clisting">return</span>-Anweisung ist nicht mehr nötig.</li>
</ul>
<p>Betrachten wir eine statische Methode, die für zwei Zahlen die Summe und das Produkt als Array liefert:</p>
<p class="tabunter"><strong>Listing 3.11    </strong>MultipleReturnValues.java</p>
<div class="listing"><pre class="prettyprint">public class MultipleReturnValues
{
  static int[] productAndSum( int a, int b )
  {
    return new int[]{ a * b, a + b };
  }

  public static void main( String[] args )
  {
    System.out.println( productAndSum(9, 3)[ 1 ] );
  }
}</pre></div><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Eine ungewöhnliche Syntax in Java erlaubt es, bei Feldrückgaben das Paar eckiger Klammern auch hinter den Methodenkopf zu stellen, also statt</p>
<div class="listing"><pre class="prettyprint">static int<span class="cfett">[]</span> productAndSum( int a, int</pre></div>
<p class="BStandard">alternativ Folgendes zu schreiben:</p>
<div class="listing"><pre class="prettyprint">static int productAndSum( int a, int b )<span class="cfett">[]</span></pre></div>
</td>
</tr>
</table><br><a id="mj7da5fd18833c690818519a0c82e8be6e" name="mj7da5fd18833c690818519a0c82e8be6e"></a><a name="t312"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t313"></a><h3 class="t3"><span class="cfett">3.7.12</span> Methode mit variabler Argumentanzahl (Vararg)  <a href="#t2t314"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t312"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Bei vielen Methoden ist es klar, wie viele Argumente sie haben; eine Sinus-Methode bekommt ohnehin nur ein Argument. Es gibt jedoch Methoden, bei denen die Zahl mehr oder weniger frei ist, etwa bei der Methode <span class="clisting">max()</span>. Die Klasse <span class="clisting">java.lang.Math</span> sieht eine statische <span class="clisting">max()</span>-Methode mit zwei Argumenten vor, doch grundsätzlich könnte die Methode auch ein Feld entgegennehmen und von diesen Elementen das Maximum bilden. Java 5 sieht eine weitere Möglichkeit vor: Methoden mit <span class="ckursiv">variabler Argumentanzahl</span>, auch <span class="ckursiv">Varargs</span> genannt.</p>
<p>Eine Methode mit variabler Argumentanzahl nutzt die Ellipse (»<span class="clisting">...</span>«) zur Verdeutlichung, dass eine beliebige Anzahl Argumente angegeben werden darf. Der Typ fällt dabei aber nicht unter den Tisch; er wird ebenfalls angegeben:</p>
<div class="listing"><pre class="prettyprint">static int max(<span class="cfett"> int...</span> array )
{
}</pre></div>
<p>Die statische Methode <span class="clisting">max()</span> behandelt <span class="clisting">array</span> wie ein Feld. Da wir Argumente vom Typ <span class="clisting">int</span> fordern, ist <span class="clisting">array</span> vom Typ <span class="clisting">int[]</span> und kann so zum Beispiel mit dem erweiterten <span class="clisting">for</span> durchlaufen werden:</p>
<div class="listing"><pre class="prettyprint">for ( int e : array )
 ...</pre></div>
<p>Werden variable Argumentlisten in der Signatur definiert, so dürfen sie nur den letzten Parameter bilden; andernfalls könnte der Compiler bei den Parametern nicht unbedingt zuordnen, was nun ein Vararg und was schon der nächste gefüllte Parameter ist:</p>
<p class="tabunter"><strong>Listing 3.12    </strong>MaxVarArgs.java</p>
<div class="listing"><pre class="prettyprint">public class MaxVarArgs
{
  static int max(<span class="cfett"> int... array</span> )
  {
    if ( array == null || array.length == 0 )
      throw new IllegalArgumentException( "Array null oder leer!" );

    int currentMax = Integer.MIN_VALUE;
    for ( int e : array )
      if ( e &gt; currentMax )
        currentMax = e;
    return currentMax;
  }

  public static void main( String[] args )
  {
    System.out.println(<span class="cfett"> max(1, 2, 9, 3)</span> );     // 9
  }
}</pre></div>
<p>Der Nutzer kann jetzt die Methode aufrufen, ohne ein Feld für die Argumente explizit zu definieren. Er bekommt auch gar nicht mit, dass der Compiler im Hintergrund ein Feld mit vier Elementen angelegt hat. So übergibt der Compiler:</p>
<div class="listing"><pre class="prettyprint">System.out.println( max(<span class="cfett"> new int[] { 1, 2, 9, 3 }</span> ) );</pre></div>
<p>An der Schreibweise lässt sich gut ablesen, dass wir ein Feld auch von Hand übergeben können:</p>
<div class="listing"><pre class="prettyprint">int[] feld = { 1, 2, 9, 3 };
System.out.println( max(feld) );</pre></div><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Da Varargs als Felder umgesetzt werden, sind überladene Varianten wie <span class="clisting">max(int... array) und max(int[] array)</span>, also einmal mit einem Vararg und einmal mit einem Feld, nicht möglich. Besser ist es hier, immer eine Variante mit Varargs zu nehmen, da diese mächtiger ist.</p>
</td>
</tr>
</table><br><a id="mjd0a6c6bf70eb16174a7c44411d2afbf4" name="mjd0a6c6bf70eb16174a7c44411d2afbf4"></a><a name="t313"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t314"></a><h3 class="t3"><span class="cfett">3.7.13</span> Klonen kann sich lohnen &#8211; Arrays vermehren *  <a href="#t2t315"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t313"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Wollen wir eine Kopie eines Arrays mit gleicher Größe und gleichem Elementtyp schaffen, so nutzen wir dazu die Objektmethode <span class="clisting">clone()</span>. [Das ist gültig, da Arrays intern die Schnittstelle <span class="clisting">Cloneable</span> implementieren. <span class="clisting">System.out.println(new int[0] instanceof Cloneable);</span> gibt <span class="clisting">true</span> zurück.
]  Sie klont &#8211; in unserem Fall kopiert &#8211; die Elemente des Array-Objekts in ein neues. Im Fall von geklonten Objekt-Feldern ist es wichtig, zu verstehen, dass die Kopie flach ist. Die Verweise aus dem ersten Feld kopiert <span class="clisting">clone()</span> in das neue, es klont aber die Objekte selbst nicht. Bei mehrdimensionalen Arrays wird also nur die erste Dimension kopiert, Unter-Arrays werden somit gemeinsam genutzt:</p>
<p class="tabunter"><strong>Listing 3.13    </strong>CloneDemo.java, main()</p>
<div class="listing"><pre class="prettyprint">int[] sourceArray = new int[ 6 ];
sourceArray[ 0 ]  = 4711;
int[] targetArray =<span class="cfett"> sourceArray.clone()</span>;
System.out.println( targetArray.length );  // 6
System.out.println( targetArray[ 0 ] );    // 4711
Point[] pointArray1 = { new Point(1, 2), new Point(2, 3) };
Point[] pointArray2 =<span class="cfett"> pointArray1.clone()</span>;
System.out.println( pointArray1[ 0 ] == pointArray2[ 0 ] );  // true</pre></div>
<p>Die letzte Zeile zeigt anschaulich, dass die beiden Felder dasselbe <span class="clisting">Point</span>-Objekt referenzieren; die Kopie ist flach, aber nicht tief.</p><a id="mja91938f74923b4f8ab51724e9530e8cb" name="mja91938f74923b4f8ab51724e9530e8cb"></a><a name="t314"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t315"></a><h3 class="t3"><span class="cfett">3.7.14</span> Feldinhalte kopieren *  <a href="#t2t316"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t314"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Eine weitere nützliche statische Methode ist <span class="clisting">System.arraycopy()</span>. Sie kann auf zwei Arten arbeiten:</p>
<ul class="gp">
<li><span class="ckursiv">Auf zwei schon existierenden Feldern</span>. Ein Teil eines Feldes wird in ein anderes Feld kopiert. <span class="clisting">arraycopy()</span> eignet sich dazu, sich vergrößernde Felder zu implementieren, indem zunächst ein neues größeres Feld angelegt wird und anschließend die alten Feldinhalte in das neue Feld kopiert werden.</li>
</ul>
<ul class="gp">
<li><span class="ckursiv">Auf dem gleichen Feld</span>. So lässt sich die Methode dazu verwenden, Elemente eines Felds um bestimmte Positionen zu verschieben. Die Bereiche können sich durchaus überlappen.</li>
</ul><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">final class java.lang.<span class="cfett">System</span></pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">static void arraycopy( Object src, int srcPos, Object dest, int destPos, int length )</span></li>
</ul>
<ul class="gpeg">
<li>
<ul class="eg">
<li>Kopiert <span class="clisting">length</span> viele Einträge des Arrays <span class="clisting">src</span> ab der Position <span class="clisting">srcPos</span> in ein Array <span class="clisting">dest</span> ab der Stelle <span class="clisting">destPos</span>. Der Typ des Feldes ist egal, es muss nur in beiden Fällen der gleiche Typ sein. Die Methode arbeitet für große Felder schneller als eine eigene Kopierschleife.</li>
</ul>
</li>
</ul><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Um zu zeigen, dass <span class="clisting">arraycopy()</span> auch innerhalb des eigenen Feldes kopiert, sollen alle Elemente bis auf eines im Feld <span class="clisting">f</span> nach links und nach rechts bewegt werden:</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">System.arraycopy( f, 1, f, 0, f.length &#8211; 1 );   // links
System.arraycopy( f, 0, f, 1, f.length &#8211; 1 );   // rechts</pre></div>
<p class="BStandard">Hier bleibt jedoch ein Element doppelt!</p>
</td>
</tr>
</table><br><div class="bildbox">
<p><a name="IDAWVZD"></a><a onClick="OpenWin('bilder/365_java_03_007.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein365_java_03_007.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 3.4    </strong>Kopieren der Elemente von einem Feld in ein anderes</p><a id="mj84d959216ad1aa6d5c9ccf5c270e4545" name="mj84d959216ad1aa6d5c9ccf5c270e4545"></a><a name="t315"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t316"></a><h3 class="t3"><span class="cfett">3.7.15</span> Die Klasse Arrays zum Vergleichen, Füllen und Suchen nutzen  <img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"><a href="#t2t315"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Die Klasse <span class="clisting">java.util.Arrays</span> deklariert nützliche statische Methoden im Umgang mit Arrays. So bietet sie Möglichkeiten zum Vergleichen, Sortieren und Füllen von Feldern sowie zur binären Suche.</p>
<div class="bildbox">
<p><a name="IDACWZD"></a><a onClick="OpenWin('bilder/javautilarrays.gif','Abbildung',800,800)"><img border="0" src="bilderklein/kleinjavautilarrays.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<h4 class="t4">String-Repräsentation eines Feldes</h4>
<p>Nehmen wir an, wir haben es mit einem Feld von Hundenamen zu tun, das wir auf dem Bildschirm ausgeben wollen:</p>
<p class="tabunter"><strong>Listing 3.14    </strong>DogArrayToString, main()</p>
<div class="listing"><pre class="prettyprint">String[] dogs = {
    "Flocky Fluke", "Frizzi Faro", "Fanny Favorit", "Frosty Filius",
    "Face Flash", "Fame Friscco" };</pre></div>
<p>Soll der Feldinhalt zum Testen auf den Bildschirm gebracht werden, so kommt eine Ausgabe mit <span class="clisting">System.out.println(dogs)</span> <span class="ckursiv">nicht</span> in Frage, denn <span class="clisting">toString()</span> ist auf dem Objekttyp Array nicht sinnvoll definiert:</p>
<div class="listing"><pre class="prettyprint">System.out.println( dogs );                  // [Ljava.lang.String;@10b62c9</pre></div>
<p>Die statische Methode <span class="clisting">Arrays.toString</span><span class="clisting">(array)</span> liefert für unterschiedliche Feldtypen die gewünschte String-Repräsentation des Feldes:</p>
<div class="listing"><pre class="prettyprint">System.out.println(<span class="cfett"> Arrays.toString(dogs)</span> ); // [Flocky Fluke, ...]</pre></div>
<p>Das spart eine <span class="clisting">for</span>-Schleife, die durch das Feld läuft und auf jedem Element <span class="clisting">print()</span> aufruft:</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">class java.util.<span class="cfett">Arrays</span></pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">static String toString( XXX[] a )</span>
Liefert eine String-Repräsentation des Feldes. Der Typ <span class="clisting">XXX</span> steht stellvertretend für <span class="clisting">boolean</span>, <span class="clisting">byte</span>, <span class="clisting">char</span>, <span class="clisting">short</span>, <span class="clisting">int</span>, <span class="clisting">long</span>, <span class="clisting">float</span>, <span class="clisting">double</span>.</li>
</ul>
<ul class="gp">
<li><span class="clisting">static String toString( Object[] a )</span>
Liefert eine String-Repräsentation des Feldes. Im Fall des Objekttyps ruft die Methode auf jedem Objekt im Feld <span class="clisting">toString()</span> auf.</li>
</ul>
<ul class="gp">
<li><span class="clisting">static String deepToString( Object[] a )</span>
Ruft auch auf jedem Unterfeld <span class="clisting">Arrays.toString()</span> auf und nicht nur <span class="clisting">toString()</span> wie bei jedem anderen Objekt.</li>
</ul>
<h4 class="t4">Sortieren</h4>
<p>Diverse statische <span class="clisting">Arrays.sort()</span>-Methoden ermöglichen das Sortieren von Elementen im Feld. Bei primitiven Elementen (kein <span class="clisting">boolean</span>) gibt es keine Probleme, da sie eine natürliche Ordnung haben. Im Fall von Objekten müssen sie vergleichbar sein. Das gelingt entweder mit einem extra <span class="clisting">Comparator</span>, oder die Klassen implementieren die Schnittstelle <span class="clisting">Comparable</span>. Kapitel 9, »Besondere Klassen der Java SE«, beschreibt diese Möglichkeiten präzise.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">class java.util.<span class="cfett">Arrays</span></pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">static void sort( XXX[] a )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">static void sort( XXX[] a, int fromIndex, int toIndex )</span>
Sortiert die gesamte Liste vom Typ <span class="clisting">XXX</span> (wobei <span class="clisting">XXX</span> für <span class="clisting">byte</span>, <span class="clisting">char</span>, <span class="clisting">short</span>, <span class="clisting">int</span>, <span class="clisting">long</span>, <span class="clisting">float</span>, <span class="clisting">double</span> steht) oder einen ausgewählten Teil. Bei angegebenen Grenzen ist <span class="clisting">fromIndex</span> wieder inklusiv und <span class="clisting">toIndex</span> exklusiv. Sind die Grenzen fehlerhaft, löst die Methode eine <span class="clisting">IllegalArgumentException</span> (im Fall <span class="clisting">fromIndex &gt; toIndex</span>) beziehungsweise eine <span class="clisting">ArrayIndexOutOfBoundsException</span> (<span class="clisting">fromIndex &lt; 0</span> oder <span class="clisting">toIndex &gt; a.length</span>) aus.</li>
</ul>
<ul class="gp">
<li><span class="clisting">static void sort( Object[] a )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">static void sort( Object[] a, int fromIndex, int toIndex )</span>
Sortiert ein Feld von Objekten. Die Elemente müssen <span class="clisting">Comparable</span> implementieren. Bei der Methode gibt es keinen generischen Typ-Parameter.</li>
</ul>
<ul class="gp">
<li><span class="clisting">static &lt;T&gt; void sort( T[] a, Comparator&lt;? super T&gt; c )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">static &lt;T&gt; void sort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; c )</span>
Sortiert ein Feld von Objekten mit gegebenem <span class="clisting">Comparator</span>.</li>
</ul>
<h4 class="t4">Felder vergleichen mit »Arrays.equals()« und »Arrays.deepEquals()« *</h4>
<p>Die statische Methode <span class="clisting">Arrays.equals()</span> vergleicht, ob zwei Felder die gleichen Inhalte besitzen; dazu ist die überladene Methode für alle wichtigen Typen definiert. Wenn ja, ist die Rückgabe der Methode <span class="clisting">true</span>, sonst <span class="clisting">false</span>. Natürlich müssen beide Arrays schon die gleiche Anzahl von Elementen besitzen, sonst ist der Test sofort vorbei und das Ergebnis <span class="clisting">false</span>. Im Fall von Objektfeldern nutzt <span class="clisting">Arrays.equals()</span> nicht die Identitätsprüfung per <span class="clisting">==</span>, sondern die Gleichheit per <span class="clisting">equals()</span>:</p>
<div class="listing"><pre class="prettyprint">int[] array = { 1, 2, 3, 4 };
int[] clone = array.clone();
System.out.println(<span class="cfett"> Arrays.equals( array, clone )</span> );            // true</pre></div>
<p>Ein Vergleich von Teilfeldern ist leider auch nach mehr als zehn Jahren Java-Bibliothek einfach nicht vorgesehen.</p>
<p>Bei unterreferenzierten Feldern betrachtet <span class="clisting">Arrays.equals()</span> das innere Feld als einen Objektverweis und vergleicht es auch mit <span class="clisting">equals()</span> &#8211; was jedoch bedeutet, dass nicht identische, aber mit gleichen Elementen referenzierte innere Felder als ungleich betrachtet werden. Die statische Methode <span class="clisting">deepEquals()</span> bezieht auch unterreferenzierte Felder in den Vergleich mit ein. Ein Beispiel verdeutlicht den Unterschied zwischen <span class="clisting">equals()</span> und <span class="clisting">deepEquals()</span>:</p>
<p class="tabunter"><strong>Listing 3.15    </strong>ArrayEqualsDemo.java, main()</p>
<div class="listing"><pre class="prettyprint">int[][] a1 = { { 0, 1 }, { 1, 0 } };
int[][] a2 = { { 0, 1 }, { 1, 0 } };
System.out.println(<span class="cfett"> Arrays.equals( a1, a2 )</span> );     // false
System.out.println(<span class="cfett"> Arrays.deepEquals( a1, a2 )</span> ); // true
System.out.println( a1[0] );                       // zum Beispiel [I@10b62c9
System.out.println( a2[0] );                       // zum Beispiel [I@82ba41</pre></div>
<p>Den Grund für das unterschiedliche Verhalten zeigen die beiden letzten Konsolenausgaben: Die von <span class="clisting">a1</span> und <span class="clisting">a2</span> unterreferenzierten Felder enthalten die gleichen Elemente, sind aber zwei unterschiedliche Objekte, also nicht identisch. <span class="clisting">deepEquals()</span> vergleicht auch eindimensionale Felder:</p>
<div class="listing"><pre class="prettyprint">Object[] b1 = { "1", "2", "3" };
Object[] b2 = { "1", "2", "3" };
System.out.println( Arrays.deepEquals( b1, b2 ) ); // true</pre></div><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">class java.util.<span class="cfett">Arrays</span></pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">static boolean equals( XXX[] a, XXX[] a2 )</span>
Vergleicht zwei Felder gleichen Typs und liefert <span class="clisting">true</span>, wenn die Felder gleich groß und Elemente paarweise gleich sind. <span class="clisting">XXX</span> steht stellvertretend für <span class="clisting">boolean</span>, <span class="clisting">byte</span>, <span class="clisting">char</span>, <span class="clisting">int</span>, <span class="clisting">short</span>, <span class="clisting">long</span>, <span class="clisting">double</span>, <span class="clisting">float</span>.</li>
</ul>
<ul class="gp">
<li><span class="clisting">static boolean equals( Object[] a, Object[] a2 )</span>
Vergleicht zwei Felder mit Objektverweisen. Ein Objekt-Feld darf <span class="clisting">null</span> enthalten; dann gilt für die Gleichheit <span class="clisting">e1==null ? e2==null : e1.equals(e2)</span>.</li>
</ul>
<ul class="gp">
<li><span class="clisting">static boolean deepEquals( Object[] a1, Object[] a2 )</span>
Liefert <span class="clisting">true</span>, wenn die beiden Felder ebenso wie alle Unterfelder &#8211; rekursiv im Fall von Unter-Objekt-Feldern &#8211; gleich sind.</li>
</ul>
<h4 class="t4">Füllen von Feldern *</h4>
<p><span class="clisting">Arrays.fill()</span> füllt ein Feld mit einem festen Wert. Der Start-Endbereich lässt sich optional angeben.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Fülle ein <span class="clisting">char</span>-Feld mit Sternchen:</p>
<div class="listing"><pre class="prettyprint">char[] chars = new char[ 4 ];</pre></div>
<div class="listing"><pre class="prettyprint"><span class="cfett">Arrays.fill( chars, '*' )</span>;</pre></div>
<div class="listing"><pre class="prettyprint">System.out.println( Arrays.toString( chars ) ); // [*, *, *, *]</pre></div>
</td>
</tr>
</table><br><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">class java.util.<span class="cfett">Arrays</span></pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">static void fill( XXX[] a, XXX val )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">static void fill( XXX[] a, int fromIndex, int toIndex, XXX val )</span>
Setzt das Element <span class="clisting">val</span> in das Feld. Mögliche Typen für <span class="clisting">XXX</span> sind <span class="clisting">boolean</span>, <span class="clisting">char</span>, <span class="clisting">byte</span>, <span class="clisting">short</span>, <span class="clisting">int</span>, <span class="clisting">long</span>, <span class="clisting">double</span>, <span class="clisting">float</span> oder mit <span class="clisting">Object</span> beliebige Objekte. Beim Bereich ist <span class="clisting">fromIndex</span> inklusiv und <span class="clisting">toIndex</span> exklusiv.</li>
</ul>
<h4 class="t4">Feldabschnitte kopieren *</h4>
<p>Die Klasse <span class="clisting">Arrays</span> bietet eine Reihe von <span class="clisting">copyOf()</span>- bzw. <span class="clisting">copyOfRange()</span>-Methoden, die gegenüber <span class="clisting">clone()</span> den Vorteil haben, dass sie auch Bereichsangaben erlauben und das neue Feld größer machen können; im letzten Fall füllen die Methoden das Feld je nach Typ mit <span class="clisting">null</span>, <span class="clisting">false</span> oder 0.</p>
<p class="tabunter"><strong>Listing 3.16    </strong>ArraysCopyOfDemo.java, main()</p>
<div class="listing"><pre class="prettyprint">String[] snow = { "Neuschnee", "Altschnee", "Harsch", "Firn" };

String[] snow1 =<span class="cfett"> Arrays.copyOf</span>( snow, 2 );         // [Neuschnee, Altschnee]
String[] snow2 =<span class="cfett"> Arrays.copyOf</span>( snow, 5 );         // [Neuschnee, Altschnee, <img src="common/umbruch.gif" border="0" alt="Umbruch">
                                                   // Harsch, Firn, null]
String[] snow3 =<span class="cfett"> Arrays.copyOfRange</span>( snow, 2, 4 ); // [Harsch, Firn]
String[] snow4 =<span class="cfett"> Arrays.copyOfRange</span>( snow, 2, 5 ); // [Harsch, Firn, null]</pre></div><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">class java.util.<span class="cfett">Arrays</span></pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">static boolean[] copyOf( boolean[] original, int newLength )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">static byte[] copyOf( byte[] original, int newLength )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">static char[] copyOf( char[] original, int newLength )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">static double[] copyOf( double[] original, int newLength )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">static float[] copyOf( float[] original, int newLength )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">static int[] copyOf( int[] original, int newLength )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">static long[] copyOf( long[] original, int newLength )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">static short[] copyOf( short[] original, int newLength )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">static &lt;T&gt; T[] copyOf( T[] original, int newLength )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">static boolean[] copyOfRange( boolean[] original, int from, int to )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">static byte[] copyOfRange( byte[] original, int from, int to )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">static char[] copyOfRange( char[] original, int from, int to )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">static double[] copyOfRange( double[] original, int from, int to )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">static float[] copyOfRange( float[] original, int from, int to )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">static int[] copyOfRange( int[] original, int from, int to )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">static long[] copyOfRange( long[] original, int from, int to )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">static short[] copyOfRange( short[] original, int from, int to )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">static &lt;T&gt; T[] copyOfRange( T[] original, int from, int to )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">static &lt;T,U&gt; T[] copyOfRange( U[] original, int from, int to,</span>
                              <span class="clisting">Class&lt;? extends T[]&gt; newType )</span>
Erzeugt ein neues Feld mit der gewünschten Größe beziehungsweise dem angegebenen Bereich aus einem existierenden Feld. Wie üblich ist der Index <span class="clisting">from</span> inklusiv und <span class="clisting">to</span> exklusiv.</li>
</ul><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Hänge zwei Arrays aneinander. Das ist ein gutes Beispiel für <span class="clisting">copyOf()</span>, wenn das Zielfeld größer ist:</p>
<div class="listing"><pre class="prettyprint">public static &lt;T&gt; T[] concat( T[] first, T[] second
{
  T[] result = <span class="cfett">Arrays.copyOf( first, first.length + second.length )</span>;
  System.arraycopy( second, 0, result, first.length, second.length );

  return result;
}</pre></div>
</td>
</tr>
</table><br><h4 class="t4">Halbierungssuche *</h4>
<p>Ist das Feld sortiert, lässt sich mit <span class="clisting">Arrays.binarySearch()</span> eine binäre Suche (Halbierungssuche) durchführen. Ist das Feld nicht sortiert, ist das Ergebnis unvorhersehbar. Findet <span class="clisting">binarySearch()</span> das Element, ist der Rückgabewert der Index der Fundstelle, andernfalls ist die Rückgabe negativ:</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">class java.util.<span class="cfett">Arrays</span></pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">static int binarySearch( XXX[] a, XXX key )</span>
Sucht mit der Halbierungssuche nach einem Schlüssel. <span class="clisting">XXX</span> steht stellvertretend für <span class="clisting">byte</span>, <span class="clisting">char</span>, <span class="clisting">int</span>, <span class="clisting">long</span>, <span class="clisting">float</span>, <span class="clisting">double</span>.</li>
</ul>
<ul class="gp">
<li><span class="clisting">static int binarySearch( Object[] a, Object key )</span>
Sucht mit der Halbierungssuche nach <span class="clisting">key</span>. Die Objekte müssen die Schnittstelle <span class="clisting">Comparable</span> implementieren; das bedeutet im Allgemeinen, dass die Elemente vom gleichen Typ sein müssen &#8211; also nicht Strings und Hüpfburg-Objekte gemischt.</li>
</ul>
<ul class="gp">
<li><span class="clisting">static &lt;T&gt; int binarySearch( T[] a, T key, Comparator&lt;? super T&gt; c )</span>
Sucht mit der Halbierungssuche ein Element im Objektfeld. Die Vergleiche übernimmt ein spezielles Vergleichsobjekt <span class="clisting">c</span>.</li>
</ul>
<ul class="gp">
<li><span class="clisting">static &lt;T&gt; int binarySearch( T[] a, int fromIndex, int toIndex, T key, 
                           Comparator&lt;? super T&gt; c )</span>
Schränkt die Binärsuche auf Bereiche ein.</li>
</ul>
<p>Die API-Dokumentation von <span class="clisting">binarySearch()</span> ist durch Verwendung der Generics (mehr darüber in Kapitel 7, »Generics&lt;T&gt;«) etwas schwieriger. Wir werden in Kapitel 13, »Datenstrukturen und Algorithmen«, auch noch einmal auf die statische Methode <span class="clisting">binarySearch()</span> für beliebige Listen zurückkommen und insbesondere die Bedeutung der Schnittstellen <span class="clisting">Comparator</span> und <span class="clisting">Comparable</span> in Kapitel 9, »Besondere Klassen der Java SE«, genau klären.</p>
<h4 class="t4">Felder zu Listen mit »Arrays.asList()« &#8211; praktisch für die Suche und zum Vergleichen *</h4>
<p>Ist das Feld unsortiert, funktioniert <span class="clisting">binarySearch()</span> nicht. Die Klasse <span class="clisting">Arrays</span> hat für diesen Fall keine Methode im Angebot &#8211; eine eigene Schleife muss her. Es gibt aber noch eine Möglichkeit: Die statische Methode <span class="clisting">Arrays.asList()</span> dekoriert das Array als Liste vom Typ <span class="clisting">java.util.List</span>, die dann praktische Methoden wie <span class="clisting">contains()</span>, <span class="clisting">equals()</span> oder <span class="clisting">sublist()</span> anbietet. Mit den Methoden sind Dinge auf Feldern möglich, für die <span class="clisting">Arrays</span> bisher keine Methoden definierte.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Teste, ob auf der Kommandozeile der Schalter <span class="clisting">-?</span> gesetzt ist. Die auf der Kommandozeile übergebenen Argumente übergibt die Laufzeitumgebung als String-Feld in die statische <span class="clisting">main(String[] args)</span>-Methode:</p>
<div class="listing"><pre class="prettyprint">if ( Arrays.asList( args ).contains( "-?" ) )
  ...</pre></div>
</td>
</tr>
</table><br><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Teste, ob Teile eines Feldes gleich sind:</p>
<p class="tabunter"><strong>Listing 3.17    </strong>AsListDemo.java, main()</p>
<div class="listing"><pre class="prettyprint">// Index         0                1          2
String[] a = { "Asus",       "Elitegroup", "MSI" };
String[] b = { "Elitegroup", "MSI",        "Shuttle" };

System.out.println( Arrays.asList( a ).subList( 1, 3 ).
                    equals( Arrays.asList( b ).subList( 0, 2 ) ) );  // true</pre></div>
<p class="BStandard">Im Fall von <span class="clisting">subList()</span> ist der Start-Index inklusiv und der End-Index exklusiv (das ist die Standardnotation von Bereichen in Java, etwa auch bei <span class="clisting">substring()</span> oder <span class="clisting">fill()</span>). Somit werden in obigem Beispiel die Einträge 1 bis 2 aus <span class="clisting">a</span> mit den Einträgen 0 bis 1 aus <span class="clisting">b</span> verglichen.</p>
</td>
</tr>
</table><br><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">class java.util.<span class="cfett">Arrays</span></pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">static &lt;T&gt; List&lt;T&gt; asList( T... a )</span>
Liefert eine Liste vom Typ <span class="clisting">T</span> bei einem Feld vom Typ <span class="clisting">T</span>.</li>
</ul>
<p>Die statische Methode <span class="clisting">asList()</span> nimmt über das Vararg entweder ein Feld von Objekten (kein primitives Feld!) an oder aufgezählte Elemente. Im Fall der aufgezählten Elemente ist auch kein oder genau ein Element erlaubt, wie folgendes Beispiel zeigt:</p>
<div class="listing"><pre class="prettyprint">System.out.println( Arrays.asList() );        // []
System.out.println( Arrays.asList("Chris") );    // [Chris]</pre></div>
<p>Dass das übergebende Feld kein primitives Feld sein darf, veranschaulicht das folgende Beispiel:</p>
<div class="listing"><pre class="prettyprint">int[] nums = { 1, 2 };
System.out.println( Arrays.asList(nums).toString() ); // [[I@82ba41]
System.out.println( Arrays.toString(nums) );          // [1, 2]</pre></div>
<p>Der Grund ist einfach: <span class="clisting">Arrays.asList()</span> erkennt <span class="clisting">nums</span> nicht als Feld von Objekten, sondern als genau ein Element einer Aufzählung. So setzt die statische Methode das Feld mit Primitiven als ein Element in die Liste, und <span class="clisting">toString()</span> eines <span class="clisting">java.util.List</span>-Objekts ruft lediglich auf dem Feld-Objekt <span class="clisting">toString()</span> auf, was die kryptische Ausgabe zeigt.</p><br><hr><a name="kommentar"></a><h3>Ihr Kommentar</h3>
                       Wie hat Ihnen das &lt;openbook&gt; gefallen? Wir freuen uns immer über Ihre freundlichen und kritischen Rückmeldungen.
                       <form action="http://www.galileo-press.de/feedback/openbook" method="post" style="text-align: center; margin-top: 10px;"><input type="hidden" name="openbookurl" value="javainsel9/.htm"><input type="hidden" name="buchtitel" value="Java ist auch eine Insel"><input type="hidden" name="Kapitel" value="3.7 Arrays"><table border="0">
<tr>
<td><label for="name">Name</label><br></td>
<td><input type="text" name="name" id="name" size="40"><br></td>
</tr>
<tr>
<td><label for="email">E-Mail</label><br></td>
<td><input type="text" name="email" id="email" size="40"><br></td>
</tr>
<tr>
<td valign="top"><label for="comment">Ihr Kommentar</label><br></td>
<td><textarea name="comment" id="comment" rows="10" cols="40"></textarea><br></td>
</tr>
<tr>
<td>
</td>
<td><input type="submit" value="Kommentar absenden"></td>
</tr>
</table>
</form>
</div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="javainsel_03_006.htm" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a class="navnav" href="#">&lt;top&gt;</a></div></td>
<td align="right" width="25%"><div align="right"><a href="javainsel_03_008.htm" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
</table>
</div></td>
<td width="10" valign="top">  </td>
<td width="160" valign="top">
<table border="0" cellpadding="0" cellspacing="0" width="160">
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2">
&nbsp;<a href="http://www.galileocomputing.de/katalog/buecher/?GPP=opjiVIV" class="autor">
<strong>Zum Katalog</strong></a>

</td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2">
<img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV">
<img src="common/9783836215060_s.gif" width="119" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Java ist auch eine Insel" title="Zum Katalog: Java ist auch eine Insel">
<br><br><br><br><br><br><strong>Java ist auch eine Insel</strong><br><img src="common/pfeil_rechts5.gif" border="0" alt="">Jetzt bestellen</a><br /><br />
</td>
</tr>
</table>
</td>

</tr>
</table>
</td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2"><span class="autor"><strong>&nbsp;Ihre Meinung?</strong></a></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">

<table cellspacing="3">
<tr>
<td>Wie hat Ihnen das &lt;openbook&gt; gefallen?<br><a href="#kommentar"><img src="common/pfeil_rechts5.gif" border="0" alt="">Ihre Meinung</a>
<br><br></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>

<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>
<tr>
<td>
</td>
</tr>

<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2">&nbsp;<a href="http://www.galileocomputing.de/katalog/buecher/?GPP=opjiVIV" class="autor"><strong>Buchempfehlungen</strong></a></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2285?GPP=opjiVIV">
<img src="common/9783836215275_s.gif" width="102" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Computergeschichte(n) – nicht nur für Geeks" title="Zum Katalog: Computergeschichte(n) – nicht nur für Geeks"><br><br><br><br><br><br>&nbsp;Computergeschichte(n)<br>&nbsp;nicht nur für Geeks</a><br><br></td>
</tr>

<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/1949?GPP=opjiVIV">
<img src="common/9783836213080_s.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Java und XML" title="Zum Katalog: Java und XML"><br><br><br><br><br><br><br>&nbsp;Java und XML</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2346?GPP=opjiVIV">
<img src="common/9783836215688_s.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Einstieg in Java" title="Zum Katalog: Einstieg in Java"><br><br><br><br><br><br><br>&nbsp;Einstieg<br>&nbsp;in Java</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2051?GPP=opjiVIV">

<img src="common/9783836213677_s.gif" width="112" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Einstieg in XML" title="Zum Katalog: Einstieg in XML"><br><br><br><br><br><br><br>&nbsp;Einstieg<br>&nbsp;in XML</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2322?GPP=opjiVIV">
<img src="common/9783836215527_s.gif" width="112" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Visual C# 2010" title="Zum Katalog: Visual C# 2010"><br><br><br><br><br><br><br>&nbsp;Visual C# 2010</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2212?GPP=opjiVIV">
<img src="common/9783836214742_s.gif" width="119" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Professionell entwickeln mit Visual C# 2010" title="Zum Katalog: Professionell entwickeln mit Visual C# 2010"><br><br><br><br><br><br><br>&nbsp;Professionell<br>&nbsp;entwickeln mit<br>&nbsp;Visual C# 2010</a><br><br></td>
</tr>

<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2156?GPP=opjiVIV">
<img src="common/9783836214292_s.gif" width="108" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C++ von A bis Z" title="Zum Katalog: C++ von A bis Z"><br><br><br><br><br><br><br>&nbsp;C++ von A bis Z</a><br><br></td>
</tr>
</table></td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>

<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2"><span class="autor"><strong>&nbsp;Shopping</strong></span></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><b>Versandkostenfrei</b> bestellen in Deutschland und &Ouml;sterreich<br><a href="http://www.galileocomputing.de/hilfe/Shop/?GPP=opjiVIV"><img src="common/pfeil_rechts5.gif" border="0" alt="Info">Info</a><br><br></td>

</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table><br><br><hr width="70%" align="center">
<div align="center">
<p class="standard"><strong>Copyright © Galileo Press 2011</strong><br>
        Für Ihren privaten Gebrauch dürfen Sie die Online-Version natürlich ausdrucken.
        Ansonsten unterliegt das &lt;openbook&gt; denselben Bestimmungen, wie die
        gebundene Ausgabe: Das Werk einschließlich aller seiner Teile ist urheberrechtlich
        geschützt. Alle Rechte vorbehalten einschließlich der Vervielfältigung, Übersetzung,
        Mikroverfilmung sowie Einspeicherung und Verarbeitung in elektronischen Systemen.</p><br><a href="http://www.galileocomputing.de/">[Galileo Computing]</a><br><br>
      Galileo Press, Rheinwerkallee 4, 53227 Bonn, Tel.: 0228.42150.0, Fax 0228.42150.77, <a href="mailto:info@galileo-press.de">info@galileo-press.de</a></div><br><br></body>
</html>
