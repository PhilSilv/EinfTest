<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Galileo Computing :: Java ist auch eine Insel – 2.8 Methoden einer Klasse</title>
<meta name="title" content="Galileo Computing :: Java ist auch eine Insel - 2.8 Methoden einer Klasse">
<meta name="author" content="Christian Ullenboom ">
<meta name="publisher" content="Galileo Press 2011">
<meta name="copyright" content="Galileo Press 2011">
<meta name="Description" content="Java ist auch eine Insel - Das umfassende Handbuch – 2.8 Methoden einer Klasse">
<meta name="audience" content="Alle">
<meta name="robots" content="INDEX,FOLLOW">
<meta http-equiv="content-language" content="de">
<link rel="stylesheet" type="text/css" href="common/galileo_open.css">
<link rel="prev" href=".htm">
<link rel="next" href=".htm"><script type="text/javascript"><!--
    function OpenWin(url,name,height,width)
    {
      var InfoWin = window.open(url,name,"directories=0,height="+height+",width=" + width + ",hotkeys=0,location=0,menubar=0,resizable=1,screenX=150,screenY=10,left=150,top=10,scrollbars=1,status=1,titlebar=0,toolbar=0");
      InfoWin.focus();
    }
    //--></script><link href="common/prettify.css" type="text/css" rel="stylesheet"><script type="text/javascript" src="common/prettify.js"></script></head>
<body vlink="#000099" link="#000099" alink="#000099" onload="prettyPrint()">
<table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#000066">
<tr>
<td height="74" valign="bottom" colspan="2"><a href="http://www.galileocomputing.de/katalog/openbook?GPP=opjiVIV"><img src="common/galileocomputing_openbook.gif" width="200" height="56" border="0" alt="Galileo Computing < openbook >" title="Galileo Computing < openbook >"></a></td>
<td width="80" height="74"><a href="http://www.galileocomputing.de/?GPP=opjiVIV"><img src="common/galileocomputing.gif" border="0" alt="Galileo Computing - Professionelle Bücher. Auch für Einsteiger." title="Galileo Computing - Professionelle Bücher. Auch für Einsteiger."></a></td>
</tr>
</table>
<div align="right"><a href="http://www.galileocomputing.de/?GPP=opjiVIV" class="navnav">Professionelle Bücher. Auch für Einsteiger.</a></div><br><table class="tbl" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="190" valign="top">
<table class="tbl1" border="0" cellpadding="3" cellspacing="0" width="190" align="left">
<tr>
<td class="tbl2"><a class="nav" href="index.htm#_top">Inhaltsverzeichnis</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_00_001.htm#mj58b119301920569a446c9c510503f310">Vorwort</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_01_001.htm#mja8fc5b7ad19fc7332bc66b09a8fda26e">1 Java ist auch eine Sprache</a></td>
</tr>
<tr>
<td><a class="navh" href="##mj313f67c98dc9ecaddfa2d8b80f057fd2">2 Sprachbeschreibung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_03_001.htm#mjcd3b5720e8605484942e3476a1075bdf">3 Klassen und Objekte</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_04_001.htm#mj71fbc84ad33a281b9352b0b19fae2fb2">4 Der Umgang mit Zeichenketten</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_05_001.htm#mj005cd8e604aefc3ae72b92880fcee5c6">5 Eigene Klassen schreiben</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_06_001.htm#mj6f6b47453043c38837bfc32154a97968">6 Exceptions</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_07_001.htm#mjc4a1f6f3499a02fb64fe89046739edca">7 Generics&lt;T&gt;</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_08_001.htm#mj46e914488628367f5dfc0a62c3a78a53">8 Äußere.innere Klassen</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_09_001.htm#mj94af2b90e8a2dad6c1ef67255f89a137">9 Besondere Klassen der Java SE</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_10_001.htm#mjcae20f50ffbc015d0b66861e7087af9b">10 Architektur, Design und angewandte Objektorientierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_11_001.htm#mj60bc6a007ae9b8657949f3e91d96df3d">11 Die Klassenbibliothek</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_12_001.htm#mj0ce00eb41aae2b084534019cf6edc3b6">12 Bits und Bytes und Mathematisches</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_13_001.htm#mj245f5f8d5a858b46462d64e9b9c0786b">13 Datenstrukturen und Algorithmen</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_14_001.htm#mj8c6f381221d805dd6fbe480731ac0c58">14 Threads und nebenläufige Programmierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_15_001.htm#mjbe3ed0989722396930966f95deeb2497">15 Raum und Zeit</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_16_001.htm#mj78bd405fb0de0cff099c06255fe36853">16 Dateien, Verzeichnisse und Dateizugriffe</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_17_001.htm#mjb420b02f4ccf65226f7271e48cefa05d">17 Datenströme</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_18_001.htm#mjedab16f1a9cc168eda4a24416359e0b9">18 Die eXtensible Markup Language (XML)</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_19_001.htm#mjc8f47f7f51ac3795c46c4544f391b02e">19 Grafische Oberflächen mit Swing</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_20_001.htm#mj25cc7d47e476b8b1a183a10ee741dbaa">20 Grafikprogrammierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_21_001.htm#mjea7bcdd596c8bd25b078a00221a01a75">21 Netzwerkprogrammierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_22_001.htm#mjde622db61608a627262a27ecb377d675">22 Verteilte Programmierung mit RMI</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_23_001.htm#mj23bf599d65364bcd05d06a34cb5593bf">23 JavaServer Pages und Servlets</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_24_001.htm#mja621f3b4a74c7fa576b4a58b1614041e">24 Datenbankmanagement mit JDBC</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_25_001.htm#mja2e217bf5724cc65eba184a2af8b79cf">25 Reflection und Annotationen</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_26_001.htm#mjb47dd6e0a309b7e78cad68f6b5de9319">26 Dienstprogramme für die Java-Umgebung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_27_001.htm#mjf59db36d9280a70e0d3d196e9bf160f5">A Die Begleit-DVD</a></td>
</tr>
<tr>
<td><a class="navnav" href="stichwort.htm#_top">Stichwort</a></td>
</tr>
<tr>
<td><br><a href="http://download2.galileo-press.de/openbook/galileocomputing_javainsel9.zip" class="navnav"><strong>Download:</strong><br>- ZIP, ca. 20,5 MB</a></td>
</tr>
<tr>
<td><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV" class="navnav">Buch bestellen</a></td>
</tr>
<tr>
<td><a class="navnav" href="#kommentar">Ihre Meinung?</a><br><br></td>
</tr>
</table>
</td>
<td width="10"><img src="common/spacer10.gif" width="10" height="10" alt="Spacer"></td>
<td width="85%" valign="top" align="center"><div align="center">
<table width="98%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="javainsel_02_007.htm" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a href="http://www.galileocomputing.de/?GPP=opjiVIV" class="navnav">Galileo Computing /</a><a href="http://www.galileocomputing.de/katalog/openbook/?GPP=opjiVIV" class="navnav"> &lt;openbook&gt; /</a><a href="index.htm" class="navnav"> Java-Insel</a></div></td>
<td align="right" width="25%"><div align="right"><a href="javainsel_02_009.htm" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" valign="top"><table width="100%" border="0" cellpadding="10" cellspacing="0" class="box">
<tr>
<td colspan="2"><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV" class="buchtitel">Java ist auch eine Insel</a><span class="autor"> von Christian Ullenboom </span><br><span class="untertitel">Das umfassende Handbuch</span></td>
</tr>
<tr>
<td valign="top" width="211"><dl>
<dt><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV" class="navnav"><img src="common/9783836215060.gif" border="0" alt="Buch: Java ist auch eine Insel" title="Buch: Java ist auch eine Insel"></a></dt>
<dd><br><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV"><span class="autor"><strong>Java ist auch eine Insel</strong><br>geb., mit DVD<br>1482 S., 49,90 Euro<br>Galileo Computing<br>ISBN 978-3-8362-1506-0</span></a></dd>
</dl></td>
<td width="80%"><table border="0">
<tr>
<td valign="baseline"><img src="common/pfeil_u.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="3" class="kap"><strong><a href="javainsel_02_001.htm#mj313f67c98dc9ecaddfa2d8b80f057fd2" class="navnav">2 Sprachbeschreibung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_02_001.htm#mj4c39ccec48a76ae30226f3f932121636" class="navnav">2.1 Elemente der Programmiersprache Java</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_001.htm#mj5b64c72b27b5a6ab0a66c5e72bb198cf" class="navnav">2.1.1 Token</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_001.htm#mjecb61a9b6f9af4b3942699e5e3bd68d1" class="navnav">2.1.2 Textkodierung durch Unicode-Zeichen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_001.htm#mjc69b2ac175f46ac3528ed4a2a25453bc" class="navnav">2.1.3 Literale</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_001.htm#mjea18182a41b645e6fbe90ee51045338f" class="navnav">2.1.4 Bezeichner</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_001.htm#mj6c435823530664f454748e31c7501bf7" class="navnav">2.1.5 Reservierte Schlüsselwörter</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_001.htm#mj5a0b15f1dc322e8b94e434a98bb500b4" class="navnav">2.1.6 Zusammenfassung der lexikalischen Analyse</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_001.htm#mj60051b94eb75aff76b77b34080d60b4c" class="navnav">2.1.7 Kommentare</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_02_002.htm#mje6cf7db9d2efcd52e5d81fc832f8b139" class="navnav">2.2 Anweisungen formen Programme</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_002.htm#mj41f7748a6816ed4f9e4936292f838c48" class="navnav">2.2.1 Was sind Anweisungen?</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_002.htm#mjf3869f794db9bf16bbaf9a79668c17d3" class="navnav">2.2.2 Klassendeklaration</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_002.htm#mjd13c9e060033d31199f1482b71660888" class="navnav">2.2.3 Die Reise beginnt am main()</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_002.htm#mjb81c2e28c2fe110a0b7a2ef9da7d10a4" class="navnav">2.2.4 Der erste Methodenaufruf: println()</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_002.htm#mj17be0d5f85aa24f9db2bee70ea355e9c" class="navnav">2.2.5 Atomare Anweisungen und Anweisungssequenzen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_002.htm#mje4439fc88c3da817f3de3838c4d83baa" class="navnav">2.2.6 Mehr zu print(), println() und printf() für Bildschirmausgaben</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_002.htm#mj31d33be82ee48d560fea2597234eb467" class="navnav">2.2.7 Die API-Dokumentation</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_002.htm#mj2d3ffeacbc5d2d61393972d4204f73c4" class="navnav">2.2.8 Ausdrucksanweisung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_002.htm#mj641d7792a19c51b88ef2fe06bf079712" class="navnav">2.2.9 Erste Idee der Objektorientierung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_002.htm#mj5892f57ef257e41d40b817935ca8595f" class="navnav">2.2.10 Modifizierer</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_02_003.htm#mjfa63996892f690e96d6bdc12b0045e24" class="navnav">2.3 Datentypen, Typisierung, Variablen und Zuweisungen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_003.htm#mj2a9abd617099b9fd801bd838feae09cc" class="navnav">2.3.1 Primitive Datentypen im Überblick</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_003.htm#mj2eae18508a8cdb7b415dcb04a19eba9f" class="navnav">2.3.2 Variablendeklarationen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_003.htm#mje0a1a7aa587e4ef38dc8a8d84cfcd506" class="navnav">2.3.3 Variablendeklaration mit Wertinitialisierung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_003.htm#mjb5488e9f0c7c9d35049e1d883a370c30" class="navnav">2.3.4 Zuweisungsoperator</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_003.htm#mjf64878f5c2fa2b31ae20a20c7ef2d2e2" class="navnav">2.3.5 Wahrheitswerte</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_003.htm#mjc11164cdd5eedb52b21ddd19b16f0385" class="navnav">2.3.6 Ganzzahlige Datentypen und Literale</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_003.htm#mjbd61f831aaea6b174b7a007af1a67476" class="navnav">2.3.7 Das binäre (Basis 2), oktale (Basis 8), hexadezimale (Basis 16) Stellenwertsystem *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_003.htm#mjaed1f301e088df504ed1f24dae0d0caf" class="navnav">2.3.8 Die Fließkommazahlen »float« und »double«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_003.htm#mj45c99ccfafcac85ec9c0e87222047c6f" class="navnav">2.3.9 Alphanumerische Zeichen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_003.htm#mj76f1b77014dafca1b945790800d9aedd" class="navnav">2.3.10 Gute Namen, schlechte Namen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_02_004.htm#mjb044d5eb156360a6192e0bde3eeaceb0" class="navnav">2.4 Blöcke, Initialisierung und Sichtbarkeit</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_004.htm#mj266d7a655884ea92d24ba0aa380f56f3" class="navnav">2.4.1 Gruppieren von Anweisungen mit Blöcken</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_004.htm#mjeb2ef4723a3c26e8c0a6ae1eec3a5626" class="navnav">2.4.2 Initialisierung von lokalen Variablen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_004.htm#mj47f0fa7692df8df688cd6a8a6cf9fefd" class="navnav">2.4.3 Sichtbarkeit und Gültigkeitsbereich</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_02_005.htm#mj727e5a27eac7c9b15b5799f50c4a2895" class="navnav">2.5 Ausdrücke, Operanden und Operatoren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_005.htm#mj9a3af0f9509c60c1a268346af4c9aedb" class="navnav">2.5.1 Ausdrücke</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_005.htm#mj998e5fa30c9c8bd8a0d12f9b09f3f71d" class="navnav">2.5.2 Arithmetische Operatoren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_005.htm#mj03da32a2fe369215529830de87a204d1" class="navnav">2.5.3 Unäres Minus und Plus</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_005.htm#mj63bbbb7a2e0d9190bab41140a3bb33c2" class="navnav">2.5.4 Zuweisung mit Operation</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_005.htm#mj54700b6f99a3a2cf4f2a38465dc17289" class="navnav">2.5.5 Präfix- oder Postfix-Inkrement und -Dekrement</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_005.htm#mjb37eafd775d803d67baf4aae75ee97d7" class="navnav">2.5.6 Die relationalen Operatoren und die Gleichheitsoperatoren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_005.htm#mje27fd167a2ddda300630b8d5c405d763" class="navnav">2.5.7 Logische Operatoren: Nicht, Und,Oder, Xor</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_005.htm#mj001aa1d35c1746f2106c8a28aff843e8" class="navnav">2.5.8 Der Rang der Operatoren in der Auswertungsreihenfolge</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_005.htm#mj714856e56857d03d2d050f84d418981d" class="navnav">2.5.9 Die Typanpassung (das Casting)</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_005.htm#mj93a46c1206bdba6ff4c9adf47674d2a7" class="navnav">2.5.10 Überladenes Plus für Strings</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_005.htm#mj9431e0ffd2d053ce73e865c35801f571" class="navnav">2.5.11 Operator vermisst *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_02_006.htm#mj3530d43fab0c366ff75b1414feef64e3" class="navnav">2.6 Bedingte Anweisungen oder Fallunterscheidungen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_006.htm#mj5c02f22dd3cf727da8cf465e7a3ec9a0" class="navnav">2.6.1 Die if-Anweisung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_006.htm#mjb94647aaf953d4eac34b42a303575c94" class="navnav">2.6.2 Die Alternative mit einer if-else-Anweisung wählen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_006.htm#mj0ed4e5c52acd8f230d31a246ccd268c6" class="navnav">2.6.3 Der Bedingungsoperator</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_006.htm#mj448e6960f284a4beda96b23e994ebd5e" class="navnav">2.6.4 Die switch-Anweisung bietet die Alternative</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_02_007.htm#mjb517285509ecebe1bb38c15fc43eb4c2" class="navnav">2.7 Schleifen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_007.htm#mja1bc0775bbd3451450d183be28eeb3eb" class="navnav">2.7.1 Die while-Schleife</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_007.htm#mj6e1455d87e650c79a9c4af1df370cf26" class="navnav">2.7.2 Die do-while-Schleife</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_007.htm#mjdcbb2e90942d428b2c033d90ed115f3b" class="navnav">2.7.3 Die for-Schleife</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_007.htm#mj0a12edb4c2de73996536d2a0cfa93253" class="navnav">2.7.4 Schleifenbedingungen und Vergleiche mit ==</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_007.htm#mj86b3106463107c046e4f10288be23d6f" class="navnav">2.7.5 Ausbruch planen mit break und Wiedereinstieg mit »continue«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_02_007.htm#mjb66a4e86916302730701a5ea728c4602" class="navnav">2.7.6 »break« und »continue« mit Marken *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="#mjc2d5868bd7bba72c8f470a1eff29b8f8" class="navh">2.8 Methoden einer Klasse</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj03b21193a0b840663819e08cdcf6aa9a" class="navh">2.8.1 Bestandteil einer Methode</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj6cd639c6b783b1a61957698d1c4d5428" class="navh">2.8.2 Signatur-Beschreibung in der Java-API</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mje562fc58793dd3e128a981b070731e31" class="navh">2.8.3 Aufruf einer Methode</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjd30f308b95326a708d51f03f631ca749" class="navh">2.8.4 Methoden ohne Parameter deklarieren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj2836d5713aaa7620f0e534af0f44159c" class="navh">2.8.5 Statische Methoden (Klassenmethoden)</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj9b0d4e5b321975f9fc5fd010a7b19af8" class="navh">2.8.6 Parameter, Argument und Wertübergabe</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mje82aa3de4956da1e1f98332c14f73c54" class="navh">2.8.7 Methoden vorzeitig mit return beenden</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj8f915a85179c256c6ea97f1a4c2c6640" class="navh">2.8.8 Nicht erreichbarer Quellcode bei Methoden</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjd33fee2b0c0e1f589dc7bed1badb5329" class="navh">2.8.9 Rückgabewerte</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj021ec31631b9b7c44011343c7fbe8def" class="navh">2.8.10 Methoden überladen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjf8e7549c7c3a573dcfba78077f9cf7e1" class="navh">2.8.11 Vorgegebener Wert für nicht aufgeführte Argumente *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj93af18e3273e580bb7a4395eeec2f1f8" class="navh">2.8.12 Finale lokale Variablen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mje1fd0b8e4f3262cd2aa633ff59abaab5" class="navh">2.8.13 Rekursive Methoden *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mja99d7594870ad07a0d98217193f32790" class="navh">2.8.14 Die Türme von Hanoi *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_02_009.htm#mj5080aed8bdb6bf2ecab222e8a24e2514" class="navnav">2.9 Zum Weiterlesen</a></strong></td>
</tr>
</table><br></td>
</tr>
</table>
<table width="100%" cellpadding="20" cellspacing="0" border="0" bgcolor="#eeeeee">
<tr>
<td><div class="main"><a id="mjc2d5868bd7bba72c8f470a1eff29b8f8" name="mjc2d5868bd7bba72c8f470a1eff29b8f8"></a><a name="t21"></a><a name="t2t31"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div>
<h2 class="t2"><span class="cfett">2.8</span> Methoden einer Klasse  <a href="#t2t32"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><img src="common/15x15leer.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></h2>
<p>In objektorientierten Programmen interagieren zur Laufzeit Objekte miteinander und senden sich gegenseitig Nachrichten als Aufforderung, etwas zu machen. Diese Aufforderungen resultieren in einem Methodenaufruf, in dem Anweisungen stehen, die dann ausgeführt werden. Das Angebot eines Objekts, also das, was es »kann«, wird in Java durch Methoden ausgedrückt.</p>
<p>Wir haben schon mindestens eine Methode kennengelernt: <span class="clisting">println()</span>. Sie ist eine Methode vom <span class="clisting">out</span>-Objekt. Ein anderes Programmstück schickt nun eine Nachricht an das <span class="clisting">out</span>-Objekt, die <span class="clisting">println()</span>-Methode auszuführen. Im Folgenden werden wir den aktiven Teil des Nachrichtenversendens nicht mehr so genau betrachten, sondern wir sagen nur noch, dass eine Methode aufgerufen wird.</p>
<p>Für die Deklaration von Methoden gibt es drei Gründe:</p>
<ul class="gp">
<li>Wiederkehrende Programmteile sollen nicht immer wieder programmiert, sondern an einer Stelle angeboten werden. Änderungen an der Funktionalität lassen sich dann leichter durchführen, wenn der Code lokal zusammengefasst ist.</li>
</ul>
<ul class="gp">
<li>Komplexe Programme werden in kleine Teilprogramme zerlegt, damit die Komplexität des Programms heruntergebrochen wird. Damit ist der Kontrollfluss leichter zu erkennen.</li>
</ul>
<ul class="gp">
<li>Die Operationen einer Klasse, also das Angebot eines Objekts, sind ein Grund für Methodendeklarationen in einer objektorientierten Programmiersprache. Daneben gibt es aber noch weitere Gründe, die für Methoden sprechen. Sie werden im Folgenden erläutert.</li>
</ul><a id="mj03b21193a0b840663819e08cdcf6aa9a" name="mj03b21193a0b840663819e08cdcf6aa9a"></a><a name="t31"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t32"></a><h3 class="t3"><span class="cfett">2.8.1</span> Bestandteil einer Methode  <a href="#t2t33"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t31"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Eine Methode setzt sich aus mehreren Bestandteilen zusammen. Dazu gehören der <span class="ckursiv">Methodenkopf</span> (kurz <span class="ckursiv">Kopf</span>) und der <span class="ckursiv">Methodenrumpf</span> (kurz <span class="ckursiv">Rumpf</span>). Der Kopf besteht aus einem <span class="ckursiv">Rückgabetyp</span> (auch <span class="ckursiv">Ergebnistyp</span> genannt), dem <span class="ckursiv">Methodennamen</span> und einer optionalen <span class="ckursiv">Parameterliste</span>.</p>
<p>Nehmen wir die bekannte statische <span class="clisting">main()</span>-Methode:</p>
<div class="listing"><pre class="prettyprint">public static void main( String[] args )
{
  System.out.println( "Wie siehst du denn aus? Biste gerannt?" );
}</pre></div>
<p>Sie hat folgende Bestandteile:</p>
<ul class="gp">
<li>Die statische Methode liefert keine Rückgabe, daher ist der »Rückgabetyp« <span class="clisting">void</span>. (An dieser Stelle sollte bemerkt werden, dass <span class="clisting">void</span> in Java kein Typ ist.) <span class="clisting">void</span> heißt auf Deutsch übersetzt: »frei«, »die Leere« oder »Hohlraum«.</li>
</ul>
<ul class="gp">
<li>Der Methodenname ist <span class="clisting">main</span>.</li>
</ul>
<ul class="gp">
<li>Die Parameterliste ist <span class="clisting">String[] args</span>.</li>
</ul>
<ul class="gp">
<li>Der Rumpf besteht nur aus der Bildschirmausgabe.</li>
</ul><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Namenskonvention   </span>Methodennamen beginnen wie Variablennamen mit Kleinbuchstaben und werden in der gemischten Groß-/Kleinschreibung verfasst. Bezeichner dürfen nicht wie Schlüsselwörter heißen.[Das führte bei manchen Bibliotheken (JUnit sei hier als Beispiel genannt) zu Überraschungen. In Java 1.4 etwa wurde das Schlüsselwort <span class="clisting">assert</span> eingeführt, das JUnit als Methodenname wählte. Unzählige Zeilen Programmcode mussten daraufhin von <span class="clisting">assert()</span> nach<span class="clisting"> assertTrue()</span> konvertiert werden.] </p>
</td>
</tr>
</table><br><h4 class="t4">Die Signatur einer Methode</h4>
<p>Der Methodenname und die Parameterliste bestimmen die <span class="ckursiv">Signatur</span> einer Methode; der Rückgabetyp gehört nicht dazu. Die Parameterliste ist durch die Anzahl, die Reihenfolge und die Typen der Parameter beschrieben. Pro Klasse darf es nur eine Methode mit derselben Signatur geben, sonst meldet der Compiler einen Fehler. Da die Methoden void main( String[] args ) und String main( String[] arguments ) die gleiche Signatur (<span class="clisting">main</span>, <span class="clisting">String[]</span>) besitzen &#8211; die Namen der Parameter spielen keine Rolle &#8211;, können sie nicht zusammen in einer Klasse deklariert werden (später werden wir sehen, dass Unterklassen durchaus gewisse Sonderfälle zulassen).</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Duck-Typing   </span>Insbesondere Skriptsprachen, wie Python, Ruby oder Groovy, erlauben Methodendeklarationen ohne Parametertyp, sodass die Methoden mit unterschiedlichen Argumenttypen aufgerufen werden können:</p>
<div class="listing"><pre class="prettyprint">add( a, b ) return a + b</pre></div>
<p class="BStandard">Aufgrund des nicht bestimmten Parametertyps lässt sich die Methode mit Ganzzahlen, Fließkommazahlen oder Strings aufrufen. Es ist die Aufgabe der Laufzeitumgebung, diesen dynamischen Typ zu erkennen und die Addition auf dem konkreten Typ auszuführen. In Java ist das nicht möglich. Der Typ muss überall stehen.</p>
</td>
</tr>
</table><br><a id="mj6cd639c6b783b1a61957698d1c4d5428" name="mj6cd639c6b783b1a61957698d1c4d5428"></a><a name="t32"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t33"></a><h3 class="t3"><span class="cfett">2.8.2</span> Signatur-Beschreibung in der Java-API  <a href="#t2t34"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t32"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>In der Java-Dokumentation sind alle Methoden mit ihren Rückgaben und Parametern genau definiert. Betrachten wir die Dokumentation der statischen Methode <span class="clisting">max()</span> der Klasse <span class="clisting">Math</span>:</p>
<div class="bildbox">
<p><a name="IDA4YYD"></a><a onClick="OpenWin('bilder/api_doku_mathmax.gif','Abbildung',800,800)"><img border="0" src="bilderklein/kleinapi_doku_mathmax.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 2.7    </strong>Die Online-API-Dokumentation für Math.max()</p>
<p>Die Hilfe gibt Informationen über die komplette Signatur der Methode. Der Rückgabetyp ist ein <span class="clisting">double</span>, die statische Methode heißt <span class="clisting">max()</span>, und sie erwartet genau zwei <span class="clisting">double</span>-Zahlen. Verschwiegen haben wir die Schlüsselwörter <span class="clisting">public static</span> &#8211; die Modifizierer. <span class="clisting">public</span> gibt die Sichtbarkeit an und sagt, wer diese Methode nutzen kann. Im Fall von <span class="clisting">public</span> bedeutet es, dass jeder diese Methode verwenden kann. Das Gegenteil ist <span class="clisting">private</span>: In dem Fall kann nur das Objekt selbst diese Methode nutzen. Das ist sinnvoll, wenn Methoden benutzt werden, um die Komplexität zu verkleinern und Teilprobleme zu lösen. Private Methoden werden in der Regel nicht in der Hilfe angezeigt, da sie ein Implementierungsdetail sind. Das Schlüsselwort <span class="clisting">static</span> zeigt an, dass sich die Methode mit dem Klassennamen nutzen lässt, also kein Exemplar eines Objekts nötig ist.</p>
<p>Es gibt Methoden, die noch andere Modifizierer und eine erweiterte Signatur besitzen. Ein weiteres Beispiel aus der API:</p>
<div class="bildbox">
<p><a name="IDAUZYD"></a><a onClick="OpenWin('bilder/api_doku_serversocket.gif','Abbildung',800,800)"><img border="0" src="bilderklein/kleinapi_doku_serversocket.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 2.8    </strong>Ausschnitt aus der API-Dokumentation für die Klasse »ServerSocket«</p>
<p>Die Sichtbarkeit dieser Methode ist <span class="clisting">protected</span>. Das bedeutet: Nur abgeleitete Klassen und Klassen im gleichen Verzeichnis (Paket) können diese Methode nutzen. Ein zusätzlicher Modifizierer ist <span class="clisting">final</span>, der in einer Vererbung der Unterklasse nicht erlaubt, die Methode zu überschreiben und ihr neuen Programmcode zu geben. Zum Schluss folgt hinter dem Schlüsselwort <span class="clisting">throws</span> eine Ausnahme. Diese sagt etwas darüber aus, welche Fehler die Methode verursachen kann und worum sich der Programmierer kümmern muss. Im Zusammenhang mit der Vererbung werden wir noch über <span class="clisting">protected</span> und <span class="clisting">final</span> sprechen. Dem Ausnahmezustand widmen wir Kapitel 6, »Exceptions«. Die Dokumentation zeigt mit »Since: JDK 1.1« an, dass es die Methode seit Java 1.1 gibt. Die Information kann auch an der Klasse festgemacht sein.</p><a id="mje562fc58793dd3e128a981b070731e31" name="mje562fc58793dd3e128a981b070731e31"></a><a name="t33"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t34"></a><h3 class="t3"><span class="cfett">2.8.3</span> Aufruf einer Methode  <a href="#t2t35"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t33"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Da eine Methode immer einer Klasse oder einem Objekt zugeordnet ist, muss der Eigentümer beim Aufruf angegeben werden. Im Fall von <span class="clisting">System.out.println()</span> ist <span class="clisting">println()</span> eine Methode vom <span class="clisting">out</span>-Objekt. Wenn wir das Maximum zweier Fließkommazahlen mit <span class="clisting">Math.max(a, b)</span> bilden, dann ist <span class="clisting">max()</span> eine (statische) Methode der Klasse <span class="clisting">Math</span>. Für den Aufrufer ist damit immer ersichtlich, wer diese Methode anbietet, also auch, wer diese Nachricht entgegennimmt. Was der Aufrufer nicht sieht, ist die Arbeitsweise der Methode. Der Methodenaufruf verzweigt in den Programmcode, aber der Aufrufer weiß nicht, was dort geschieht. Er betrachtet nur das Ergebnis.</p>
<p>Die aufgerufene Methode wird mit ihrem Namen genannt. Die Parameterliste wird durch ein Klammerpaar umschlossen. Diese Klammern müssen auch dann gesetzt werden, wenn die Methode keine Parameter enthält. Eine Methode wie <span class="clisting">System.out.println()</span> gibt nichts als Ergebnis einer Berechnung zurück. Anders ist die statische Methode <span class="clisting">max()</span>; sie liefert ein Ergebnis. Damit ergeben sich vier unterschiedliche Typen von Methoden:</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 2.15    </strong>Methoden mit Rückgabewerten und Parametern</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">Methode</span>
</td>
<td class="tabellenkopf"><span class="cfett">Ohne Rückgabewert</span>
</td>
<td class="tabellenkopf"><span class="cfett">Mit Rückgabewert</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p>ohne Parameter</p>
</td>
<td class="tabellentext">
<p><span class="clisting">System.out.println()</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">System.currentTimeMillis()</span></p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p>mit Parameter</p>
</td>
<td class="tabellentext">
<p><span class="clisting">System.out.println(4)</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">Math.max(12, 33)</span></p>
</td>
</tr>
</table><br><p>Die statische Methode <span class="clisting">System.currentTimeMillis()</span> gibt die Anzahl der verstrichenen Millisekunden ab dem 1.1.1970 als <span class="clisting">long</span> zurück.</p><a id="mjd30f308b95326a708d51f03f631ca749" name="mjd30f308b95326a708d51f03f631ca749"></a><a name="t34"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t35"></a><h3 class="t3"><span class="cfett">2.8.4</span> Methoden ohne Parameter deklarieren  <a href="#t2t36"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t34"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Die einfachste Methode besitzt keinen Rückgabewert und keine Parameter. Der Programmcode steht in geschweiften Klammern hinter dem Kopf und bildet damit den Körper der Methode. Gibt die Methode nichts zurück, dann wird <span class="clisting">void</span> vor den Methodennamen geschrieben. Falls die Methode etwas zurückgibt, wird der Typ der Rückgabe an Stelle von <span class="clisting">void</span> geschrieben.</p>
<p>Schreiben wir eine statische Methode ohne Rückgabe und Parameter, die etwas auf dem Bildschirm ausgibt:</p>
<p class="tabunter"><strong>Listing 2.23    </strong>FriendlyGreeter.java</p>
<div class="listing"><pre class="prettyprint">class FriendlyGreeter
{
 <span class="cfett"> static</span> void<span class="cfett"> greet()</span>
  {
    System.out.println( "Guten Morgen. Oh, und falls wir uns nicht mehr" +
                        " sehen, guten Tag, guten Abend und gute Nacht!" );
  }

  public static void main( String[] args )
  {
   <span class="cfett"> greet();</span>
  }
}</pre></div><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Tipp   </span>Die Vergabe eines Methodennamens ist gar nicht so einfach. Nehmen wir zum Beispiel an, wir wollen eine Methode schreiben, die eine Datei kopiert. Spontan kommen uns zwei Wörter in den Sinn, die zu einem Methodennamen verbunden werden wollen: »file« und »copy«. Doch in welcher Kombination? Soll es <span class="clisting">copyFile()</span> oder <span class="clisting">fileCopy()</span> heißen? Wenn dieser Konflikt entsteht, sollte das Verb die Aktion anführen, unsere Wahl also auf <span class="clisting">copyFile()</span> fallen. Methodennamen sollten immer das Tätigkeitswort vorne haben und das Was, das Objekt, an zweiter Stelle.</p>
</td>
</tr>
</table><br><p><div class="eclipse"><img src="common/eclipseicon.gif" align="top" width="53" height="23" alt="Eclipse" title="Eclipse"></div>Eine gedrückte 
    <span class="tastenkappe">Strg</span>
  -Taste und ein Mausklick auf einen Bezeichner lässt Eclipse zur Deklaration springen. Ein Druck auf 
    <span class="tastenkappe">F3</span>
   hat den gleichen Effekt. Steht der Cursor in unserem Beispiel auf dem Methodenaufruf <span class="clisting">greet()</span> und wird 
    <span class="tastenkappe">F3</span>
   gedrückt, dann springt Eclipse zur Definition in Zeile 3 und hebt den Methodennamen hervor.</p><a id="mj2836d5713aaa7620f0e534af0f44159c" name="mj2836d5713aaa7620f0e534af0f44159c"></a><a name="t35"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t36"></a><h3 class="t3"><span class="cfett">2.8.5</span> Statische Methoden (Klassenmethoden)  <a href="#t2t37"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t35"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Bisher arbeiten wir nur mit statischen Methoden (auch Klassenmethoden genannt). Das Besondere daran ist, dass die statischen Methoden nicht an einem Objekt hängen und daher immer ohne explizit erzeugtes Objekt aufgerufen werden können. Das heißt, statische Methoden gehören zu Klassen an sich und sind nicht mit speziellen Objekten verbunden. Am Aufruf unserer statischen Methode <span class="clisting">greet()</span> lässt sich ablesen, dass hier kein Objekt gefordert ist, mit dem die Methode verbunden ist. Das ist möglich, denn die Methode ist als <span class="clisting">static</span> deklariert, und innerhalb der Klasse lassen sich alle Methoden einfach mit ihrem Namen nutzen.</p>
<p>Statische Methoden müssen explizit mit dem Schlüsselwort <span class="clisting">static</span> kenntlich gemacht werden. Fehlt der Modifizierer <span class="clisting">static</span>, so deklarieren wir damit eine Objektmethode, die wir nur aufrufen können, wenn wir vorher ein Objekt angelegt haben. Das heben wir uns aber bis zum nächsten Kapitel, »Klassen und Objekte«, auf. Die Fehlermeldung sollte Ihnen aber keine Angst machen. Lassen wir von der <span class="clisting">greet()</span>-Deklaration das <span class="clisting">static</span> weg und ruft die statische <span class="clisting">main()</span>-Methode wie jetzt ohne Aufbau eines Objekts die dann nicht mehr statische Methode <span class="clisting">greet()</span> auf, so gibt es den Compilerfehler "<span class="clisting">Cannot make a static reference to the non-static method greet() from the type FriendlyGreeter</span>".</p>
<p>Ist die statische Methode in der gleichen Klasse wie der Aufrufer deklariert &#8211; in unserem Fall <span class="clisting">main()</span> und <span class="clisting">greet()</span> &#8211;, so ist der Aufruf allein mit dem Namen der Methode eindeutig. Befinden sich jedoch Methodendeklaration und Methodenaufruf in unterschiedlichen Klassen, so muss der Aufrufer den Namen der Klasse nennen; wir haben so etwas schon einmal bei Aufrufen wie <span class="clisting">Math.max()</span> gesehen.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">class<span class="cfett"> FriendlyGreeter</span>
{<span class="cfett">
 static</span> void greet()
 {
  System.out.println( "Guten Morgen…" );
 }
}</pre></div>
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">class FriendlyGreeterCaller
{
  public static void main( String[] args )
  {
   <span class="cfett"> FriendlyGreeter.greet</span>();
  }
}</pre></div>
</td>
</tr>
</table><br><a id="mj9b0d4e5b321975f9fc5fd010a7b19af8" name="mj9b0d4e5b321975f9fc5fd010a7b19af8"></a><a name="t36"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t37"></a><h3 class="t3"><span class="cfett">2.8.6</span> Parameter, Argument und Wertübergabe  <a href="#t2t38"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t36"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Einer Methode können Werte übergeben werden, die sie dann in ihre Arbeitsweise einbeziehen kann. Der Methode <span class="clisting">println(2001)</span> ist zum Beispiel ein Wert übergeben worden. Sie wird damit zur <span class="ckursiv">parametrisierten Methode</span>.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Werfen wir einen Blick auf die Methodendeklaration <span class="clisting">printMax()</span>, die den größeren der beiden übergebenen Werte auf dem Bildschirm ausgibt.</p>
<div class="listing"><pre class="prettyprint">static void printMax( <span class="cfett">double a, double b</span> )
{
  if ( <span class="cfett">a</span> &gt; <span class="cfett">b</span> )
    System.out.println( <span class="cfett">a</span> );
  else
    System.out.println( <span class="cfett">b</span> );
}</pre></div>
</td>
</tr>
</table><br><p>Um die an Methoden übergebenen Werte anzusprechen, gibt es <span class="ckursiv">formale Parameter</span>. Von unserer statischen Methode <span class="clisting">printMax()</span> sind <span class="clisting">a</span> und <span class="clisting">b</span> die formalen Parameter der Parameterliste. Jeder Parameter wird durch ein Komma getrennt aufgelistet, wobei für jeden Parameter der Typ angegeben sein muss; eine Kurzform wie bei der sonst üblichen Variablendeklaration wie <span class="clisting">double a, b</span> ist nicht möglich. Jede Parametervariable einer Methodendeklaration muss natürlich einen anderen Namen tragen.</p>
<h4 class="t4">Argumente (aktuelle Parameter)</h4>
<p>Der Aufrufer der Methode muss für jeden Parameter ein Argument angeben. Die im Methodenkopf deklarierten Parameter sind letztendlich lokale Variablen im Rumpf der Methode. Beim Aufruf initialisiert die Laufzeitumgebung die lokalen Variablen mit den an die Methode übergebenen Argumenten. Rufen wir unsere parametrisierte Methode etwa mit <span class="clisting">printMax(10, 20)</span> auf, so sind die Literale 10 und 20 <span class="ckursiv">Argumente</span> (aktuelle Parameter der Methode). Beim Aufruf der Methode setzt die Laufzeitumgebung die Argumente in die lokalen Variablen, kopiert also den Wert 10 in die Parametervariable <span class="clisting">a</span> und 20 in die Parametervariable <span class="clisting">b</span>. Innerhalb des Methodenkörpers gibt es so Zugriff auf die von außen übergebenen Werte.</p>
<p>Das Ende des Blocks bedeutet automatisch das Ende für die Parametervariablen. Der Aufrufer weiß auch nicht, wie die Parametervariablen heißen. Eine Typanpassung von <span class="clisting">int</span> auf <span class="clisting">double</span> nimmt der Compiler in unserem Fall automatisch vor. Die Argumente müssen vom Typ her natürlich passen, und es gelten die für die Typanpassung bekannten Regeln.</p>
<div class="bildbox">
<p><a name="IDA3FZD"></a><a onClick="OpenWin('bilder/argument_parameter.gif','Abbildung',800,800)"><img border="0" src="bilderklein/kleinargument_parameter.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 2.9    </strong>Die Begriffe Parameter und Argument</p>
<h4 class="t4">Wertübergabe per Call by Value</h4>
<p>Wenn eine Methode aufgerufen wird, dann gibt es in Java ein bestimmtes Verfahren, in dem jedes Argument einer Parametervariablen übergeben wird. Diese Technik heißt <span class="ckursiv">Parameterübergabemechanismus</span>. Viele Programmiersprachen verfügen oft über eine ganze Reihe von verwirrenden Möglichkeiten. Java kennt nur einen einfachen Mechanismus der <span class="ckursiv">Wertübergabe</span> (engl. <span class="ckursiv">call by value</span>, selten auch <span class="ckursiv">copy by value</span> genannt). Ein Beispiel zum Methodenaufruf macht das deutlich:</p>
<div class="listing"><pre class="prettyprint">int i = 2;<span class="cfett">
printMax( 10, i );</span></pre></div>
<p>Unsere aufgerufene Methode <span class="clisting">printMax(double a, double b)</span> bekommt zunächst 10 in die Variable <span class="clisting">a</span> kopiert und dann den Inhalt der Variablen <span class="clisting">i</span> (in unserem Beispiel 2) in <span class="clisting">b</span>. Auf keinen Fall gibt der Aufrufer Informationen über den Speicherbereich von <span class="clisting">i</span> an die Methode mit. In dem Moment, in dem die Methode aufgerufen wird, erfragt die Laufzeitumgebung die Belegung von <span class="clisting">i</span> und initialisiert damit die Parametervariable <span class="clisting">b</span>. Ändert <span class="clisting">printMax()</span> die Variable <span class="clisting">b</span>, so ändert dies nur die lokale Variable <span class="clisting">b</span> (überschreibt also 2), aber die Änderung in der Methode ist für das außenstehende <span class="clisting">i</span> ohne Konsequenz; <span class="clisting">i</span> bleibt weiterhin bei 2. Wegen dieser Aufrufart kommt auch der Name »copy by value« zustande. Lediglich der Wert wird übergeben (kopiert) und kein Verweis auf die Variable. [… wie dies Referenzen in C++ tun.
] </p>
<h4 class="t4">Auswertung der Argumentliste von links nach rechts *</h4>
<p>Bei einem Methodenaufruf werden erst alle Argumente ausgewertet und anschließend der Methode übergeben. Dies bedeutet im Besonderen, dass Untermethoden ausgewertet und Zuweisungen gemacht werden können. Fehler führen dann zu einem Abbruch des Methodenaufrufs. Bis zum Fehler werden alle Ausdrücke ausgewertet.</p><a id="mje82aa3de4956da1e1f98332c14f73c54" name="mje82aa3de4956da1e1f98332c14f73c54"></a><a name="t37"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t38"></a><h3 class="t3"><span class="cfett">2.8.7</span> Methoden vorzeitig mit return beenden  <a href="#t2t39"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t37"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Läuft eine Methode bis zum Ende durch, dann ist die Methode damit beendet, und es geht zurück zum Aufrufer. In Abhängigkeit von einer Bedingung kann eine Methode jedoch vor dem Ende des Ablaufs mit einer <span class="clisting">return</span>-Anweisung beendet werden. Das ist nützlich bei Methoden, die abhängig von Parametern vorzeitig aussteigen wollen. Wir können uns vorstellen, dass vor dem Ende der Methode automatisch ein verstecktes <span class="clisting">return</span> steht.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Eine statische Methode <span class="clisting">printSqrt()</span> soll die Wurzel einer Zahl auf dem Bildschirm ausgeben. Bei Zahlen kleiner null erscheint eine Meldung, und die Methode wird verlassen. Andernfalls wird die Wurzelberechnung durchgeführt:</p>
<div class="listing"><pre class="prettyprint">static void printSqrt( double d )
{
  if ( d &lt; 0 )
  {
    System.out.println( "Keine Wurzel aus negativen Zahlen!" );
    <span class="cfett">return;</span>
  }
  System.out.println( Math.sqrt( d ) );
}</pre></div>
<p class="BStandard">Die Realisierung wäre natürlich auch mit einer <span class="clisting">else</span>-Anweisung möglich gewesen.</p>
</td>
</tr>
</table><br><p>Eigene Methoden können natürlich wie Bibliotheksmethoden heißen, da sie zu unterschiedlichen Klassen gehören.</p><a id="mj8f915a85179c256c6ea97f1a4c2c6640" name="mj8f915a85179c256c6ea97f1a4c2c6640"></a><a name="t38"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t39"></a><h3 class="t3"><span class="cfett">2.8.8</span> Nicht erreichbarer Quellcode bei Methoden  <a href="#t2t310"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t38"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Folgt direkt hinter einer <span class="clisting">return</span>-Anweisung Quellcode, so ist dieser nicht erreichbar &#8211; im Sinne von nicht ausführbar. <span class="clisting">return</span> beendet also immer die Methode und kehrt zum Aufrufer zurück. Folgt nach dem <span class="clisting">return</span> noch Quelltext, meldet der Compiler einen Fehler:</p>
<div class="listing"><pre class="prettyprint">public static void main( String[] args )
{
  int i = 1;
 <span class="cfett"> return;</span>
 <span class="cfett"> i = 2;</span>              // Unreachable code!
}</pre></div>
<p>Reduzieren wir eine Anweisung bis auf das Nötigste, das Semikolon, so führt dies bisweilen zu amüsanten Ergebnissen:</p>
<div class="listing"><pre class="prettyprint">public static void main( String[] args )
{
  ;return;<span class="cfett">;</span>
}</pre></div>
<p>Das Beispiel enthält zwei Null-Anweisungen: eine vor dem <span class="clisting">return</span> und eine dahinter. Doch das zweite Semikolon hinter dem <span class="clisting">return</span> ist unzulässig, da es eine nicht erreichbare Anweisung darstellt.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Tipp   </span>In manchen Fällen ist ein <span class="clisting">return</span> in der Mitte einer Methode gewollt. Soll etwa eine Methode in der Testphase nicht komplett durchlaufen, sondern in der Mitte beendet werden, so können wir uns mit einer Anweisung wie <span class="clisting">if ( true ) return;</span> retten.</p>
</td>
</tr>
</table><br><a id="mjd33fee2b0c0e1f589dc7bed1badb5329" name="mjd33fee2b0c0e1f589dc7bed1badb5329"></a><a name="t39"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t310"></a><h3 class="t3"><span class="cfett">2.8.9</span> Rückgabewerte  <a href="#t2t311"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t39"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Statische Methoden wie <span class="clisting">Math.max()</span> liefern in Abhängigkeit von den Argumenten ein Ergebnis zurück. Für den Aufrufer ist die Implementierung egal; er abstrahiert und nutzt lediglich die Methode statt eines Ausdrucks. Damit Methoden Rückgabewerte an den Aufrufer liefern können, müssen zwei Dinge gelten:</p>
<ul class="gp">
<li>Eine Methodendeklaration bekommt einen Rückgabetyp ungleich <span class="clisting">void</span>.</li>
</ul>
<ul class="gp">
<li>Eine <span class="clisting">return</span>-Anweisung gibt einen Wert zurück.</li>
</ul><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Eine statische Methode bildet den Mittelwert und gibt diesen zurück:</p>
<div class="listing"><pre class="prettyprint">static <span class="cfett">double</span> avg( double x, double y )
{
  <span class="cfett">return (x + y) / 2;</span>
}</pre></div>
</td>
</tr>
</table><br><p>Fehlt der Ausdruck, und ist es nur ein einfaches <span class="clisting">return</span>, meldet der Compiler einen Programmfehler.</p>
<p>Obwohl einige Programmierer den Ausdruck gerne klammern, ist das nicht nötig. Klammern sollen lediglich komplexe Ausdrücke besser lesbar machen. Geklammerte Ausdrücke erinnern sonst nur an einen Methodenaufruf, und diese Verwechslungsmöglichkeit sollte bei Rückgabewerten nicht bestehen.</p>
<p>Der Rückgabewert muss an der Aufrufstelle nicht zwingend benutzt werden. Berechnet unsere Methode den Durchschnitt zweier Zahlen, ist es wohl eher ein Programmierfehler, den Rückgabewert nicht zu verwenden.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Was andere können   </span>Obwohl zwar mehrere Parameter deklariert werden können, kann doch nur höchstens ein Wert an den Aufrufer zurückgegeben werden. In der Programmiersprache Python lassen sich auch mehrere Werte über ein so genanntes Tupel zurückgeben. In Java lässt sich das über ein Array nachbilden.</p>
</td>
</tr>
</table><br><p><div class="eclipse"><img src="common/eclipseicon.gif" align="top" width="53" height="23" alt="Eclipse" title="Eclipse"></div>Eclipse erkennt, ob ein Rückgabetyp fehlt, und schlägt über 
    <span class="tastenkappe">Strg</span>
  +
    <span class="tastenkappe">1</span>
   einen passenden Typ vor.</p>
<h4 class="t4">Mehrere Ausstiegspunke mit return</h4>
<p>Für Methoden mit Rückgabewert gilt ebenso wie für <span class="clisting">void</span>-Methoden, dass es mehr als ein <span class="clisting">return</span> geben kann. Nach der Abarbeitung von <span class="clisting">return</span> geht es im Programmcode des Aufrufers wie bei den normalen <span class="clisting">void</span>-Methoden weiter.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>In <span class="clisting">if</span>-Anweisungen mit weiteren <span class="clisting">else</span>-<span class="clisting">if</span>-Alternativen und Rücksprung ist die Semantik oft die gleiche, wenn das <span class="clisting">else</span>-<span class="clisting">if</span> durch ein einfaches <span class="clisting">if</span> ersetzt wird. Der nachfolgende Programmcode zeigt das:</p>
<div class="listing"><pre class="prettyprint">if ( a == 1 )
  return 0;<span class="cfett">
else if</span> ( a == 2 )   // mit else
  return 1;</pre></div>
<p class="BStandard">Äquivalent ist:</p>
<div class="listing"><pre class="prettyprint">if ( a == 1 )
  return 0;

if ( a == 2 )        // ohne else
  return 1;</pre></div>
<p class="BStandard">Ist die erste Bedingung wahr, so endet die Methode, und das nachfolgende <span class="clisting">if</span> würde sowieso nicht beachtet.</p>
</td>
</tr>
</table><br><p>Wichtig ist nur, dass jeder denkbare Programmfluss mit einem <span class="clisting">return</span> beendet wird. Der Compiler verfügt über ein scharfes Auge und merkt, wenn es einen Programmpfad gibt, der nicht mit einem <span class="clisting">return</span>-Ausdruck beendet wird.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Die statische Methode <span class="clisting">isLastBitSet()</span> soll 0 zurückgeben, wenn das letzte Bit einer Ganzzahl nicht gesetzt ist, und 1, wenn es gesetzt ist. Den Bit-Test erledigt der Und-Operator:</p>
<div class="listing"><pre class="prettyprint">static int <span class="cfett">isLastBitSet</span>( int i )
{
  switch ( i &amp; 1 ) {
    case 0: return 0;
    case 1: return 1;
  }
}</pre></div>
<p class="BStandard">Die Methode lässt sich nicht übersetzen, obwohl ein Bit nur gesetzt oder nicht gesetzt sein kann &#8211; dazwischen gibt es nichts.</p>
</td>
</tr>
</table><br><p>Bei den Dingen, die für den Benutzer meistens offensichtlich sind, muss der Compiler passen, da er nicht hinter die Bedeutung sehen kann. Ähnliches würde für eine Wochen-Methode gelten, die mit einem Ganzzahl-Argument (0 bis 6) einen Wochentag als String zurückgibt. Wenn wir die Fälle 0 = Montag bis 6 = Sonntag beachten, dann kann in unseren Augen ein Wochentag nicht 99 sein. Der Compiler kennt aber die Methode nicht und weiß nicht, dass der Wertebereich beschränkt ist. Das Problem ließe sich mit einem <span class="clisting">default</span> leicht beheben.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Die statische Methode <span class="clisting">posOrNeg()</span> soll eine Zeichenkette mit der Information liefern, ob die übergebene Fließkommazahl positiv oder negativ ist:</p>
<div class="listing"><pre class="prettyprint">static String posOrNeg( double d )
{
  if ( d &gt;= 0 )
    return "pos";

  if ( d &lt; 0 )
    return "neg";
}</pre></div>
</td>
</tr>
</table><br><p>Überraschenderweise ist dieser Programmcode ebenfalls fehlerhaft. Denn obwohl er offensichtlich für positive oder negative Zahlen den passenden String zurückgibt, gibt es einen Fall, den diese Methode nicht abdeckt. Wieder gilt, dass der Compiler nicht erkennen kann, dass der zweite Ausdruck eine Negation des ersten sein soll. Es gibt aber noch einen zweiten Grund, der damit zu tun hat, dass es in Java spezielle Werte gibt, die keine Zahlen sind. Denn die Zahl <span class="clisting">d</span> kann auch eine NaN (Not a Number) als Quadratwurzel aus einer negativen Zahl sein. Diesen speziellen Wert überprüft <span class="clisting">posOrNeg()</span> nicht. Als Lösung für den einfachen Fall ohne NaN reicht es, aus dem zweiten <span class="clisting">if</span> und der Abfrage einfach ein <span class="clisting">else</span> zu machen oder die Anweisung auch gleich wegzulassen beziehungsweise mit dem Bedingungsoperator im Methodenrumpf kompakt zu schreiben: <span class="clisting">return d &gt;= 0 ? "pos" : "neg";</span>.</p>
<p>Methoden, die einen Fehlerwert wie 1 zurückliefern, sind häufig so implementiert, dass am Ende immer automatisch der Fehlerwert zurückgeliefert und dann in der Mitte die Methode bei passendem Ende verlassen wird.</p>
<h4 class="t4">Fallunterscheidungen mit Ausschlussprinzip *</h4>
<p>Eine Methode <span class="clisting">between(x, a, b)</span> soll testen, ob ein Wert <span class="clisting">x</span> zwischen <span class="clisting">a</span> (untere Schranke) und <span class="clisting">b</span> (obere Schranke) liegt. Bei Methoden dieser Art ist es immer sehr wichtig, darauf zu achten und es zu dokumentieren, ob der Test auf echt kleiner (<span class="clisting">&lt;</span>) oder kleiner gleich (<span class="clisting">&lt;=</span>) durchgeführt werden soll. Wir wollen hier auch die Gleichheit betrachten.</p>
<p>In der Implementierung gibt es zwei Lösungen, wobei die meisten Programmierer zur ersten Lösung neigen. Die erste Lösungsidee zeigt sich in einer mathematischen Gleichung. Wir möchten gerne <span class="clisting">a &lt;= x &lt;= b</span> schreiben, doch ist dies in Java nicht erlaubt. [... im Gegensatz zur Programmiersprache Python.
]  So müssen wir einen Und-Vergleich anstellen, der etwa so lautet: Ist <span class="clisting">a &lt;= x &amp;&amp; x &lt;= b</span>, dann liefere <span class="clisting">true</span> zurück.</p>
<p>Die zweite Methode zeigt, dass sich das Problem auch ohne Und-Vergleich durch das Ausschlussprinzip lösen lässt:</p>
<div class="listing"><pre class="prettyprint">static boolean between( int x, int a, int b )
{
  if ( x &lt; a )
    return false;

  if ( x &lt;= b )
    return true;

  return false;
}</pre></div>
<p>Mit verschachtelten Anfragen sieht das dann so aus:</p>
<div class="listing"><pre class="prettyprint">static boolean between( int x, int a, int b )
{
  if ( a &lt;= x )
    if ( x &lt;= b )
      return true;

  return false;
}</pre></div><a id="mj021ec31631b9b7c44011343c7fbe8def" name="mj021ec31631b9b7c44011343c7fbe8def"></a><a name="t310"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t311"></a><h3 class="t3"><span class="cfett">2.8.10</span> Methoden überladen  <a href="#t2t312"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t310"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Eine Methode ist gekennzeichnet durch Rückgabewert, Name, Parameter und unter Umständen durch Ausnahmefehler, die sie auslösen kann. Java erlaubt es, den Namen der Methode beizubehalten, aber andere Parameter einzusetzen. Eine <span class="ckursiv">überladene Methode</span> ist eine Methode mit dem gleichen Namen wie eine andere Methode, aber einer unterschiedlichen Parameterliste. Das ist auf zwei Arten möglich:</p>
<ul class="gp">
<li>Eine Methode heißt gleich, akzeptiert aber eine unterschiedliche Anzahl von Argumenten.</li>
</ul>
<ul class="gp">
<li>Eine Methode heißt gleich, hat aber für den Compiler unterscheidbare Parametertypen.</li>
</ul>
<p>Anwendungen für den ersten Fall gibt es viele. Der Name einer Methode soll ihre Aufgabe beschreiben, aber nicht die Typen der Parameter, mit denen sie arbeitet, extra erwähnen. Das ist bei anderen Sprachen üblich, doch nicht in Java. Sehen wir uns als Beispiel die in der Mathe-Klasse <span class="clisting">Math</span> angebotene statische Methode <span class="clisting">max()</span> an. Sie ist mit den Parametertypen <span class="clisting">int</span>, <span class="clisting">long</span>, <span class="clisting">float</span> und <span class="clisting">double</span> deklariert &#8211; das ist viel schöner als etwa separate Methoden <span class="clisting">maxInt()</span> und <span class="clisting">maxDouble()</span>.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Eine unterschiedliche Anzahl von Parametern ist ebenfalls eine sinnvolle Angelegenheit. Die statische Methode <span class="clisting">avg()</span> könnten wir so für zwei und drei Parameter deklarieren:</p>
<div class="listing"><pre class="prettyprint">static double avg( <span class="cfett">double x, double y</span> ) {
  return (x + y) / 2;
}
static double avg( <span class="cfett">double x, double y, double z</span> ) {
  return (x + y + z) / 3;
}</pre></div>
</td>
</tr>
</table><br><h4 class="t4">»print()« und »println()« sind überladen *</h4>
<p>Das bekannte <span class="clisting">print()</span> und <span class="clisting">println()</span> sind überladene Methoden, die etwa wie folgt deklariert sind:</p>
<div class="listing"><pre class="prettyprint">class PrintStream
{
  void print(<span class="cfett"> Object</span> arg ) { ... }
  void print(<span class="cfett"> String</span> arg ) { ... }
  void print(<span class="cfett"> char[]</span> arg ) { ... }
  ...
}</pre></div>
<p>Wird nun die Methode <span class="clisting">print()</span> mit irgendeinem Typ aufgerufen, dann wird die am besten passende Methode herausgesucht. Versucht der Programmierer beispielsweise die Ausgabe eines Objekts <span class="clisting">Date</span>, dann stellt sich die Frage, welche Methode sich darum kümmern kann. Glücklicherweise ist die Antwort nicht schwierig, denn es existiert auf jeden Fall eine <span class="clisting">print()</span>-Methode, die Objekte ausgibt. Und da <span class="clisting">Date</span>, wie auch alle anderen Klassen, eine Unterklasse von <span class="clisting">Object</span> ist, wird <span class="clisting">print(Object)</span> gewählt (natürlich kann nicht erwartet werden, dass das Datum in einem bestimmten Format &#8211; etwa nur das Jahr &#8211; ausgegeben wird, jedoch wird eine Ausgabe auf dem Schirm sichtbar). Denn jedes Objekt kann sich durch den Namen identifizieren, und dieser würde in dem Fall ausgegeben. Obwohl es sich so anhört, als ob immer die Methode mit dem Parametertyp <span class="clisting">Object</span> aufgerufen wird, wenn der Datentyp nicht angepasst werden kann, ist dies nicht ganz richtig. Wenn der Compiler keine passende Klasse findet, dann wird die nächste Oberklasse im Ableitungsbaum gesucht, für die in unserem Fall eine Ausgabemethode existiert.</p>
<h4 class="t4">Negative Beispiele und schlaue Leute *</h4>
<p>Oft verfolgt auch die Java-Bibliothek die Strategie mit gleichen Namen und unterschiedlichen Typen. Es gibt allerdings einige Ausnahmen. In der Grafik-Bibliothek finden sich die folgenden drei Methoden:</p>
<ul class="gp">
<li><span class="clisting">draw</span><span class="cfett">String</span><span class="clisting">(</span> <span class="cfett">String</span> <span class="clisting">str, int x, int y )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">draw</span><span class="cfett">Chars</span><span class="clisting">(</span> <span class="cfett">char[]</span> <span class="clisting">data, int offset, int length, int x, int y )</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">draw</span><span class="cfett">Bytes</span><span class="clisting">(</span> <span class="cfett">byte[]</span> <span class="clisting">data, int offset, int length, int x, int y )</span></li>
</ul>
<p>Das ist äußerst hässlich und schlechter Stil.</p>
<p>Ein anderes Beispiel findet sich in der Klasse <span class="clisting">DataOutputStream</span>. Hier heißen die Methoden etwa <span class="clisting">writeInt()</span>, <span class="clisting">writeChar()</span> und so weiter. Obwohl wir dies auf den ersten Blick verteufeln würden, ist diese Namensgebung sinnvoll. Ein Objekt vom Typ <span class="clisting">DataOutputStream</span> dient zum Schreiben von primitiven Werten in einen Datenstrom. Gäbe es in <span class="clisting">DataOutputStream</span> die überladenen Methoden <span class="clisting">write(byte)</span>, <span class="clisting">write(short)</span>, <span class="clisting">write(int)</span>, <span class="clisting">write(long)</span> und <span class="clisting">write(char)</span> und würden wir sie mit <span class="clisting">write(21)</span> füttern, dann hätten wir das Problem, dass eine Typkonvertierung die Daten automatisch anpassen und der Datenstrom mehr Daten beinhalten würde, als wir wünschen. Denn <span class="clisting">write(21)</span> ruft nicht etwa <span class="clisting">write(short)</span> auf und schreibt zwei Bytes, sondern <span class="clisting">write(int)</span> und schreibt somit vier Bytes. Um also die Übersicht über die geschriebenen Bytes zu behalten, ist eine ausdrückliche Kennzeichnung der Datentypen in manchen Fällen gar nicht so dumm.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Sprachvergleich   </span>Überladene Methoden sind in anderen Programmiersprachen nichts Selbstverständliches. Es erlauben zum Beispiel C# und C++ überladene Methoden, JavaScript, PHP und C jedoch nicht. In Sprachen ohne überladene Methoden wird der Methode/Funktion ein Feld mit Argumenten übergeben. So ist die Typisierung der einzelnen Elemente ein Problem genauso wie die Beschränkung auf eine bestimmte Anzahl von Parametern.</p>
</td>
</tr>
</table><br><a id="mjf8e7549c7c3a573dcfba78077f9cf7e1" name="mjf8e7549c7c3a573dcfba78077f9cf7e1"></a><a name="t311"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t312"></a><h3 class="t3"><span class="cfett">2.8.11</span> Vorgegebener Wert für nicht aufgeführte Argumente *  <a href="#t2t313"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t311"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Überladene Methoden lassen sich gut verwenden, wenn vorinitialisierte Werte bei nicht vorhandenen Argumenten genutzt werden sollen. Ist also ein Parameter nicht belegt, soll ein Standardwert eingesetzt werden. Um das zu erreichen, überladen wir einfach die Methode und rufen die andere Methode mit dem Standardwert passend auf (die Sprache C++ definiert in der Sprachgrammatik eine Möglichkeit, die wir in Java nicht haben).</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Zwei überladene statische Methoden, <span class="clisting">tax(double cost, double taxRate)</span> und <span class="clisting">tax(double cost)</span>, sollen die Steuer berechnen. Wir möchten, dass der Steuersatz automatisch 19  % ist, wenn die statische Methode <span class="clisting">tax(double cost)</span> aufgerufen wird und der Steuersatz nicht explizit gegeben ist; im anderen Fall können wir <span class="clisting">taxRate</span> beliebig wählen.</p>
<div class="listing"><pre class="prettyprint">static double tax( double cost, double taxRate )
{
  return cost * taxRate / 100;
}
static double tax( double cost )
{
  return tax( cost, 19.0 );
}</pre></div>
</td>
</tr>
</table><br><a id="mj93af18e3273e580bb7a4395eeec2f1f8" name="mj93af18e3273e580bb7a4395eeec2f1f8"></a><a name="t312"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t313"></a><h3 class="t3"><span class="cfett">2.8.12</span> Finale lokale Variablen  <a href="#t2t314"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t312"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>In einer Methode können Parameter oder lokale Variablen mit dem Modifizierer <span class="clisting">final</span> deklariert werden. Dieses zusätzliche Schlüsselwort verbietet nochmalige Zuweisungen an diese Variable, sodass sie nicht mehr verändert werden kann:</p>
<div class="listing"><pre class="prettyprint">static void foo(<span class="cfett"> final</span> int a )
{
    int i = 2;
   <span class="cfett"> final</span> int j = 3;
    i = 3;
    j = 4;       // <img src="common/totenkopf.gif" border="0" align="bottom" alt="Fehler"> Compilerfehler
    a = 2;       // <img src="common/totenkopf.gif" border="0" align="bottom" alt="Fehler"> Compilerfehler
}</pre></div>
<h4 class="t4">Aufgeschobene Initialisierung *</h4>
<p>Java erlaubt bei finalen Werten eine aufgeschobene Initialisierung. Das heißt, dass nicht zwingend zum Zeitpunkt der Variablendeklaration ein Wert zugewiesen werden muss. Dies kann auch genau einmal im Programmcode geschehen. Folgendes ist gültig:</p>
<div class="listing"><pre class="prettyprint"><span class="cfett">final</span> int a;
a = 2;</pre></div>
<p>Obwohl auch Objektvariablen und Klassenvariablen final sein können, gibt es dort nur beschränkt eine aufgeschobene Initialisierung. Bei der Deklaration müssen wir die Variablen entweder direkt belegen oder im Konstruktor zuweisen. Wir werden uns dies später noch einmal genauer ansehen. Werden finale Variablen vererbt, so können Unterklassen diesen Wert auch nicht mehr überschreiben. (Das wäre ein Problem, aber vielleicht auch ein Vorteil für manche Konstanten.)</p>
<h4 class="t4">Final deklarierte Referenz-Parameter und das fehlende »const«</h4>
<p>Wir haben gesehen, dass finale Variablen dem Programmierer vorgeben, dass er Variablen nicht beschreiben darf. Das heißt, Zuweisungen sind tabu. Dabei ist es egal, ob die Parametervariable vom primitiven Typ oder vom Referenztyp ist. Bei einer Methodendeklaration der folgenden Art wäre also eine Zuweisung an <span class="clisting">i</span> und auch an <span class="clisting">s</span> verboten:</p>
<div class="listing"><pre class="prettyprint">public void foo(<span class="cfett"> final</span> int i,<span class="cfett"> final</span> String s )</pre></div>
<p>Ist die Parametervariable ein Referenztyp (und nicht <span class="clisting">final</span>), so würden wir mit einer Zuweisung den Verweis auf das ursprüngliche Objekt verlieren, und das wäre wenig sinnvoll.</p>
<div class="listing"><pre class="prettyprint">public void foo( String s )
{
  s = "Keine Feier ohne Geier.";
}</pre></div>
<p>Halten wir fest: Ist ein Parameter mit <span class="clisting">final</span> deklariert, sind keine Zuweisungen möglich. <span class="clisting">final</span> verbietet aber keine Änderungen an Objekten &#8211; und so könnte <span class="clisting">final</span> im Sinne der Übersetzung »endgültig« verstanden werden. Mit der Referenz des Objekts können wir sehr wohl den Zustand verändern. So ändert die folgende <span class="clisting">foo()</span>-Methode die x-Koordinate eines <span class="clisting">Point</span>-Objekts, egal, ob <span class="clisting">p</span> final ist oder nicht.</p>
<div class="listing"><pre class="prettyprint">public static void foo( final Point p )
{
  p.x = 2;
}</pre></div>
<p><span class="clisting">final</span> erfüllt demnach nicht die Aufgabe, schreibende Objektzugriffe zu verhindern. Eine Methode mit übergebenen Referenzen kann also Objektveränderungen vornehmen, wenn es etwa <span class="clisting">setXXX()</span>-Methoden oder Variablen gibt, auf die zugegriffen werden kann. Die Dokumentation muss also immer ausdrücklich beschreiben, wann die Methode den Zustand eines Objekts modifiziert.</p>
<p>In C++ gibt es für Parameter den Zusatz <span class="clisting">const</span>, an dem der Compiler erkennen kann, dass Objektzustände nicht verändert werden sollen. Ein Programm nennt sich »const-korrekt«, wenn es niemals ein konstantes Objekt verändert. Dieses <span class="clisting">const</span> ist in C++ eine Erweiterung des Objekttyps, die es in Java nicht gibt. Zwar haben die Java-Entwickler das Schlüsselwort <span class="clisting">const</span> reserviert, doch genutzt wird es bisher nicht.</p>
<h4 class="t4">»final« in der Vererbung *</h4>
<p>In der Vererbung spielt das <span class="clisting">final</span> bei Parametern keine Rolle. Wir können es als zusätzliche Information für die jeweilige Methode betrachten. Eine Unterklasse kann demnach beliebig das <span class="clisting">final</span> hinzufügen oder auch wegnehmen. Alte Bibliotheken lassen sich so leicht weiterverwenden.</p><a id="mje1fd0b8e4f3262cd2aa633ff59abaab5" name="mje1fd0b8e4f3262cd2aa633ff59abaab5"></a><a name="t313"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t314"></a><h3 class="t3"><span class="cfett">2.8.13</span> Rekursive Methoden *  <a href="#t2t315"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t313"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Wir wollen den Einstieg in die Rekursion mit einem kurzen Beispiel beginnen.</p>
<p>Auf dem Weg durch den Wald begegnet uns eine Fee (engl. <span class="ckursiv">fairy</span>). Sie sagt zu uns: »Du hast drei Wünsche frei.« Tolle Situation. Um das ganze Unglück aus der Welt zu räumen, entscheiden wir uns nicht für eine egozentrische Wunscherfüllung, sondern für die sozialistische: »Ich möchte Frieden für alle, Gesundheit und Wohlstand für jeden.« Und schwupps, so war es geschehen, und alle lebten glücklich bis...</p>
<p>Einige Leser werden vielleicht die Hand vor den Kopf schlagen und sagen: »Quatsch! Ein Haus, ein Auto und einen Lebenspartner, der die Trägheit des Morgens duldet.« Glücklicherweise können wir das Dilemma mit der Rekursion lösen. Die Idee ist einfach &#8211; und in unseren Träumen schon erprobt &#8211;, sie besteht nämlich darin, den letzten Wunsch als »Nochmal drei Wünsche frei« zu formulieren.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Eine kleine Wunsch-Methode:</p>
<div class="listing"><pre class="prettyprint">static void <span class="cfett">fairy()</span>
{
  wish();
  wish();
  <span class="cfett">fairy()</span><span class="clisting">;</span>
}</pre></div>
</td>
</tr>
</table><br><p>Durch den dauernden Aufruf der <span class="clisting">fairy()</span>-Methode haben wir unendlich viele Wünsche frei. <span class="ckursiv">Rekursion</span> ist also das Aufrufen der eigenen Methode, in der wir uns befinden. Dies kann auch über einen Umweg funktionieren. Das nennt sich dann nicht mehr <span class="ckursiv">direkte Rekursion</span>, sondern <span class="ckursiv">indirekte Rekursion</span>. Sie ist ein sehr alltägliches Phänomen, das wir auch von der Rückkopplung Mikrofon/Lautsprecher oder dem Blick mit einem Spiegel in den Spiegel kennen.</p>
<h4 class="t4">Abbruch der Rekursion</h4>
<p>Wir müssen nun die Fantasie-Programme (deren Laufzeit und Speicherbedarf auch sehr schwer zu berechnen sind) gegen Java-Methoden austauschen.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Eine Endlos-Rekursion:</p>
<p class="tabunter"><strong>Listing 2.24    </strong>EndlessRecursion.java, down()</p>
<div class="listing"><pre class="prettyprint">static void <span class="cfett">down</span>( int n )
{
  System.out.print( n + ", " );
  <span class="cfett">down</span>( n &#8211; 1 );
}</pre></div>
</td>
</tr>
</table><br><p>Rufen wir <span class="clisting">down(10)</span> auf, dann wird die Zahl 10 auf dem Bildschirm ausgegeben und anschließend <span class="clisting">down(9)</span> aufgerufen. Führen wir das Beispiel fort, so ergibt sich eine endlose Ausgabe, die so beginnt:</p>
<div class="listing"><pre class="prettyprint">10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, &#8211;1, &#8211;2, ...</pre></div>
<p>An dieser Stelle erkennen wir, dass Rekursion prinzipiell etwas Unendliches ist. Für Programme ist dies aber ungünstig. Wir müssen daher ähnlich wie bei Schleifen eine Abbruchbedingung formulieren und dann keinen Rekursionsaufruf mehr starten. Die Abbruchbedingung sieht so aus, dass eine Fallunterscheidung das Argument prüft und mit <span class="clisting">return</span> die Abarbeitung beendet.</p>
<p class="tabunter"><strong>Listing 2.25    </strong>Recursion.java, down1()</p>
<div class="listing"><pre class="prettyprint">static void down1( int n )
{
 <span class="cfett"> if ( n &lt;= 0</span> )              // Rekursionsende
   <span class="cfett"> return;

  System.out.print( n + ", " );
  down1( n &#8211; 1 );
}</span></pre></div>
<p>Die statische <span class="clisting">down1()</span>-Methode ruft jetzt nur noch so lange <span class="clisting">down1(n</span> &#8211; <span class="clisting">1)</span> auf, wie das <span class="clisting">n</span> größer null ist. Das ist die <span class="ckursiv">Abbruchbedingung</span> einer Rekursion.</p>
<h4 class="t4">Unterschiedliche Rekursionsformen</h4>
<p>Ein Kennzeichen der bisherigen Programme war, dass nach dem Aufruf der Rekursion keine Anweisung stand, sondern die Methode mit dem Aufruf beendet wurde. Diese Rekursionsform nennt sich Endrekursion. Diese Form ist verhältnismäßig einfach zu verstehen. Schwieriger sind Rekursionen, bei denen hinter dem Methodenaufruf Anweisungen stehen. Betrachten wir folgende Methoden, von denen die erste bekannt und die zweite neu ist:</p>
<p class="tabunter"><strong>Listing 2.26    </strong>Recursion.java, down1() und down2()</p>
<div class="listing"><pre class="prettyprint">static void<span class="cfett"> down1</span>( int n )
{
  if ( n &lt;= 0 )   // Rekursionsende
    return;

  System.out.print( n + ", " );
 <span class="cfett"> down1</span>( n &#8211; 1 );
}

static void<span class="cfett"> down2</span>( int n )
{
  if ( n &lt;= 0 )   // Rekursionsende
    return;

 <span class="cfett"> down2</span>( n &#8211; 1 );

  System.out.print( n + ", " );
}</pre></div>
<p>Der Unterschied besteht darin, dass <span class="clisting">down1()</span> zuerst die Zahl <span class="clisting">n</span> ausgibt und anschließend rekursiv <span class="clisting">down1()</span> aufruft. Die Methode <span class="clisting">down2()</span> steigt jedoch erst immer tiefer ab, und die Rekursion muss beendet sein, bis es zum ersten <span class="clisting">print()</span> kommt. Daher gibt im Gegensatz zu <span class="clisting">down1()</span> die statische Methode <span class="clisting">down2()</span> die Zahlen in aufsteigender Reihenfolge aus:</p>
<div class="listing"><pre class="prettyprint">1, 2, 3, 4, 5, 6, 7, 8, 9, 10,</pre></div>
<p>Dies ist einleuchtend, wenn wir die Ablaufreihenfolge betrachten. Beim Aufruf <span class="clisting">down2(10)</span> ist der Vergleich von <span class="clisting">n</span> mit null falsch, also wird ohne Ausgabe wieder <span class="clisting">down2(9)</span> aufgerufen. Ohne Ausgabe deshalb, da <span class="clisting">print()</span> ja erst nach dem Methodenaufruf steht. Es geht rekursiv tiefer, bis <span class="clisting">n</span> gleich null ist. Dann endet die letzte Methode mit <span class="clisting">return</span>, und die Ausgabe wird nach dem <span class="clisting">down2()</span>, dem Aufrufer, fortgeführt. Dort ist <span class="clisting">print()</span> die nächste Anweisung. Da wir nun noch tief verschachtelt stecken, gibt <span class="clisting">print(n)</span> die Zahl 1 aus. Dann ist die Methode <span class="clisting">down2()</span> wieder beendet (ein unsichtbares, nicht direkt geschriebenes <span class="clisting">return</span>), und sie springt zum Aufrufer zurück. Das war wieder die Methode <span class="clisting">down2()</span>, aber mit der Belegung <span class="clisting">n = 2</span>. Das geht so weiter, bis es zurück zum Aufrufer kommt, der <span class="clisting">down(10)</span> aufgerufen hat, zum Beispiel der statischen <span class="clisting">main()</span>-Methode. Der Trick bei der Sache besteht nun darin, dass jede Methode ihre eigene lokale Variable besitzt.</p>
<p><div class="eclipse"><img src="common/eclipseicon.gif" align="top" width="53" height="23" alt="Eclipse" title="Eclipse"></div>Die Tastenkombination 
    <span class="tastenkappe">Strg</span>
  +
    <span class="tastenkappe">Alt</span>
  +
    <span class="tastenkappe">H</span>
   zeigt die Aufrufhierarchie an. So ist zu sehen, wer eine Methode aufruft. In den Aufrufen von <span class="clisting">down2()</span> tauchen also wiederum wegen des rekursiven Aufrufs <span class="clisting">down2()</span> auf sowie <span class="clisting">main()</span>.</p>
<h4 class="t4">Rekursion und der Stack sowie die Gefahr eines StackOverflowError *</h4>
<p>Am Beispiel haben wir gesehen, dass der Aufruf von <span class="clisting">down2(10)</span> zum Aufruf von <span class="clisting">down2(9)</span> führt. Und <span class="clisting">down2(10)</span> kann erst dann beendet werden, wenn <span class="clisting">down2(9)</span> komplett abgearbeitet wurde. <span class="clisting">down2(10)</span> ist sozusagen so lange »offen«, bis der Schwanz von untergeordneten Aufrufen beendet ist. Nun muss sich die Laufzeitumgebung natürlich bei einem Methodenaufruf merken, wo es nach dem Methodenaufruf weitergeht. Dazu nutzt sie den Stack. Beim Aufruf von <span class="clisting">down2(9)</span> etwa wird der Stack mit der Rücksprungadresse gefüllt, der zum Kontext von <span class="clisting">down2(10)</span> zurückführt. In jedem Kontext gibt es auch wieder die alten lokalen Variablen.</p>
<p>Gibt es bei Rekursionen keine Abbruchbedingung, so kommen immer mehr Rücksprungadressen auf den Stapel, bis der Stapel keinen Platz mehr hat. Dann folgt ein <span class="clisting">java.lang. StackOverflowError</span>, und das Programm (der Thread) bricht ab. In der Regel deutet der <span class="clisting">StackOverflowError</span> auf einen Programmierfehler hin, es gibt aber Programme, die einen wirklich großen Stack benötigen und für die die Stack-Größe einfach zu klein ist.</p>
<p>Standardmäßig ist die Stack-Größe 512 KiB. Sie lässt sich über einen JVM-Schalter [<span class="ckursiv"><a href="http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp" target="_blank">http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp</a></span>
]  vergrößern, der <span class="clisting">-Xss:n</span> heißt (oder etwas länger in der Schreibweise <span class="clisting">-XX:ThreadStackSize=n</span>). Um ihn auf 2 MiB (2048 KiB) zu setzen, schreiben wir:</p>
<div class="listing"><pre class="prettyprint">$ java<span class="cfett"> &#8211;XXs:2048</span> MyApplication</pre></div>
<p>Die Stack-Größe gilt damit für alle Threads in der JVM, was natürlich bei großen Stacks und vielen Threads zu einem Speicherproblem führen kann. Umgekehrt lässt sich auch Speicher einsparen, wenn das System sehr viele Threads nutzt und die Stack-Größe verringert wird.</p><a id="mja99d7594870ad07a0d98217193f32790" name="mja99d7594870ad07a0d98217193f32790"></a><a name="t314"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t315"></a><h3 class="t3"><span class="cfett">2.8.14</span> Die Türme von Hanoi *  <img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"><a href="#t2t314"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Die Legende der Türme von Hanoi soll erstmalig von Ed Lucas in einem Artikel in der französischen Zeitschrift »Cosmo« im Jahre 1890 veröffentlicht worden sein. [Wir halten uns hier an eine Überlieferung von C. H. A. Koster aus dem Buch »Top-down Programming with Elan« von Ellis Horwood (1987).
]  Der Legende nach standen vor langer Zeit im Tempel von Hanoi drei Säulen. Die erste war aus Kupfer, die zweite aus Silber und die dritte aus Gold. Auf der Kupfersäule waren einhundert Scheiben aufgestapelt. Die Scheiben hatten in der Mitte ein Loch und waren aus Porphyr [Gestein vulkanischen Ursprungs. Besondere Eigenschaften von Porphyr sind: hohe Bruchfestigkeit, hohe Beständigkeit gegen physikalisch-chemische Wirkstoffe und hohe Wälz- und Gleitreibung.
] . Die Scheibe mit dem größten Umfang lag unten, und alle kleiner werdenden Scheiben lagen obenauf. Ein alter Mönch stellte sich die Aufgabe, den Turm der Scheiben von der Kupfersäule zur Goldsäule zu bewegen. In einem Schritt sollte aber nur eine Scheibe bewegt werden, und zudem war die Bedingung, dass eine größere Scheibe niemals auf eine kleinere bewegt werden durfte. Der Mönch erkannte schnell, dass er die Silbersäule nutzen musste; er setzte sich an einen Tisch, machte einen Plan, überlegte und kam zu einer Entscheidung. Er konnte sein Problem in drei Schritten lösen. Am nächsten Tag schlug der Mönch die Lösung an die Tempeltür:</p>
<ul class="gp">
<li>Falls der Turm aus mehr als einer Scheibe besteht, bitte deinen ältesten Schüler, einen Turm von (n &#8211; 1) Scheiben von der ersten zur dritten Säule unter Verwendung der zweiten Säule umzusetzen.</li>
</ul>
<ul class="gp">
<li>Trage selbst die erste Scheibe von einer zur anderen Säule.</li>
</ul>
<ul class="gp">
<li>Falls der Turm aus mehr als einer Scheibe besteht, bitte deinen ältesten Schüler, einen Turm aus (n &#8211; 1) Scheiben von der dritten zu der anderen Säule unter Verwendung der ersten Säule zu transportieren.</li>
</ul>
<p>Und so rief der alte Mönch seinen ältesten Schüler zu sich und trug ihm auf, den Turm aus 99 Scheiben von der Kupfersäule zur Goldsäule unter Verwendung der Silbersäule umzuschichten und ihm den Vollzug zu melden. Nach der Legende würde das Ende der Welt nahe sein, bis der Mönch seine Arbeit beendet hätte. Nun, so weit die Geschichte. Wollen wir den Algorithmus zur Umschichtung der Porphyrscheiben in Java programmieren, so ist eine rekursive Lösung recht einfach. Werfen wir einen Blick auf das folgende Programm, das die Umschichtungen über die drei Pflöcke (engl. <span class="ckursiv">pegs</span>) vornimmt.</p>
<p class="tabunter"><strong>Listing 2.27    </strong>TowerOfHanoi.java</p>
<div class="listing"><pre class="prettyprint">class TowerOfHanoi
{
 static void<span class="cfett"> move( int n, String fromPeg, String toPeg, String usingPeg )</span>
 {
  if ( n &gt; 1 )
  {
  <span class="cfett"> move( n &#8211; 1, fromPeg, usingPeg, toPeg );</span>
   System.out.printf( "Bewege Scheibe %d von der %s zur %s.%n", n, fromPeg, toPeg );
  <span class="cfett"> move( n &#8211; 1, usingPeg, toPeg, fromPeg );</span>
  }
  else
   System.out.printf( "Bewege Scheibe %d von der %s zur %s.%n", n, fromPeg, toPeg );
 }

 public static void main( String[] args )
 {
 <span class="cfett"> move( 4, "Kupfersäule", "Goldsäule", "Silbersäule" );</span>
 }
}</pre></div>
<p>Starten wir das Programm mit vier Scheiben, so bekommen wir folgende Ausgabe:</p>
<div class="listing"><pre class="prettyprint">Bewege Scheibe 1 von der Kupfersäule zur Silbersäule.
Bewege Scheibe 2 von der Kupfersäule zur Goldsäule.
Bewege Scheibe 1 von der Silbersäule zur Goldsäule.
Bewege Scheibe 3 von der Kupfersäule zur Silbersäule.
Bewege Scheibe 1 von der Goldsäule zur Kupfersäule.
Bewege Scheibe 2 von der Goldsäule zur Silbersäule.
Bewege Scheibe 1 von der Kupfersäule zur Silbersäule.
Bewege Scheibe 4 von der Kupfersäule zur Goldsäule.
Bewege Scheibe 1 von der Silbersäule zur Goldsäule.
Bewege Scheibe 2 von der Silbersäule zur Kupfersäule.
Bewege Scheibe 1 von der Goldsäule zur Kupfersäule.
Bewege Scheibe 3 von der Silbersäule zur Goldsäule.
Bewege Scheibe 1 von der Kupfersäule zur Silbersäule.
Bewege Scheibe 2 von der Kupfersäule zur Goldsäule.
Bewege Scheibe 1 von der Silbersäule zur Goldsäule.</pre></div>
<p>Schon bei vier Scheiben haben wir 15 Bewegungen. Selbst wenn unser Prozessor mit vielen Millionen Operationen pro Sekunde arbeitet, benötigt ein Computer für die Abarbeitung Tausende geologischer Erdzeitalter. An diesem Beispiel wird eines deutlich: Viele Dinge sind im Prinzip berechenbar, nur praktisch ist so ein Algorithmus nicht.</p><br><hr><a name="kommentar"></a><h3>Ihr Kommentar</h3>
                       Wie hat Ihnen das &lt;openbook&gt; gefallen? Wir freuen uns immer über Ihre freundlichen und kritischen Rückmeldungen.
                       <form action="http://www.galileo-press.de/feedback/openbook" method="post" style="text-align: center; margin-top: 10px;"><input type="hidden" name="openbookurl" value="javainsel9/.htm"><input type="hidden" name="buchtitel" value="Java ist auch eine Insel"><input type="hidden" name="Kapitel" value="2.8 Methoden einer Klasse"><table border="0">
<tr>
<td><label for="name">Name</label><br></td>
<td><input type="text" name="name" id="name" size="40"><br></td>
</tr>
<tr>
<td><label for="email">E-Mail</label><br></td>
<td><input type="text" name="email" id="email" size="40"><br></td>
</tr>
<tr>
<td valign="top"><label for="comment">Ihr Kommentar</label><br></td>
<td><textarea name="comment" id="comment" rows="10" cols="40"></textarea><br></td>
</tr>
<tr>
<td>
</td>
<td><input type="submit" value="Kommentar absenden"></td>
</tr>
</table>
</form>
</div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="javainsel_02_007.htm" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a class="navnav" href="#">&lt;top&gt;</a></div></td>
<td align="right" width="25%"><div align="right"><a href="javainsel_02_009.htm" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
</table>
</div></td>
<td width="10" valign="top">  </td>
<td width="160" valign="top">
<table border="0" cellpadding="0" cellspacing="0" width="160">
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2">
&nbsp;<a href="http://www.galileocomputing.de/katalog/buecher/?GPP=opjiVIV" class="autor">
<strong>Zum Katalog</strong></a>

</td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2">
<img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV">
<img src="common/9783836215060_s.gif" width="119" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Java ist auch eine Insel" title="Zum Katalog: Java ist auch eine Insel">
<br><br><br><br><br><br><strong>Java ist auch eine Insel</strong><br><img src="common/pfeil_rechts5.gif" border="0" alt="">Jetzt bestellen</a><br /><br />
</td>
</tr>
</table>
</td>

</tr>
</table>
</td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2"><span class="autor"><strong>&nbsp;Ihre Meinung?</strong></a></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">

<table cellspacing="3">
<tr>
<td>Wie hat Ihnen das &lt;openbook&gt; gefallen?<br><a href="#kommentar"><img src="common/pfeil_rechts5.gif" border="0" alt="">Ihre Meinung</a>
<br><br></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>

<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>
<tr>
<td>
</td>
</tr>

<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2">&nbsp;<a href="http://www.galileocomputing.de/katalog/buecher/?GPP=opjiVIV" class="autor"><strong>Buchempfehlungen</strong></a></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2285?GPP=opjiVIV">
<img src="common/9783836215275_s.gif" width="102" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Computergeschichte(n) – nicht nur für Geeks" title="Zum Katalog: Computergeschichte(n) – nicht nur für Geeks"><br><br><br><br><br><br>&nbsp;Computergeschichte(n)<br>&nbsp;nicht nur für Geeks</a><br><br></td>
</tr>

<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/1949?GPP=opjiVIV">
<img src="common/9783836213080_s.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Java und XML" title="Zum Katalog: Java und XML"><br><br><br><br><br><br><br>&nbsp;Java und XML</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2346?GPP=opjiVIV">
<img src="common/9783836215688_s.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Einstieg in Java" title="Zum Katalog: Einstieg in Java"><br><br><br><br><br><br><br>&nbsp;Einstieg<br>&nbsp;in Java</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2051?GPP=opjiVIV">

<img src="common/9783836213677_s.gif" width="112" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Einstieg in XML" title="Zum Katalog: Einstieg in XML"><br><br><br><br><br><br><br>&nbsp;Einstieg<br>&nbsp;in XML</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2322?GPP=opjiVIV">
<img src="common/9783836215527_s.gif" width="112" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Visual C# 2010" title="Zum Katalog: Visual C# 2010"><br><br><br><br><br><br><br>&nbsp;Visual C# 2010</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2212?GPP=opjiVIV">
<img src="common/9783836214742_s.gif" width="119" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Professionell entwickeln mit Visual C# 2010" title="Zum Katalog: Professionell entwickeln mit Visual C# 2010"><br><br><br><br><br><br><br>&nbsp;Professionell<br>&nbsp;entwickeln mit<br>&nbsp;Visual C# 2010</a><br><br></td>
</tr>

<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2156?GPP=opjiVIV">
<img src="common/9783836214292_s.gif" width="108" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C++ von A bis Z" title="Zum Katalog: C++ von A bis Z"><br><br><br><br><br><br><br>&nbsp;C++ von A bis Z</a><br><br></td>
</tr>
</table></td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>

<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2"><span class="autor"><strong>&nbsp;Shopping</strong></span></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><b>Versandkostenfrei</b> bestellen in Deutschland und &Ouml;sterreich<br><a href="http://www.galileocomputing.de/hilfe/Shop/?GPP=opjiVIV"><img src="common/pfeil_rechts5.gif" border="0" alt="Info">Info</a><br><br></td>

</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table><br><br><hr width="70%" align="center">
<div align="center">
<p class="standard"><strong>Copyright © Galileo Press 2011</strong><br>
        Für Ihren privaten Gebrauch dürfen Sie die Online-Version natürlich ausdrucken.
        Ansonsten unterliegt das &lt;openbook&gt; denselben Bestimmungen, wie die
        gebundene Ausgabe: Das Werk einschließlich aller seiner Teile ist urheberrechtlich
        geschützt. Alle Rechte vorbehalten einschließlich der Vervielfältigung, Übersetzung,
        Mikroverfilmung sowie Einspeicherung und Verarbeitung in elektronischen Systemen.</p><br><a href="http://www.galileocomputing.de/">[Galileo Computing]</a><br><br>
      Galileo Press, Rheinwerkallee 4, 53227 Bonn, Tel.: 0228.42150.0, Fax 0228.42150.77, <a href="mailto:info@galileo-press.de">info@galileo-press.de</a></div><br><br></body>
</html>
