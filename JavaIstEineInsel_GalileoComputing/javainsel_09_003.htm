<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Galileo Computing :: Java ist auch eine Insel – 9.3 Object ist die Mutter aller Klassen</title>
<meta name="title" content="Galileo Computing :: Java ist auch eine Insel - 9.3 Object ist die Mutter aller Klassen">
<meta name="author" content="Christian Ullenboom ">
<meta name="publisher" content="Galileo Press 2011">
<meta name="copyright" content="Galileo Press 2011">
<meta name="Description" content="Java ist auch eine Insel - Das umfassende Handbuch – 9.3 Object ist die Mutter aller Klassen">
<meta name="audience" content="Alle">
<meta name="robots" content="INDEX,FOLLOW">
<meta http-equiv="content-language" content="de">
<link rel="stylesheet" type="text/css" href="common/galileo_open.css">
<link rel="prev" href=".htm">
<link rel="next" href=".htm"><script type="text/javascript"><!--
    function OpenWin(url,name,height,width)
    {
      var InfoWin = window.open(url,name,"directories=0,height="+height+",width=" + width + ",hotkeys=0,location=0,menubar=0,resizable=1,screenX=150,screenY=10,left=150,top=10,scrollbars=1,status=1,titlebar=0,toolbar=0");
      InfoWin.focus();
    }
    //--></script><link href="common/prettify.css" type="text/css" rel="stylesheet"><script type="text/javascript" src="common/prettify.js"></script></head>
<body vlink="#000099" link="#000099" alink="#000099" onload="prettyPrint()">
<table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#000066">
<tr>
<td height="74" valign="bottom" colspan="2"><a href="http://www.galileocomputing.de/katalog/openbook?GPP=opjiVIV"><img src="common/galileocomputing_openbook.gif" width="200" height="56" border="0" alt="Galileo Computing < openbook >" title="Galileo Computing < openbook >"></a></td>
<td width="80" height="74"><a href="http://www.galileocomputing.de/?GPP=opjiVIV"><img src="common/galileocomputing.gif" border="0" alt="Galileo Computing - Professionelle Bücher. Auch für Einsteiger." title="Galileo Computing - Professionelle Bücher. Auch für Einsteiger."></a></td>
</tr>
</table>
<div align="right"><a href="http://www.galileocomputing.de/?GPP=opjiVIV" class="navnav">Professionelle Bücher. Auch für Einsteiger.</a></div><br><table class="tbl" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="190" valign="top">
<table class="tbl1" border="0" cellpadding="3" cellspacing="0" width="190" align="left">
<tr>
<td class="tbl2"><a class="nav" href="index.htm#_top">Inhaltsverzeichnis</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_00_001.htm#mj58b119301920569a446c9c510503f310">Vorwort</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_01_001.htm#mja8fc5b7ad19fc7332bc66b09a8fda26e">1 Java ist auch eine Sprache</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_02_001.htm#mj313f67c98dc9ecaddfa2d8b80f057fd2">2 Sprachbeschreibung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_03_001.htm#mjcd3b5720e8605484942e3476a1075bdf">3 Klassen und Objekte</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_04_001.htm#mj71fbc84ad33a281b9352b0b19fae2fb2">4 Der Umgang mit Zeichenketten</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_05_001.htm#mj005cd8e604aefc3ae72b92880fcee5c6">5 Eigene Klassen schreiben</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_06_001.htm#mj6f6b47453043c38837bfc32154a97968">6 Exceptions</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_07_001.htm#mjc4a1f6f3499a02fb64fe89046739edca">7 Generics&lt;T&gt;</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_08_001.htm#mj46e914488628367f5dfc0a62c3a78a53">8 Äußere.innere Klassen</a></td>
</tr>
<tr>
<td><a class="navh" href="##mj94af2b90e8a2dad6c1ef67255f89a137">9 Besondere Klassen der Java SE</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_10_001.htm#mjcae20f50ffbc015d0b66861e7087af9b">10 Architektur, Design und angewandte Objektorientierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_11_001.htm#mj60bc6a007ae9b8657949f3e91d96df3d">11 Die Klassenbibliothek</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_12_001.htm#mj0ce00eb41aae2b084534019cf6edc3b6">12 Bits und Bytes und Mathematisches</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_13_001.htm#mj245f5f8d5a858b46462d64e9b9c0786b">13 Datenstrukturen und Algorithmen</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_14_001.htm#mj8c6f381221d805dd6fbe480731ac0c58">14 Threads und nebenläufige Programmierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_15_001.htm#mjbe3ed0989722396930966f95deeb2497">15 Raum und Zeit</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_16_001.htm#mj78bd405fb0de0cff099c06255fe36853">16 Dateien, Verzeichnisse und Dateizugriffe</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_17_001.htm#mjb420b02f4ccf65226f7271e48cefa05d">17 Datenströme</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_18_001.htm#mjedab16f1a9cc168eda4a24416359e0b9">18 Die eXtensible Markup Language (XML)</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_19_001.htm#mjc8f47f7f51ac3795c46c4544f391b02e">19 Grafische Oberflächen mit Swing</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_20_001.htm#mj25cc7d47e476b8b1a183a10ee741dbaa">20 Grafikprogrammierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_21_001.htm#mjea7bcdd596c8bd25b078a00221a01a75">21 Netzwerkprogrammierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_22_001.htm#mjde622db61608a627262a27ecb377d675">22 Verteilte Programmierung mit RMI</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_23_001.htm#mj23bf599d65364bcd05d06a34cb5593bf">23 JavaServer Pages und Servlets</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_24_001.htm#mja621f3b4a74c7fa576b4a58b1614041e">24 Datenbankmanagement mit JDBC</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_25_001.htm#mja2e217bf5724cc65eba184a2af8b79cf">25 Reflection und Annotationen</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_26_001.htm#mjb47dd6e0a309b7e78cad68f6b5de9319">26 Dienstprogramme für die Java-Umgebung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_27_001.htm#mjf59db36d9280a70e0d3d196e9bf160f5">A Die Begleit-DVD</a></td>
</tr>
<tr>
<td><a class="navnav" href="stichwort.htm#_top">Stichwort</a></td>
</tr>
<tr>
<td><br><a href="http://download2.galileo-press.de/openbook/galileocomputing_javainsel9.zip" class="navnav"><strong>Download:</strong><br>- ZIP, ca. 20,5 MB</a></td>
</tr>
<tr>
<td><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV" class="navnav">Buch bestellen</a></td>
</tr>
<tr>
<td><a class="navnav" href="#kommentar">Ihre Meinung?</a><br><br></td>
</tr>
</table>
</td>
<td width="10"><img src="common/spacer10.gif" width="10" height="10" alt="Spacer"></td>
<td width="85%" valign="top" align="center"><div align="center">
<table width="98%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="javainsel_09_002.htm" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a href="http://www.galileocomputing.de/?GPP=opjiVIV" class="navnav">Galileo Computing /</a><a href="http://www.galileocomputing.de/katalog/openbook/?GPP=opjiVIV" class="navnav"> &lt;openbook&gt; /</a><a href="index.htm" class="navnav"> Java-Insel</a></div></td>
<td align="right" width="25%"><div align="right"><a href="javainsel_09_004.htm" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" valign="top"><table width="100%" border="0" cellpadding="10" cellspacing="0" class="box">
<tr>
<td colspan="2"><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV" class="buchtitel">Java ist auch eine Insel</a><span class="autor"> von Christian Ullenboom </span><br><span class="untertitel">Das umfassende Handbuch</span></td>
</tr>
<tr>
<td valign="top" width="211"><dl>
<dt><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV" class="navnav"><img src="common/9783836215060.gif" border="0" alt="Buch: Java ist auch eine Insel" title="Buch: Java ist auch eine Insel"></a></dt>
<dd><br><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV"><span class="autor"><strong>Java ist auch eine Insel</strong><br>geb., mit DVD<br>1482 S., 49,90 Euro<br>Galileo Computing<br>ISBN 978-3-8362-1506-0</span></a></dd>
</dl></td>
<td width="80%"><table border="0">
<tr>
<td valign="baseline"><img src="common/pfeil_u.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="3" class="kap"><strong><a href="javainsel_09_001.htm#mj94af2b90e8a2dad6c1ef67255f89a137" class="navnav">9 Besondere Klassen der Java SE</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_09_001.htm#mj3ddd02b9666d4fc340fdb6405a0f3616" class="navnav">9.1 Vergleichen von Objekten</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_09_001.htm#mj8a85f5b5aeb1bcd90175fc9455224490" class="navnav">9.1.1 Natürlich geordnet oder nicht?</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_09_001.htm#mj0ed1876a49727c1dc4a281f6818e3a95" class="navnav">9.1.2 Die Schnittstelle Comparable</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_09_001.htm#mjb229dd3e0c549bc7bf8a2503fbedb9dd" class="navnav">9.1.3 Die Schnittstelle Comparator</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_09_001.htm#mj550f9cf0302921bc2da7e5671447de14" class="navnav">9.1.4 Rückgabewerte kodieren die Ordnung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_09_002.htm#mje37d90c12874f9ae2898ef61d7f21c97" class="navnav">9.2 Wrapper-Klassen und Autoboxing</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_09_002.htm#mjbe1449b7ae820f093f6d98929e07cf8d" class="navnav">9.2.1 Wrapper-Objekte erzeugen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_09_002.htm#mjfcc9ccd6b164cb6389e2daa620ee7b42" class="navnav">9.2.2 Konvertierungen in eine String-Repräsentation</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_09_002.htm#mj987a90501851c20bcde7822857b7ab14" class="navnav">9.2.3 Die Basisklasse Number für numerische Wrapper-Objekte</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_09_002.htm#mjecf5de0c4d43d2ba0f83dfce865d017e" class="navnav">9.2.4 Vergleiche durchführen mit »compare()«, »compareTo()« und »equals()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_09_002.htm#mj28ea7d603270b0dd47fceea971440d70" class="navnav">9.2.5 Die Klasse Integer</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_09_002.htm#mjee10d7cf5077c4f7a00dafb1b58385f6" class="navnav">9.2.6 Die Klassen Double und Float für Fließkommazahlen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_09_002.htm#mj3d6f4811d493a0b54aeda9ef7213c8cf" class="navnav">9.2.7 Die Boolean-Klasse</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_09_002.htm#mj9aaef31dce82a3daebaeb79ea69bfab2" class="navnav">9.2.8 Autoboxing: Boxing und Unboxing</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="#mj2d86e66e54287fd3a7216ef0e9e70a3c" class="navh">9.3 Object ist die Mutter aller Klassen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj23d2063caef590e4f07f8dea2ba81ebf" class="navh">9.3.1 Klassenobjekte</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjb955c41594d5085cbcc3db2dca6507a1" class="navh">9.3.2 Objektidentifikation mit »toString()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj4c33787451c2460c2eb18623b08278d9" class="navh">9.3.3 Objektgleichheit mit »equals()« und Identität</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjf4272fd243c9ca882397f284661c5aad" class="navh">9.3.4 Klonen eines Objekts mit »clone()« *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj7fe8f3d9fd296c97017de07898eebccc" class="navh">9.3.5 Hashcodes über »hashCode()« liefern *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj719f4e662e9ffafee33ad5d59fdc0dbb" class="navh">9.3.6 Aufräumen mit »finalize()« *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjaa2ddfc2bae3f5cf4c8a3427a2ed1555" class="navh">9.3.7 Synchronisation *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_09_004.htm#mj2f6d324dfd3b9293fe6312045c460ad3" class="navnav">9.4 Die Spezial-Oberklasse Enum</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_09_004.htm#mjb51623ea831884c57b143981630b06fb" class="navnav">9.4.1 Methoden auf Enum-Objekten</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_09_004.htm#mj83148487d9d7e07f7a117a0a6b4be8c5" class="navnav">9.4.2 »Enum« mit eigenen Konstruktoren und Methoden *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_09_005.htm#mjaedac022d8feb8adeb6b664e81d2e969" class="navnav">9.5 Erweitertes »for« und »Iterable«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_09_005.htm#mjfc718ed8a1956898dc6f70e8ed9ca1ad" class="navnav">9.5.1 Die Schnittstelle »Iterable«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="javainsel_09_005.htm#mj71228677e0dcf9d6abaa2b5a84e78c15" class="navnav">9.5.2 Einen eigenen Iterable implementieren *</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="javainsel_09_006.htm#mj9a703099ff8a171b1423262b0e4a6d45" class="navnav">9.6 Zum Weiterlesen</a></strong></td>
</tr>
</table><br></td>
</tr>
</table>
<table width="100%" cellpadding="20" cellspacing="0" border="0" bgcolor="#eeeeee">
<tr>
<td><div class="main"><a id="mj2d86e66e54287fd3a7216ef0e9e70a3c" name="mj2d86e66e54287fd3a7216ef0e9e70a3c"></a><a name="t21"></a><a name="t2t31"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div>
<h2 class="t2"><span class="cfett">9.3</span> Object ist die Mutter aller Klassen  <a href="#t2t32"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><img src="common/15x15leer.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></h2>
<p><span class="clisting">java.lang.Object</span> ist die oberste aller Klassen. Somit spielt diese Klasse eine ganz besondere Rolle, da alle anderen Klassen automatisch Unterklassen sind und die Methoden erben beziehungsweise überschreiben.</p>
<div class="bildbox">
<p><a name="IDAJF0D"></a><a onClick="OpenWin('bilder/objectuml.gif','Abbildung',800,800)"><img border="0" src="bilderklein/kleinobjectuml.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div><a id="mj23d2063caef590e4f07f8dea2ba81ebf" name="mj23d2063caef590e4f07f8dea2ba81ebf"></a><a name="t31"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t32"></a><h3 class="t3"><span class="cfett">9.3.1</span> Klassenobjekte  <a href="#t2t33"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t31"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Zwar ist jedes Objekt ein Exemplar einer Klasse &#8211; doch was ist eine Klasse? In einer Sprache wie C++ existieren Klassen nicht zur Laufzeit, und der Compiler übersetzt die Klassenstruktur in ein ausführbares Programm. Im absoluten Gegensatz dazu steht Smalltalk: Diese Laufzeitumgebung verwaltet Klassen selbst als Objekte. Diese Idee, Klassen als Objekte zu repräsentieren, übernimmt auch Java &#8211; Klassen sind Objekte vom Typ <span class="clisting">java.lang.Class</span>.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">class java.lang.<span class="cfett">Object</span></pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">final Class&lt;? extends Object&gt; getClass()</span>
Liefert die Referenz auf das Klassenobjekt, die das Objekt konstruiert hat. Das <span class="clisting">Class</span>-Objekt ist immer eindeutig in der JVM, sodass auch mehrere Anfragen an <span class="clisting">getClass()</span> immer dasselbe <span class="clisting">Class</span>-Objekt liefern.</li>
</ul><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Die Objektmethode <span class="clisting">getName()</span> eines <span class="clisting">Class</span>-Objekts liefert den Namen der Klassen:</p>
<div class="listing"><pre class="prettyprint">System.out.println( "Klaviklack".getClass().getName() ); // java.lang.String</pre></div>
</td>
</tr>
</table><br><h4 class="t4">Klassen-Literale</h4>
<p>Ein <span class="ckursiv">Klassen-Literal</span> (engl. <span class="ckursiv">class literal</span>) ist ein Ausdruck der Form <span class="clisting">Datentyp.class</span>, wobei <span class="clisting">Datentyp</span> entweder eine Klasse, eine Schnittstelle, ein Feld oder ein primitiver Typ ist. Beispiele sind <span class="clisting">String.class</span>, <span class="clisting">Integer.class</span> oder <span class="clisting">int.class</span> (was nicht mit <span class="clisting">Integer.class</span> identisch ist). Der Ausdruck ist immer vom Typ <span class="clisting">Class</span>. Bei primitiven Typen liefert die Schreibweise <span class="clisting">primitiverTyp.class</span> das gleiche Ergebnis wie <span class="clisting">WrapperTyp.TYPE</span>; es ist also <span class="clisting">Integer.TYPE</span> identisch mit <span class="clisting">int.class</span>. <span class="clisting">Class</span>-Objekte spielen insbesondere bei dynamischen Abfragen über die so genannte Reflection eine Rolle. Zur Laufzeit können so beliebige Klassen geladen, Objekte erzeugt und Methoden aufgerufen werden.</p><a id="mjb955c41594d5085cbcc3db2dca6507a1" name="mjb955c41594d5085cbcc3db2dca6507a1"></a><a name="t32"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t33"></a><h3 class="t3"><span class="cfett">9.3.2</span> Objektidentifikation mit »toString()«  <a href="#t2t34"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t32"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Jedes Objekt sollte sich durch die Methode <span class="clisting">toString()</span> mit einer Zeichenkette identifizieren und den Inhalt der interessanten Attribute als Zeichenkette liefern.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Die Klasse <span class="clisting">Point</span> implementiert <span class="clisting">toString()</span> so, dass der Rückgabestring die Koordinaten enthält:</p>
<div class="listing"><pre class="prettyprint">System.out.println( new java.awt.Point() );  // java.awt.Point[x=0,y=0]</pre></div>
</td>
</tr>
</table><br><p>Das Angenehme ist, dass <span class="clisting">toString()</span> automatisch aufgerufen wird, wenn die Methoden <span class="clisting">print()</span> oder <span class="clisting">println()</span> mit einer Objektreferenz als Argument aufgerufen werden. Ähnliches gilt für den Zeichenkettenoperator <span class="clisting">+</span> mit einer Objektreferenz als Operand:</p>
<p class="tabunter"><strong>Listing 9.8    </strong>com/tutego/insel/object/tostring/Player.java, Player</p>
<div class="listing"><pre class="prettyprint">public class Player
{
  String name;
  int    age;

 <span class="cfett"> @Override</span>
 <span class="cfett"> public String toString()</span>
 <span class="cfett"> {</span>
   <span class="cfett"> return getClass().getName() +</span>
          <span class="cfett"> "[name=" + name +</span>
          <span class="cfett"> ",age=" + age + "]";</span>
 <span class="cfett"> }</span>
}</pre></div>
<p>Die Ausgabe mit den Zeilen</p>
<p class="tabunter"><strong>Listing 9.9    </strong>com/tutego/insel/object/tostring/PlayerToStringDemo.java, main()</p>
<div class="listing"><pre class="prettyprint">Player tinkerbelle = new Player();
tinkerbelle.name   = "Tinkerbelle";
tinkerbelle.age    = 32;
System.out.println( tinkerbelle.toString() );
System.out.println( tinkerbelle );</pre></div>
<p>ist damit:</p>
<div class="listing"><pre class="prettyprint">com.tutego.insel.object.tostring.Player[name=Tinkerbelle,age=32]
com.tutego.insel.object.tostring.Player[name=Tinkerbelle,age=32]</pre></div>
<p>Bei einer eigenen Implementierung müssen wir darauf achten, dass die Sichtbarkeit <span class="clisting">public</span> ist, da <span class="clisting">toString()</span> in der Oberklasse <span class="clisting">Object</span> öffentlich vorgegeben ist und wir in der Unterklasse die Sichtbarkeit nicht einschränken können. Zwar bringt die Spezifikation nicht deutlich zum Ausdruck, dass <span class="clisting">toString()</span> nicht <span class="clisting">null</span> als Rückgabe liefern darf, doch ist dann der Leerstring <span class="clisting">""</span> allemal besser. Die Annotation <span class="clisting">@Override</span> macht das Überschreiben deutlich.</p>
<h4 class="t4">Standardimplementierung</h4>
<p>Neue Klassen sollten <span class="clisting">toString()</span> überschreiben. Ist dies nicht der Fall, gelangt das Programm zur Standardimplementierung in <span class="clisting">Object</span>, wo lediglich der Klassenname und der wenig aussagekräftige Hash-Wert hexadezimal zusammengebunden werden.</p>
<div class="listing"><pre class="prettyprint">public String toString()
{
  return getClass().getName() + "@" + Integer.toHexString(hashCode());
}</pre></div><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">class java.lang.<span class="cfett">Object</span></pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">String toString()</span>
Liefert eine String-Repräsentation des Objekts aus Klassenname und Hash-Wert.</li>
</ul>
<p>Zwar sagt der Hash-Wert selbst wenig aus, allerdings ist er ein erstes Indiz dafür, dass bei Klassen, die keine <span class="clisting">toString()</span>- und <span class="clisting">hashCode()</span>-Methoden überschreiben, zwei Referenzen nicht identisch sind.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Ein Objekt der <span class="clisting">class A {}</span> wird gebildet, und <span class="clisting">toString()</span> liefert die ID, die ausgegeben wird:</p>
<div class="listing"><pre class="prettyprint">System.out.println( new A().toString() );  // A@923e30
System.out.println( new A().toString() );  // A@130c19b</pre></div>
</td>
</tr>
</table><br><h4 class="t4">»toString()« generieren lassen</h4>
<p>Die Methode eignet sich gut zum Debugging, doch ist das manuelle Tippen der Methoden lästig. Zwei Lösungen vereinfachen das Implementieren der Methode <span class="clisting">toString()</span>:</p>
<ul class="gp">
<li>Eclipse und NetBeans können standardmäßig über das Kontextmenü eine <span class="clisting">toString()</span>-Methode anhand ausgewählter Attribute generieren.</li>
</ul>
<ul class="gp">
<li>Die Zustände werden automatisch über Reflection ausgelesen. Hier führt <span class="ckursiv">Apache Commons Lang</span> (http://jakarta.apache.org/commons/lang/) auf den richtigen Weg.</li>
</ul><a id="mj4c33787451c2460c2eb18623b08278d9" name="mj4c33787451c2460c2eb18623b08278d9"></a><a name="t33"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t34"></a><h3 class="t3"><span class="cfett">9.3.3</span> Objektgleichheit mit »equals()« und Identität  <a href="#t2t35"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t33"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Ob zwei Referenzen dasselbe Objekt repräsentieren, stellt der Vergleichsoperator <span class="clisting">==</span> fest. Er testet die Identität, nicht jedoch automatisch die inhaltliche Gleichheit. Am Beispiel mit Zeichenketten ist das gut zu erkennen: Ein Vergleich mit <span class="clisting">firstname == "Christian"</span> hat im Allgemeinen einen falschen, unbeabsichtigten Effekt, obwohl er syntaktisch korrekt ist. An dieser Stelle sollte der inhaltliche Vergleich stattfinden: Stimmen alle Zeichen der Zeichenkette überein?</p>
<p>Eine <span class="clisting">equals()</span>-Methode sollte Objekte auf Gleichheit prüfen. So besitzt das <span class="clisting">String</span>-Objekt eine Implementierung, die jedes Zeichen vergleicht:</p>
<div class="listing"><pre class="prettyprint">String firstname = "Christian";
if ( firstname.equals( "Christian" ) )
  ...</pre></div><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">class java.lang.<span class="cfett">Object</span></pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">boolean equals( Object o )</span>
Testet, ob das andere Objekt mit dem eigenen gleich ist. Die Gleichheit definiert jede Klasse für sich anders, doch die Basisklasse vergleicht nur die Referenzen <span class="clisting">o == this</span>.</li>
</ul>
<h4 class="t4">equals()-Implementierung aus Object und Unterklassen</h4>
<p>Die Standardimplementierung aus der absoluten Oberklasse <span class="clisting">Object</span> kann über die Gleichheit von speziellen Objekten nichts wissen und testet lediglich die Referenzen:</p>
<div class="listing"><pre class="prettyprint">public boolean equals( Object obj )
{
  return  this == obj;
}</pre></div>
<p>Überschreibt eine Klasse <span class="clisting">equals()</span> nicht, ist das Ergebnis von <span class="clisting">o1.equals(o2)</span> gleichwertig mit <span class="clisting">o1 == o2</span>. Unterklassen überschreiben diese Methode, um einen inhaltlichen Vergleich mit ihren Zuständen vorzunehmen. Die Methode ist in Unterklassen gut aufgehoben, denn jede Klasse benötigt eine unterschiedliche Logik, um festzulegen, wann ein Objekt mit einem anderen Objekt gleich ist.</p>
<p>Nicht jede Klasse implementiert eine eigene <span class="clisting">equals()</span>-Methode, sodass die Laufzeitumgebung unter Umständen ungewollt bei <span class="clisting">Object</span> und seinem Referenzenvergleich landet. Dies hat ungeahnte Folgen, und diese Fehleinschätzung kommt leider bei Exemplaren der Klassen <span class="clisting">StringBuffer</span> und <span class="clisting">StringBuilder</span> vor, die kein eigenes <span class="clisting">equals()</span> implementieren. Wir haben dies bereits in Kapitel 4, »Der Umgang mit Zeichenketten«, erläutert.</p>
<h4 class="t4">Ein eigenes »equals()«</h4>
<p>Bei selbst deklarierten Methoden ist Vorsicht geboten, da wir genau auf die Signatur achten müssen. Die Methode muss ein <span class="clisting">Object</span> akzeptieren und <span class="clisting">boolean</span> zurückgeben. Wird diese Signatur falsch verwendet, kommt es statt zu einer <span class="ckursiv">Überschreibung</span> der Methode zu einer <span class="ckursiv">Überladung</span> und bei einer Rückgabe ungleich <span class="clisting">boolean</span> zu einer zweiten Methode mit gleicher Signatur, was Java nicht zulässt (Java erlaubt bisher keine kovarianten Parametertypen). Um das Problem zu minimieren, sollte die Annotation <span class="clisting">@Override</span> an <span class="clisting">equals()</span> angeheftet sein.</p>
<p>Die <span class="clisting">equals()</span>-Methode stellt einige Anforderungen:</p>
<ul class="gp">
<li>Heißt der Vergleich <span class="clisting">equals(null)</span>, so ist das Ergebnis immer <span class="clisting">false</span>.</li>
</ul>
<ul class="gp">
<li>Kommt ein <span class="clisting">this</span> hinein, lässt sich eine Abkürzung nehmen und <span class="clisting">true</span> zurückliefern.</li>
</ul>
<ul class="gp">
<li>Das Argument ist zwar vom Typ <span class="clisting">Object</span>, aber dennoch vergleichen wir immer konkrete Typen. Eine <span class="clisting">equals()</span>-Methode einer Klasse <span class="clisting">X</span> wird sich daher nur mit Objekten vom Typ <span class="clisting">X</span> vergleichen lassen. Eine spannende Frage ist, ob <span class="clisting">equals()</span> auch Unterklassen von <span class="clisting">X</span> beachten soll.</li>
</ul>
<ul class="gp">
<li>Eine Implementierung von <span class="clisting">equals()</span> sollte immer eine Implementierung von <span class="clisting">hashCode()</span> bedeuten, denn wenn zwei Objekte <span class="clisting">equals()</span>-gleich sind, müssen auch die Hashwerte gleich sein. Bei einer geerbten <span class="clisting">hashCode()</span>-Methode aus <span class="clisting">Object</span> ist das aber nicht in jedem Fall erfüllt.</li>
</ul>
<p>Die beiden ersten Punkte sind leicht erfüllbar, und ein Beispiel für einen <span class="clisting">Club</span> mit den Attributen <span class="clisting">numberOfPersons</span> und <span class="clisting">sm</span> ist schnell implementiert:</p>
<div class="listing"><pre class="prettyprint">@Override
public boolean equals( Object o )
{
  if ( o == null )
    return false;

  if ( o == this )
    return true;

  Club that = (Club) o;

  return    this.numberOfPersons == that.numberOfPersons
         &amp;&amp; this.sm == that.sm;
}</pre></div>
<p>Diese Lösung erscheint offensichtlich, führt aber spätestens bei einem Nicht-<span class="clisting">Club</span>-Objekt zu einer <span class="clisting">ClassCastException</span>. Das Problem scheint schnell behoben:</p>
<div class="listing"><pre class="prettyprint">if ( ! o instanceof Club )
  return false;</pre></div>
<p>Jetzt sind wir auf der sicheren Seite, aber das Ziel ist noch nicht ganz erreicht.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Die <span class="clisting">equals()</span>-Methode sollte bei nicht passenden Typen immer <span class="clisting">false</span> zurückgeben und keine Ausnahme auslösen.</p>
</td>
</tr>
</table><br><h4 class="t4">Das Problem der Symmetrie *</h4>
<p>Zwar funktioniert die aufgeführte Implementierung bei finalen Klassen schön, doch bei Unterklassen ist die Symmetrie gebrochen. Warum? Ganz einfach: <span class="clisting">instanceof</span> testet Typen in der Hierarchie, liefert also auch dann <span class="clisting">true</span>, wenn das an <span class="clisting">equals()</span> übergebene Argument eine Unterklasse von <span class="clisting">Club</span> ist. Diese Unterklasse wird wie die Oberklasse die gleichen Attribute haben, sodass &#8211; aus der Sicht von <span class="clisting">Club</span> &#8211; alles in Ordnung ist. Nehmen wir einmal die Varia-blen <span class="clisting">club</span> und <span class="clisting">superClub</span> an, die die Typen <span class="clisting">Club</span> und <span class="clisting">SuperClub</span> &#8211; die fiktive Unterklasse von <span class="clisting">Club</span> &#8211; besitzen. Sind beide Objekte gleich, so ergibt <span class="clisting">club.equals(superClub)</span> das Ergebnis <span class="clisting">true</span>. Drehen wir den Spieß um, und fragen wir, was <span class="clisting">superClub.equals(club)</span> ergibt. Zwar haben wir <span class="clisting">SuperClub</span> nicht implementiert, nehmen aber an, dass dort eine <span class="clisting">equals()</span>-Methode steckt, die nach dem gleichen <span class="clisting">instanceof</span>-Schema implementiert wurde wie <span class="clisting">Club</span>. Dann wird dort bei einem Test Folgendes ausgeführt: <span class="clisting">club instanceof superClub</span> &#8211; und das ist <span class="clisting">false</span>. Damit wird aber die Fallunterscheidung mit <span class="clisting">return false</span> beendet. Fassen wir zusammen:</p>
<div class="listing"><pre class="prettyprint">club.equals( superClub ) == true
superClub.equals( club ) == false</pre></div>
<p>Das darf nicht sein, und zur Lösung dürfen wir nicht <span class="clisting">instanceof</span> verwenden, sondern müssen fragen, ob der Typ exakt ist. Das geht mit <span class="clisting">getClass()</span>. Korrekt ist daher Folgendes:</p>
<p class="tabunter"><strong>Listing 9.10    </strong>com/tutego/insel/object/equals/Club.java, Club</p>
<div class="listing"><pre class="prettyprint">public class Club
{
  int numberOfPersons;
  int sm;

  @Override
  public boolean equals( Object o )
  {
    if ( o == null )
      return false;

    if ( o == this )
      return true;

   <span class="cfett"> if ( ! o.getClass().equals(getClass()) )</span>
     <span class="cfett"> return false;

    Club that = (Club) o;

    return    this.numberOfPersons == that.numberOfPersons
           &amp;&amp; this.sm   == that.sm;
  }

  @Override
  public int hashCode()
  {
    return (31 + numberOfPersons) * 31 + sm;
  }
}</span></pre></div>
<p>Die <span class="clisting">hashCode()</span>-Methode besprechen wir in Abschnitt 9.3.5, »Hashcodes über hashCode() liefern« &#8211; sie steht nur der Vollständigkeit halber hier, da <span class="clisting">equals()</span> und <span class="clisting">hashCode()</span> immer Hand in Hand gehen sollten.</p>
<p>Es ist günstig, bei erweiterten Klassen ein neues <span class="clisting">equals()</span> anzugeben, sodass auch die neuen Attribute in den Test einbezogen werden. Bei <span class="clisting">hashCode()</span>-Methoden müssen wir eine ähnliche Strategie anwenden, was wir hier nicht zeigen wollen.</p>
<h4 class="t4">Einmal gleich, immer gleich *</h4>
<p>Ein weiterer Aspekt von <span class="clisting">equals() [</span>Eine korrekte Implementierung der Methode <span class="clisting">equals()</span> bildet eine Äquivalenzrelation. Lassen wir die <span class="clisting">null</span>-Referenz außen vor, ist sie reflexiv, symmetrisch und transitiv.
]  ist der folgende: Das Ergebnis muss während der gesamten Lebensdauer eines Objekts gleich bleiben. Ein kleines Problem steckt dabei in <span class="clisting">equals()</span> der Klasse <span class="clisting">URL</span>, die vergleicht, ob zwei URL-Adressen auf die gleiche Ressource zeigen. In der Dokumentation heißt es:</p>
<p><em><span class="ckursiv">»Two URL objects are equal if they have the same protocol, reference equivalent hosts, have the same port number on the host, and the same file and fragment of the file.«</span></em></p>
<p>Hostnamen gelten als gleich, wenn entweder beide auf dieselbe IP-Adresse zeigen oder &#8211; falls eine nicht auflösbar ist &#8211; beide Hostnamen gleich (ohne Groß-/Kleinschreibung) oder <span class="clisting">null</span> sind. Da hinter den URLs http://tutego.de/ und http://java-tutor.com/ aber letztendlich http://www.tutego.com/ steckt, liefert <span class="clisting">equals()</span> die Rückgabe <span class="clisting">true</span>:</p>
<p class="tabunter"><strong>Listing 9.11    </strong>com/tutego/insel/object/equals/UrlEquals.java, main()</p>
<div class="listing"><pre class="prettyprint">URL url1 = new URL( "http://tutego.com/" );
URL url2 = new URL( "http://www.tutego.com/" );
System.out.println( url1.equals(url2) );               // true</pre></div>
<p>Die dynamische Abbildung der Hostnamen auf die IP-Adresse des Rechners kann aus mehreren Gründen problematisch sein:</p>
<ul class="gp">
<li>Der (menschliche) Leser erwartet intuitiv etwas anderes.</li>
</ul>
<ul class="gp">
<li>Wenn keine Netzwerkverbindung besteht, wird keine Namensauflösung durchgeführt, und der Vergleich liefert <span class="clisting">false</span>. Die Rückgabe sollte jedoch nicht davon abhängig sein, ob eine Netzwerkverbindung besteht.</li>
</ul>
<ul class="gp">
<li>Dass die beiden URLs auf den gleichen Server zeigen, könnte sich zur Laufzeit ändern.</li>
</ul><a id="mjf4272fd243c9ca882397f284661c5aad" name="mjf4272fd243c9ca882397f284661c5aad"></a><a name="t34"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t35"></a><h3 class="t3"><span class="cfett">9.3.4</span> Klonen eines Objekts mit »clone()« *  <a href="#t2t36"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t34"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Zum Replizieren eines Objekts gibt es oft zwei Möglichkeiten:</p>
<ul class="gp">
<li>einen Konstruktor (auch <span class="ckursiv">Copy-Constructor</span> genannt), der ein vorhandenes Objekt als Vorlage nimmt, ein neues Objekt anlegt und die Zustände kopiert</li>
</ul>
<ul class="gp">
<li>eine öffentliche <span class="clisting">clone()</span>-Methode</li>
</ul>
<p>Was eine Klasse nun anbietet, ist in der API-Dokumentation zu erfahren.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Erzeuge ein Punkt-Objekt, und klone es:</p>
<p class="tabunter"><strong>Listing 9.12    </strong>com/tutego/insel/object/clone/ClonePoint.java, main()</p>
<div class="listing"><pre class="prettyprint">java.awt.Point p = new java.awt.Point( 12, 23 );
java.awt.Point q = (java.awt.Point) p.clone();
System.out.println( q );                       // java.awt.Point[x=12,y=23]</pre></div>
<p class="BStandard">Mehr als 300 Klassen der Java-Bibliothek unterstützen ein <span class="clisting">clone()</span>, das ein neues Exemplar mit dem gleichen Zustand zurückgibt. Eine überschriebene Methode kann den Typ der Rückgabe dank kovarianter Rückgabetypen anpassen. Die <span class="clisting">clone()</span>-Methode bei <span class="clisting">java.awt.Point</span> bleibt allerdings bei <span class="clisting">Object</span>.</p>
</td>
</tr>
</table><br><p>Felder erlauben standardmäßig <span class="clisting">clone()</span>. Speichern die Arrays jedoch nicht-primitive Werte, liefert <span class="clisting">clone()</span> nur eine flache Kopie, was bedeutet, dass das neue Feldobjekt, der Klon, die exakt gleichen Objekte wie das Original referenziert und die Einträge selbst nicht klont.</p>
<h4 class="t4">»clone()« aus »java.lang.Object«</h4>
<p>Da <span class="clisting">clone()</span> nicht automatisch unterstützt wird, stellt sich die Frage, wie wir <span class="clisting">clone()</span> für unsere Klassen mit geringstem Aufwand umsetzen können. Erster Vorschlag:</p>
<div class="listing"><pre class="prettyprint">Object o = new Object();
o.clone();                   // <img src="common/totenkopf.gif" border="0" align="bottom" alt="Fehler"> Compilerfehler, da clone() nicht sichtbar ist.</pre></div><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">class java.lang.<span class="cfett">Object</span></pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">protected Object clone() throws CloneNotSupportedException</span>
Liefert eine Kopie des Objekts.</li>
</ul>
<h4 class="t4">Eine eigene clone()-Methode</h4>
<p>Eigene Klassen überschreiben die <span class="clisting">protected</span>-Methode <span class="clisting">clone()</span> aus der Oberklasse <span class="clisting">java     .lang.Object</span> und machen sie <span class="clisting">public</span>. Für die Implementierung kommen zwei Möglichkeiten in Betracht:</p>
<ul class="gp">
<li>Von Hand ein neues Objekt anlegen, alle Attribute kopieren und die Referenz auf das neue Objekt zurückgeben.</li>
</ul>
<ul class="gp">
<li>Das Laufzeitsystem soll selbst eine Kopie anlegen, und diese geben wir zurück. Lösung zwei verkürzt die Entwicklungszeit und ist auch spannender.</li>
</ul>
<p>Um das System zum Klonen zu bewegen, müssen zwei Dinge getan werden:</p>
<ul class="gp">
<li>Der Aufruf <span class="clisting">super.clone()</span> stößt die Methode <span class="clisting">clone()</span> aus <span class="clisting">Object</span> an und veranlasst so die Laufzeitumgebung, ein neues Objekt zu bilden und die nicht-statischen Attribute zu kopieren. Die Methode kopiert elementweise die Daten des aktuellen Objekts in das neue. Die Methode ist in der Oberklasse <span class="clisting">protected</span>, aber das ist der Trick: Nur Unterklassen können <span class="clisting">clone()</span> aufrufen, keiner sonst.</li>
</ul>
<ul class="gp">
<li>Die Klasse implementiert die Markierungsschnittstelle <span class="clisting">Cloneable</span>. Falls von außen ein <span class="clisting">clone()</span> auf einem Objekt aufgerufen wird, dessen Klasse nicht <span class="clisting">Cloneable</span> implementiert, ist das Ergebnis eine <span class="clisting">CloneNotSupportedException</span>. Natürlich implementiert <span class="clisting">java     .lang.Object</span> die Schnittstelle <span class="clisting">Cloneable</span> nicht selbst, denn sonst hätten ja Klassen schon automatisch diesen Typ, was sinnlos wäre.</li>
</ul>
<p><span class="clisting">clone()</span> gibt eine Referenz auf das neue Objekt zurück, und wenn es keinen freien Speicher mehr gibt, folgt ein <span class="clisting">OutOfMemoryError</span>.</p>
<p>Nehmen wir an, für ein Spiel sollen <span class="clisting">Player</span> geklont werden:</p>
<p class="tabunter"><strong>Listing 9.13    </strong>com/tutego/insel/object/clone/Player.java</p>
<div class="listing"><pre class="prettyprint">package com.tutego.insel.object.clone;

public class Player<span class="cfett"> implements Cloneable</span>
{
  public String name;
  public int    age;

 <span class="cfett"> @Override</span>
 <span class="cfett"> public Player clone()</span>
 <span class="cfett"> {</span>
   <span class="cfett"> try</span>
   <span class="cfett"> {</span>
     <span class="cfett"> return (Player) super.clone();</span>
   <span class="cfett"> }</span>
   <span class="cfett"> catch ( CloneNotSupportedException e ) {</span>
     <span class="cfett"> // Kann eigentlich nicht passieren, da Cloneable</span>
     <span class="cfett"> throw new InternalError();</span>
   <span class="cfett"> }</span>
 <span class="cfett"> }</span>
}</pre></div>
<p>Da es seit Java 5 kovariante Rückgabetypen gibt, gibt <span class="clisting">clone()</span> nicht lediglich <span class="clisting">Object</span>, sondern den Untertyp <span class="clisting">Player</span> zurück.</p>
<div class="bildbox">
<p><a name="IDADI1D"></a><a onClick="OpenWin('bilder/playerclone.gif','Abbildung',800,800)"><img border="0" src="bilderklein/kleinplayerclone.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p>Testen wir die Klasse etwa so:</p>
<p class="tabunter"><strong>Listing 9.14    </strong>com/tutego/insel/object/clone/PlayerCloneDemo.java, main()</p>
<div class="listing"><pre class="prettyprint">Player susi = new Player();
susi.age  = 29;
susi.name = "Susi";
Player dolly =<span class="cfett"> susi.clone()</span>;
System.out.println( dolly.name + " ist " + dolly.age ); // Susi ist 29</pre></div>
<h4 class="t4">»clone()« und »equals()«</h4>
<p>Die Methode <span class="clisting">clone()</span> und die Methode <span class="clisting">equals()</span> hängen, wie auch <span class="clisting">equals()</span> und <span class="clisting">hashCode()</span>, miteinander zusammen. Wenn die <span class="clisting">clone()</span>-Methode überschrieben wird, sollte auch <span class="clisting">equals()</span> angepasst werden, denn ohne ein überschriebenes <span class="clisting">equals()</span> bleibt Folgendes in <span class="clisting">Object</span> stehen:</p>
<div class="listing"><pre class="prettyprint">public boolean equals( Object obj )
{
  return (this == obj);
}</pre></div>
<p>Das bedeutet aber, dass ein geklontes Objekt &#8211; das ja im Allgemeinen ein neues Objekt ist &#8211; durch seine neue Objektidentität nicht mehr <span class="clisting">equals()</span>-gleich zu seinem Erzeuger ist. Formal heißt das: <span class="clisting">o.clone().equals(o) == false</span>. Diese Semantik dürfte nicht erwünscht sein.</p>
<h4 class="t4">Flach oder tief?</h4>
<p>Das <span class="clisting">clone()</span> vom System erzeugt standardmäßig eine <span class="ckursiv">flache Kopie</span> (engl. <span class="ckursiv">shallow copy</span>). Bei untergeordneten Objekten werden nur die Referenzen kopiert, und das Originalobjekt sowie die Kopie verweisen anschließend auf dieselben untergeordneten Objekte (sie verwenden diese gemeinsam). Wenn zum Beispiel die Bedienung ein Attribut für einen Arbeitgeber besitzt und eine Kopie der Bedienung erzeugt wird, wird der Klon auf den gleichen Arbeitgeber zeigen. Bei einem Arbeitgeber mag das noch stimmig sein, aber bei Datenstrukturen ist mitunter eine <span class="ckursiv">tiefe Kopie</span>  (engl. <span class="ckursiv">deep copy</span>) erwünscht. Bei dieser Variante werden rekursiv alle Unterobjekte ebenfalls geklont. Die Bibliotheksimplementierung hinter <span class="clisting">Object</span> kann das nicht.</p>
<h4 class="t4">Keine Klone bitte!</h4>
<p>Wenn wir weder flach noch tief kopieren wollen, aber zum Beispiel aus der Oberklasse <span class="clisting">clone()</span> erben, können wir mit einer <span class="clisting">CloneNotSupportedException</span> anzeigen, dass wir nicht geklont werden wollen.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Erben wir von einer Klasse mit implementierter <span class="clisting">clone()</span>-Methode, die ihrerseits mit <span class="clisting">super.clone()</span> arbeitet, bekommen wir von oben gleich auch die eigenen Zustände kopiert.</p>
</td>
</tr>
</table><br><a id="mj7fe8f3d9fd296c97017de07898eebccc" name="mj7fe8f3d9fd296c97017de07898eebccc"></a><a name="t35"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t36"></a><h3 class="t3"><span class="cfett">9.3.5</span> Hashcodes über »hashCode()« liefern *  <a href="#t2t37"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t35"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Die Methode <span class="clisting">hashCode()</span> soll zu jedem Objekt eine möglichst eindeutige Integerzahl (sowohl positiv als auch negativ) liefern, die das Objekt identifiziert. Die Ganzzahl heißt <span class="ckursiv">Hashcode</span> beziehungsweise <span class="ckursiv">Hash-Wert</span>, und <span class="clisting">hashCode()</span> ist die Implementierung einer <span class="ckursiv">Hash-Funktion</span>. Nötig sind Hashcodes, wenn die Objekte in speziellen Datenstrukturen untergebracht werden, die nach dem Hashing-Verfahren arbeiten. Datenstrukturen mit Hashing-Algorithmen bieten einen effizienten Zugriff auf ihre Elemente. Die Klasse <span class="clisting">java.util.HashMap</span> implementiert eine solche Datenstruktur.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">class java.lang.<span class="cfett">Object</span></pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">int hashCode()</span>
Liefert den Hash-Wert eines Objekts. Die Basisklasse <span class="clisting">Object</span> implementiert die Methode nativ.</li>
</ul>
<h4 class="t4">Spieler mit Hash-Funktion</h4>
<p>Im folgenden Beispiel soll die Klasse <span class="clisting">Player</span> die Methode <span class="clisting">hashCode()</span> aus <span class="clisting">Object</span> überschreiben. Um die Objekte erfolgreich in einem Assoziativspeicher abzulegen, ist gleichfalls <span class="clisting">equals()</span> nötig, was die Klasse <span class="clisting">Player</span> ebenfalls implementiert:</p>
<p class="tabunter"><strong>Listing 9.15    </strong>com/tutego/insel/object/hashcode/Player.java</p>
<div class="listing"><pre class="prettyprint">package com.tutego.insel.object.hashcode;

public class Player
{
  String name;
  int    age;
  double weight;

  /**
   * Returns a hash code value for this {@code Player} object.
   *
   * @return A hash code value for this object.
   *
   * @see java.lang.Object#equals(java.lang.Object)
   * @see java.util.HashMap
   */
 <span class="cfett"> @Override public int hashCode()</span>
 <span class="cfett"> {</span>
   <span class="cfett"> int result = 31 + age;</span>
   <span class="cfett"> result = 31 * result + ((name == null) ? 0 : name.hashCode());</span>
   <span class="cfett"> long temp = Double.doubleToLongBits( weight );</span>
   <span class="cfett"> result = 31 * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));

    return result;</span>
 <span class="cfett"> }
</span><span class="clisting">
  /**
   * Determines whether or not two players are equal. Two instances of
   * {@code Player} are equal if the values of their {@code name}, {@code age}
   * and {@code weight} member fields are the same.
   *
   * @param that an object to be compared with this {@code Player}
   *
   * @return {@code true} if the object to be compared is an instance of
   *         {@code Player} and has the same values; {@code false} otherwise.
   */
  @Override public boolean equals( Object that )
  {
    if ( this == that )
      return true;

    if ( that == null )
      return false;

    if ( getClass() != that.getClass() )
      return false;

    if ( age != ((Player)that).age )
      return false;

    if ( name == null )
      if ( ((Player)that).name != null )
        return false;
    else if ( !name.equals( ((Player)that).name ) )
      return false;

    return !( Double.doubleToLongBits( weight ) != </span><img src="common/umbruch.gif" border="0" alt="Umbruch"><span class="clisting">
              Double.doubleToLongBits( ((Player)that).weight ) );
  }
}</span></pre></div>
<p>Testen können wir die Klasse etwa mit den folgenden Zeilen:</p>
<p class="tabunter"><strong>Listing 9.16    </strong>com/tutego/insel/object/hashcode/PlayerHashcodeDemo.java, main()</p>
<div class="listing"><pre class="prettyprint">Player bruceWants = new Player();
bruceWants.name = "Bruce Wants";
bruceWants.age = 32;
bruceWants.weight = 70.3;

Player bruceLii = new Player();
bruceLii.name = "Bruce Lii";
bruceLii.age = 32;
bruceLii.weight = 70.3;;

System.out.println( bruceWants.hashCode() );                 // &#8211;340931147
System.out.println( bruceLii.hashCode() );                   // 301931244
System.out.println( System.identityHashCode( bruceWants ) ); // 1671711
System.out.println( System.identityHashCode( bruceLii ) );   // 11394033
System.out.println( bruceLii.equals( bruceWants ) );         // false

bruceWants.name = "Bruce Lii";
System.out.println( bruceWants.hashCode() );                 // 301931244
System.out.println( bruceLii.equals( bruceWants ) );         // true</pre></div>
<p>Die statische Methode <span class="clisting">System.identityHashCode()</span> liefert für ein Objekt den Hashcode, wie es die Standard-Implementierung von <span class="clisting">Object</span> liefern würde, wenn wir sie nicht überschrieben hätten.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Da der Hashcode negativ sein kann, muss Obacht gegeben werden bei Ausdrücken wie <span class="clisting">array[o.hashCode() % array.length()]</span>. Ist <span class="clisting">o.hashCode()</span> negativ, ist auch das Ergebnis vom Restwert negativ, und die Folge ist eine <span class="clisting">ArrayIndexOutOfBoundsException</span>.</p>
</td>
</tr>
</table><br><p><div class="eclipse"><img src="common/eclipseicon.gif" align="top" width="53" height="23" alt="Eclipse" title="Eclipse"></div>Eclipse kann die Methoden <span class="clisting">hashCode()</span> und <span class="clisting">equals()</span> automatisch generieren, wenn wir im Kontextmenü unter <span class="kapitalchen">Source</span> 
    •
   <span class="kapitalchen">Generate Hashcode and equals()</span> auswählen.</p>
<h4 class="t4">Tiefe oder flache Vergleiche/Hash-Werte</h4>
<p>Referenziert ein Objekt Unterobjekte (etwa eine Person ein String-Objekt für den Namen &#8211; keine Primitiven &#8211;, so geben die Methoden <span class="clisting">equals()</span> und <span class="clisting">hashCode()</span>den Vergleich beziehungsweise die Berechnung des Hashcodes an das referenzierte Unterobjekt weiter (wenn es denn nicht <span class="clisting">null</span> ist). Ablesen können wir das an folgendem Ausschnitt unserer <span class="clisting">equals()</span>-Methode:</p>
<p class="tabunter"><strong>Listing 9.17    </strong>com/tutego/insel/object/hashcode/Player.java, equals() Ausschnitt</p>
<div class="listing"><pre class="prettyprint">if ( name == null )
  if ( ((Player)that).name != null )
    return false;
else if ( !<span class="cfett">name.equals( ((Player)that).name</span> ) )
  return false;</pre></div>
<p>Es ist demnach die Aufgabe der <span class="clisting">String</span>-Klasse (<span class="clisting">name</span> ist vom Typ <span class="clisting">String</span>), den Gleichheitstest vorzunehmen. Das heißt, dass zwei Personen problemlos <span class="clisting">equals()</span>-gleich sein können, auch wenn sie zwei nicht-identische, aber <span class="clisting">equals()</span>-gleiche <span class="clisting">String</span>-Objekte referenzieren.</p>
<p>Auch bei <span class="clisting">hashCode()</span> ist diese Delegation an das referenzierte Unterobjekt abzulesen:</p>
<p class="tabunter"><strong>Listing 9.18    </strong>com/tutego/insel/object/hashcode/Player.java, hashCode() Ausschnitt</p>
<div class="listing"><pre class="prettyprint">result = 31 * result + ((name == null) ? 0 :<span class="cfett"> name.hashCode()</span>);</pre></div>
<p>Dass eine <span class="clisting">equals()</span>-Methode beziehungsweise <span class="clisting">hashCode()</span> einer Klasse den Vergleich beziehungsweise die Hashcode-Berechnung nicht an die Unterobjekte delegiert, sondern selbst umsetzt, ist unüblich.</p>
<h4 class="t4">»equals()«- und »hashCode()«-Berechnung bei (mehrdimensionalen) Arrays</h4>
<p>Einen gewissen Sonderfall bei <span class="clisting">equals()</span>/<span class="clisting">hashCode()</span> nehmen mehrdimensionale Arrays ein. Mehrdimensionale Arrays sind nichts anderes als Arrays von Arrays. Das erste Array für die erste Dimension referenziert jeweils auf Unterarrays für die zweite Dimension. Wichtig wird diese Realisierung bei der Frage, wie diese Verweise der ersten Dimension nun bei <span class="clisting">equals()</span> betrachtet werden sollen. Denn hier stellt sich die Frage, ob die Unterarrays von zwei zu testenden Arrays nur identisch oder auch gleich sein dürfen. Diese Frage hatten wir schon im Abschnitt »Felder vergleichen mit Arrays.equals() und Arrays.deepEquals()« in Abschnitt 3.7.15 angesprochen.</p>
<p>Enthält unsere Klasse ein Array und soll es in einem <span class="clisting">equals()</span> mit berücksichtigt werden, so sind prinzipiell drei Varianten zum Umgang mit diesem Array möglich. Felder selbst einfach mit <span class="clisting">==</span> wie primitive Werte zu vergleichen ist keine gute Lösung, da Arrays Objekte sind, die wie Strings nicht einfach mit <span class="clisting">==</span> zu vergleichen sind. Während allerdings Objekte ein <span class="clisting">equals()</span> haben, bieten Arrays keine eigene <span class="clisting">equals()</span>-Methode, sondern diese ist in die Utility-Klasse <span class="clisting">Arrays</span> gewandert. Hier gibt es jedoch zwei Methoden, die in Frage kämen. <span class="clisting">Arrays.equals(Object[] a, Object[] a2)</span>  geht jedes Element von <span class="clisting">a</span>, also bei mehrdimensionalen Arrays jede Referenz auf ein Unterarray durch, und testet, ob es identisch mit einem zweiten Feld <span class="clisting">a2</span> ist. Wenn also zwei gleiche, aber nicht-identische Hauptarrays identische Unterarrays besitzen, liefert <span class="clisting">Arrays.equals()</span> die Rückgabe <span class="clisting">true</span>, aber nicht, wenn die Unterarrays zwar gleich, aber nicht identisch sind. Spielt das eine Rolle, so ist <span class="clisting">Arrays.deep-Equals()</span> die passende Methode, denn sie fragt immer mit <span class="clisting">equals()</span> die Unterarrays ab.</p>
<p>Bei der Berechnung des Hash-Werts gibt es eine vergleichbare Frage. Die <span class="clisting">Arrays</span>-Klasse bietet zur Berechnung des Hash-Werts eines ganzen Arrays die Methoden <span class="clisting">Arrays.hashCode()</span> und <span class="clisting">Arrays.deepHashCode()</span>. Die erste Methode fragt jedes Unterelement über die von <span class="clisting">Object</span> angebotene Methode <span class="clisting">hashCode()</span> nach dem Hash-Wert. Nehmen wir ein mehrdimensionales Array an. Dann ist das Unterelement ebenfalls ein Feld. <span class="clisting">Arrays.hashCode()</span> wird dann wie erwähnt nur die <span class="clisting">hashCode()</span>-Methode auf dem Feld-Objekt aufrufen, während <span class="clisting">Arrays.deep-HashCode()</span> auch in das Unterarray hinabsteigt und so lange <span class="clisting">Arrays.deepHashCode()</span> auf allen Unterfeldern aufruft, bis ein <span class="clisting">equals()</span>-Vergleich auf einem Nicht-Feld möglich ist.</p>
<p>Was heißt das nun für unsere <span class="clisting">equals()</span>-/<span class="clisting">hashCode()</span>-Methode? Üblich ist der Einsatz von <span class="clisting">Arrays.equals()</span> und nicht von <span class="clisting">Arrays.deepEquals()</span>, genauso wie <span class="clisting">Arrays.hashCode()</span> üblicher als <span class="clisting">Arrays.deepHashCode()</span> ist.</p>
<p>Das folgende Beispiel zeigt das in der Anwendung. Die Methoden wurden von Eclipse generiert und etwas kompakter geschrieben:</p>
<p class="tabunter"><strong>Listing 9.19    </strong>com/tutego/insel/object/hashcode/Chess.java, Chess</p>
<div class="listing"><pre class="prettyprint">char[][] chessboard = new char[8][8];

@Override public int hashCode()
{
  return 31 +<span class="cfett"> Arrays.hashCode( chessboard</span><span class="cfett"> </span><span class="cfett">)</span>;
}

@Override public boolean equals( Object obj )
{
  if ( this == obj )
    return true;
  if ( obj == null )
    return false;
  if ( getClass() != obj.getClass() )
    return false;
  if ( !<span class="cfett"> Arrays.equals( chessboard, ((Chess) obj).chessboard )</span> )
    return false;
  return true;
}</pre></div>
<h4 class="t4">Fließkommazahlen im Hashcode</h4>
<p>Abhängig von den Datentypen sehen die Berechnungen immer etwas unterschiedlich aus. Während Ganzzahlen direkt in einen Ganzzahlausdruck für den Hashcode eingebracht werden können, sind im Fall von <span class="clisting">double</span> die statischen Konvertierungsmethoden <span class="clisting">Double.doubleToLongBits()</span> beziehungsweise <span class="clisting">Float.floatToIntBits()</span> im Einsatz.</p>
<p>Die Datentypen <span class="clisting">double</span> und <span class="clisting">float</span> haben eine weitere Spezialität, da <span class="clisting">NaN</span> und das Vorzeichen der 0 zu beachten sind, wie Kapitel 12, »Bits und Bytes und Mathematisches«, näher ausführt. Fazit: Sind <span class="clisting">x =</span> <span class="cfett">+</span><span class="clisting">0.0</span> und <span class="clisting">y = &#8211;0.0</span>, gilt <span class="clisting">x</span> <span class="cfett">==</span> <span class="clisting">y</span>, aber <span class="clisting">Double.doubleToLongBits(x)</span>                        <span class="cfett">!=</span> <span class="clisting">Double.doubleToLongBits(y).</span> Sind <span class="clisting">x = y = Double.NaN</span>, gilt <span class="clisting">x</span> <span class="cfett">!=</span> <span class="clisting">y</span>, aber <span class="clisting">Double.doubleToLongBits(x)</span> <span class="cfett">==</span> <span class="clisting">Double.doubleToLongBits(y)</span>. Wollen wir die beiden Nullen <span class="ckursiv">nicht</span> unterschiedlich behandeln, sondern als gleich werten, ist Folgendes ein übliches Idiom:</p>
<div class="listing"><pre class="prettyprint">x == 0.0 ? 0L : Double.doubleToLongBits( x )</pre></div>
<p><span class="clisting">Double.doubleToLongBits(0.0)</span> liefert die Rückgabe 0, aber der Aufruf <span class="clisting">Double.doubleToLongBits(-0.0)</span> gibt &#8211;9223372036854775808 zurück.</p>
<h4 class="t4">Equals, die Null und das Hashen</h4>
<p>Inhaltlich gleiche Objekte (gemäß der Methode <span class="clisting">equals()</span>) müssen denselben Wert bekommen.</p>
<p>Die beiden Methoden <span class="clisting">hashCode()</span> und <span class="clisting">equals()</span> hängen miteinander zusammen, sodass in der Regel bei der Implementierung einer Methode auch eine Implementierung der anderen notwendig wird. Denn es gilt, dass bei Gleichheit natürlich auch die Hash-Werte übereinstimmen müssen. Formal gesehen heißt das:</p>
<div class="listing"><pre class="prettyprint">x.equals( y ) =>   x.hashCode() == y.hashCode()</pre></div>
<p>So berechnet sich der Hashcode bei <span class="clisting">Point</span>-Objekten aus den Koordinaten. Zwei Punkt-Objekte, die inhaltlich gleich sind, haben die gleichen Koordinaten und damit auch den gleichen Hashcode. Wenn Objekte den gleichen Hashcode aufweisen, aber nicht gleich sind, handelt es sich um eine Kollision und den Fall, dass in der Gleichung nicht die Äquivalenz gilt.</p><a id="mj719f4e662e9ffafee33ad5d59fdc0dbb" name="mj719f4e662e9ffafee33ad5d59fdc0dbb"></a><a name="t36"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t37"></a><h3 class="t3"><span class="cfett">9.3.6</span> Aufräumen mit »finalize()« *  <a href="#t2t38"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t36"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Einen <span class="ckursiv">Destruktor</span>, der wie in C++ am Ende eines Gültigkeitsbereichs einer Variable aufgerufen wird, gibt es in Java nicht. Wohl ist es möglich, eine Methode <span class="clisting">finalize()</span> für Aufräumarbeiten zu überschreiben, die <span class="ckursiv">Finalizer</span> genannt wird (ein Finalizer hat nichts mit dem <span class="clisting">finally</span>-Block einer Exception-Behandlung zu tun). Der Garbage-Collector ruft die Methode immer dann auf, wenn er ein Objekt entfernen möchte. Es kann allerdings sein, dass <span class="clisting">finalize()</span> überhaupt nicht aufgerufen wird, und zwar dann, wenn die virtuelle Maschine Fantastillionen Megabyte an Speicher hat und dann beendet wird &#8211; in dem Fall gibt sie den Heap-Speicher als Ganzes dem Betriebssystem zurück. Ohne Garbage-Collector (GC) als Grabträger gibt es auch kein <span class="clisting">finalize()</span>! Und wann der Garbage-Collector in Aktion tritt, ist auch nicht vorhersehbar, sodass im Gegensatz zu C++ in Java keine Aussage über den Zeitpunkt möglich ist, zu dem das Laufzeitsystem <span class="clisting">finalize()</span> aufruft. Es ist von der Implementierung des GC abhängig. Üblicherweise werden aber Objekte mit <span class="clisting">finalize()</span> von einem extra GC behandelt, und der arbeitet langsamer als der normale GC.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">class java.lang.<span class="cfett">Object</span></pre></div>
</td>
</tr>
</table><br><ul class="gp">
<li><span class="clisting">protected void finalize() throws Throwable</span>
Wird vom GC aufgerufen, wenn es auf dieses Objekt keinen Verweis mehr gibt. Die Methode ist geschützt, weil sie von uns nicht aufgerufen wird. Auch wenn wir die Methode überschreiben, sollten wir die Sichtbarkeit nicht erhöhen, also <span class="clisting">public</span> setzen.</li>
</ul><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" rowspan="2">
<p class="BStandard"><span class="cfett">Hinweis   </span>Klassen sollten <span class="clisting">finalize()</span> überschreiben, um wichtige Ressourcen zur Not freizugeben, etwa File-Handles via <span class="clisting">close()</span> oder Grafik-Kontexte des Betriebssystems, wenn der Entwickler das vergessen hat. Alle diese Freigaben müssten eigentlich vom Entwickler angestoßen werden, und <span class="clisting">finalize()</span> ist nur ein Helfer, der rettend eingreifen kann. Da der GC <span class="clisting">finalize()</span> nur dann aufruft, wenn er tote Objekte freigeben möchte, dürfen wir uns nicht auf die Ausführung verlassen. Gehen zum Beispiel die File-Handles aus, wird der GC nicht aktiv; es erfolgen keine <span class="clisting">finalize()</span>-Aufrufe, und nicht mehr erreichbare, aber noch nicht weggeräumte Objekte belegen weiter die knappen File-Handles.</p>
</td>
</tr>
</table><br><h4 class="t4">Einmal Finalizer, vielleicht mehrmals der GC</h4>
<p>Objekte von Klassen, die eine <span class="clisting">finalize()</span>-Methode besitzen, kann Oracles JVM nicht so schnell erzeugen und entfernen wie Klassen ohne <span class="clisting">finalize()</span>. Das liegt auch daran, dass der GC vielleicht mehrmals laufen muss, um das Objekt zu löschen. Es gilt zwar, dass der GC aus dem Grund <span class="clisting">finalize()</span> aufruft, weil das Objekt nicht mehr benötigt wird, es kann aber sein, dass aus der <span class="clisting">finalize()</span>-Methode die <span class="clisting">this</span>-Referenz nach außen gegeben wurde, sodass das Objekt wegen einer bestehenden Referenz nicht gelöscht werden kann. Das Objekt wird zwar irgendwann entfernt, aber der Finalizer läuft nur einmal und nicht immer pro GC-Versuch. Einige Hintergründe erfährt der Leser unter http://www.iecc.com/gclist/GC-lang.html#Finalization.</p>
<p>Löst eine Anweisung in <span class="clisting">finalize()</span> eine Ausnahme aus, so wird diese ignoriert. Das bedeutet aber, dass die Finalisierung des Objekts stehen bleibt. Den GC beeinflusst das in seiner Arbeit aber nicht.</p>
<h4 class="t4">super.finalize()</h4>
<p>Überschreiben wir in einer Unterklasse <span class="clisting">finalize()</span>, dann müssen wir auch gewährleisten, dass die Methode <span class="clisting">finalize()</span> der Oberklasse aufgerufen wird. So besitzt zum Beispiel die Klasse <span class="clisting">Font</span> ein <span class="clisting">finalize()</span>, das durch eine eigene Implementierung nicht verschwinden darf. Wir müssen daher in unserer Implementierung <span class="clisting">super.finalize()</span> aufrufen (es wäre gut, wenn der Compiler das wie beim Konstruktoraufruf immer automatisch machen würde …). Leere <span class="clisting">finalize()</span>-Methoden ergeben im Allgemeinen keinen Sinn, es sei denn, das <span class="clisting">finalize()</span> der Oberklasse soll explizit übergangen werden:</p>
<p class="tabunter"><strong>Listing 9.20    </strong>com/tutego/insel/object/finalize/SuperFont.java, finalize()</p>
<div class="listing"><pre class="prettyprint">@Override protected void finalize() throws Throwable
{
  try {
    // ...
  }
  finally {
   <span class="cfett"> super.finalize();</span>
  }
}</pre></div>
<p>Der Block vom <span class="clisting">finally</span> wird immer ausgeführt, auch wenn es im oberen Teil eine Ausnahme gab.</p>
<p>Die Methode von Hand aufzurufen, ist ebenfalls keine gute Idee, denn das kann zu Problemen führen, wenn der GC-Thread die Methode auch gerade aufruft. Um das Aufrufen von außen einzuschränken, sollte die Sichtbarkeit von <span class="clisting">protected</span> bleiben und nicht erhöht werden.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Da beim Programmende vielleicht nicht alle <span class="clisting">finalize()</span>-Methoden abgearbeitet wurden, haben die Entwickler schon früh einen Methodenaufruf <span class="clisting">System.runFinalizersOn-Exit</span><span class="clisting">(true);</span> vorgesehen. Mittlerweile ist die Methode veraltet und sollte auf keinen Fall aufgerufen werden. Die API-Dokumentation erklärt:</p>
<p class="BStandard"><span class="ckursiv">»It may result in finalizers being called on live objects while other threads are concurrently manipulating those objects, resulting in erratic behavior or deadlock.«</span></p>
<p class="BStandard">Dazu auch Joshua Bloch, Autor des ausgezeichneten Buchs »Effective Java Programming Language Guide«:</p>
<p class="BStandard"><span class="ckursiv">»Never call System.runFinalizersOnExit or Runtime.runFinalizersOnExit for any reason: they are among the most dangerous methods in the Java libraries.«</span></p>
</td>
</tr>
</table><br><a id="mjaa2ddfc2bae3f5cf4c8a3427a2ed1555" name="mjaa2ddfc2bae3f5cf4c8a3427a2ed1555"></a><a name="t37"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t38"></a><h3 class="t3"><span class="cfett">9.3.7</span> Synchronisation *  <img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"><a href="#t2t37"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Threads können miteinander kommunizieren und dabei Daten teilen. Sie können außerdem auf das Eintreten bestimmter Bedingungen warten, zum Beispiel auf neue Eingabedaten. Die Klasse <span class="clisting">Object</span> deklariert insgesamt fünf Versionen der Methoden <span class="clisting">wait()</span>, <span class="clisting">notify()</span> und <span class="clisting">notifyAll()</span> zur Beendigungssynchronisation von Threads. Kapitel 14, »Threads und nebenläufige Programmierung«, geht näher auf die Programmierung von Threads ein.</p><br><hr><a name="kommentar"></a><h3>Ihr Kommentar</h3>
                       Wie hat Ihnen das &lt;openbook&gt; gefallen? Wir freuen uns immer über Ihre freundlichen und kritischen Rückmeldungen.
                       <form action="http://www.galileo-press.de/feedback/openbook" method="post" style="text-align: center; margin-top: 10px;"><input type="hidden" name="openbookurl" value="javainsel9/.htm"><input type="hidden" name="buchtitel" value="Java ist auch eine Insel"><input type="hidden" name="Kapitel" value="9.3 Object ist die Mutter aller Klassen"><table border="0">
<tr>
<td><label for="name">Name</label><br></td>
<td><input type="text" name="name" id="name" size="40"><br></td>
</tr>
<tr>
<td><label for="email">E-Mail</label><br></td>
<td><input type="text" name="email" id="email" size="40"><br></td>
</tr>
<tr>
<td valign="top"><label for="comment">Ihr Kommentar</label><br></td>
<td><textarea name="comment" id="comment" rows="10" cols="40"></textarea><br></td>
</tr>
<tr>
<td>
</td>
<td><input type="submit" value="Kommentar absenden"></td>
</tr>
</table>
</form>
</div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="javainsel_09_002.htm" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a class="navnav" href="#">&lt;top&gt;</a></div></td>
<td align="right" width="25%"><div align="right"><a href="javainsel_09_004.htm" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
</table>
</div></td>
<td width="10" valign="top">  </td>
<td width="160" valign="top">
<table border="0" cellpadding="0" cellspacing="0" width="160">
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2">
&nbsp;<a href="http://www.galileocomputing.de/katalog/buecher/?GPP=opjiVIV" class="autor">
<strong>Zum Katalog</strong></a>

</td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2">
<img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV">
<img src="common/9783836215060_s.gif" width="119" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Java ist auch eine Insel" title="Zum Katalog: Java ist auch eine Insel">
<br><br><br><br><br><br><strong>Java ist auch eine Insel</strong><br><img src="common/pfeil_rechts5.gif" border="0" alt="">Jetzt bestellen</a><br /><br />
</td>
</tr>
</table>
</td>

</tr>
</table>
</td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2"><span class="autor"><strong>&nbsp;Ihre Meinung?</strong></a></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">

<table cellspacing="3">
<tr>
<td>Wie hat Ihnen das &lt;openbook&gt; gefallen?<br><a href="#kommentar"><img src="common/pfeil_rechts5.gif" border="0" alt="">Ihre Meinung</a>
<br><br></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>

<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>
<tr>
<td>
</td>
</tr>

<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2">&nbsp;<a href="http://www.galileocomputing.de/katalog/buecher/?GPP=opjiVIV" class="autor"><strong>Buchempfehlungen</strong></a></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2285?GPP=opjiVIV">
<img src="common/9783836215275_s.gif" width="102" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Computergeschichte(n) – nicht nur für Geeks" title="Zum Katalog: Computergeschichte(n) – nicht nur für Geeks"><br><br><br><br><br><br>&nbsp;Computergeschichte(n)<br>&nbsp;nicht nur für Geeks</a><br><br></td>
</tr>

<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/1949?GPP=opjiVIV">
<img src="common/9783836213080_s.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Java und XML" title="Zum Katalog: Java und XML"><br><br><br><br><br><br><br>&nbsp;Java und XML</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2346?GPP=opjiVIV">
<img src="common/9783836215688_s.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Einstieg in Java" title="Zum Katalog: Einstieg in Java"><br><br><br><br><br><br><br>&nbsp;Einstieg<br>&nbsp;in Java</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2051?GPP=opjiVIV">

<img src="common/9783836213677_s.gif" width="112" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Einstieg in XML" title="Zum Katalog: Einstieg in XML"><br><br><br><br><br><br><br>&nbsp;Einstieg<br>&nbsp;in XML</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2322?GPP=opjiVIV">
<img src="common/9783836215527_s.gif" width="112" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Visual C# 2010" title="Zum Katalog: Visual C# 2010"><br><br><br><br><br><br><br>&nbsp;Visual C# 2010</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2212?GPP=opjiVIV">
<img src="common/9783836214742_s.gif" width="119" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Professionell entwickeln mit Visual C# 2010" title="Zum Katalog: Professionell entwickeln mit Visual C# 2010"><br><br><br><br><br><br><br>&nbsp;Professionell<br>&nbsp;entwickeln mit<br>&nbsp;Visual C# 2010</a><br><br></td>
</tr>

<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2156?GPP=opjiVIV">
<img src="common/9783836214292_s.gif" width="108" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C++ von A bis Z" title="Zum Katalog: C++ von A bis Z"><br><br><br><br><br><br><br>&nbsp;C++ von A bis Z</a><br><br></td>
</tr>
</table></td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>

<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2"><span class="autor"><strong>&nbsp;Shopping</strong></span></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><b>Versandkostenfrei</b> bestellen in Deutschland und &Ouml;sterreich<br><a href="http://www.galileocomputing.de/hilfe/Shop/?GPP=opjiVIV"><img src="common/pfeil_rechts5.gif" border="0" alt="Info">Info</a><br><br></td>

</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table><br><br><hr width="70%" align="center">
<div align="center">
<p class="standard"><strong>Copyright © Galileo Press 2011</strong><br>
        Für Ihren privaten Gebrauch dürfen Sie die Online-Version natürlich ausdrucken.
        Ansonsten unterliegt das &lt;openbook&gt; denselben Bestimmungen, wie die
        gebundene Ausgabe: Das Werk einschließlich aller seiner Teile ist urheberrechtlich
        geschützt. Alle Rechte vorbehalten einschließlich der Vervielfältigung, Übersetzung,
        Mikroverfilmung sowie Einspeicherung und Verarbeitung in elektronischen Systemen.</p><br><a href="http://www.galileocomputing.de/">[Galileo Computing]</a><br><br>
      Galileo Press, Rheinwerkallee 4, 53227 Bonn, Tel.: 0228.42150.0, Fax 0228.42150.77, <a href="mailto:info@galileo-press.de">info@galileo-press.de</a></div><br><br></body>
</html>
