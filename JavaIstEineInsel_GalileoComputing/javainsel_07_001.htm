<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Galileo Computing :: Java ist auch eine Insel – 7 Generics&lt;T&gt;</title>
<meta name="title" content="Galileo Computing :: Java ist auch eine Insel - 7 Generics<T>">
<meta name="author" content="Christian Ullenboom ">
<meta name="publisher" content="Galileo Press 2011">
<meta name="copyright" content="Galileo Press 2011">
<meta name="Description" content="Java ist auch eine Insel - Das umfassende Handbuch – 7 Generics<T>">
<meta name="audience" content="Alle">
<meta name="robots" content="INDEX,FOLLOW">
<meta http-equiv="content-language" content="de">
<link rel="stylesheet" type="text/css" href="common/galileo_open.css">
<link rel="prev" href=".htm">
<link rel="next" href=".htm"><script type="text/javascript"><!--
    function OpenWin(url,name,height,width)
    {
      var InfoWin = window.open(url,name,"directories=0,height="+height+",width=" + width + ",hotkeys=0,location=0,menubar=0,resizable=1,screenX=150,screenY=10,left=150,top=10,scrollbars=1,status=1,titlebar=0,toolbar=0");
      InfoWin.focus();
    }
    //--></script><link href="common/prettify.css" type="text/css" rel="stylesheet"><script type="text/javascript" src="common/prettify.js"></script></head>
<body vlink="#000099" link="#000099" alink="#000099" onload="prettyPrint()">
<table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#000066">
<tr>
<td height="74" valign="bottom" colspan="2"><a href="http://www.galileocomputing.de/katalog/openbook?GPP=opjiVIV"><img src="common/galileocomputing_openbook.gif" width="200" height="56" border="0" alt="Galileo Computing < openbook >" title="Galileo Computing < openbook >"></a></td>
<td width="80" height="74"><a href="http://www.galileocomputing.de/?GPP=opjiVIV"><img src="common/galileocomputing.gif" border="0" alt="Galileo Computing - Professionelle Bücher. Auch für Einsteiger." title="Galileo Computing - Professionelle Bücher. Auch für Einsteiger."></a></td>
</tr>
</table>
<div align="right"><a href="http://www.galileocomputing.de/?GPP=opjiVIV" class="navnav">Professionelle Bücher. Auch für Einsteiger.</a></div><br><table class="tbl" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="190" valign="top">
<table class="tbl1" border="0" cellpadding="3" cellspacing="0" width="190" align="left">
<tr>
<td class="tbl2"><a class="nav" href="index.htm#_top">Inhaltsverzeichnis</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_00_001.htm#mj58b119301920569a446c9c510503f310">Vorwort</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_01_001.htm#mja8fc5b7ad19fc7332bc66b09a8fda26e">1 Java ist auch eine Sprache</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_02_001.htm#mj313f67c98dc9ecaddfa2d8b80f057fd2">2 Sprachbeschreibung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_03_001.htm#mjcd3b5720e8605484942e3476a1075bdf">3 Klassen und Objekte</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_04_001.htm#mj71fbc84ad33a281b9352b0b19fae2fb2">4 Der Umgang mit Zeichenketten</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_05_001.htm#mj005cd8e604aefc3ae72b92880fcee5c6">5 Eigene Klassen schreiben</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_06_001.htm#mj6f6b47453043c38837bfc32154a97968">6 Exceptions</a></td>
</tr>
<tr>
<td><a class="navh" href="##mjc4a1f6f3499a02fb64fe89046739edca">7 Generics&lt;T&gt;</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_08_001.htm#mj46e914488628367f5dfc0a62c3a78a53">8 Äußere.innere Klassen</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_09_001.htm#mj94af2b90e8a2dad6c1ef67255f89a137">9 Besondere Klassen der Java SE</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_10_001.htm#mjcae20f50ffbc015d0b66861e7087af9b">10 Architektur, Design und angewandte Objektorientierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_11_001.htm#mj60bc6a007ae9b8657949f3e91d96df3d">11 Die Klassenbibliothek</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_12_001.htm#mj0ce00eb41aae2b084534019cf6edc3b6">12 Bits und Bytes und Mathematisches</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_13_001.htm#mj245f5f8d5a858b46462d64e9b9c0786b">13 Datenstrukturen und Algorithmen</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_14_001.htm#mj8c6f381221d805dd6fbe480731ac0c58">14 Threads und nebenläufige Programmierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_15_001.htm#mjbe3ed0989722396930966f95deeb2497">15 Raum und Zeit</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_16_001.htm#mj78bd405fb0de0cff099c06255fe36853">16 Dateien, Verzeichnisse und Dateizugriffe</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_17_001.htm#mjb420b02f4ccf65226f7271e48cefa05d">17 Datenströme</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_18_001.htm#mjedab16f1a9cc168eda4a24416359e0b9">18 Die eXtensible Markup Language (XML)</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_19_001.htm#mjc8f47f7f51ac3795c46c4544f391b02e">19 Grafische Oberflächen mit Swing</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_20_001.htm#mj25cc7d47e476b8b1a183a10ee741dbaa">20 Grafikprogrammierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_21_001.htm#mjea7bcdd596c8bd25b078a00221a01a75">21 Netzwerkprogrammierung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_22_001.htm#mjde622db61608a627262a27ecb377d675">22 Verteilte Programmierung mit RMI</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_23_001.htm#mj23bf599d65364bcd05d06a34cb5593bf">23 JavaServer Pages und Servlets</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_24_001.htm#mja621f3b4a74c7fa576b4a58b1614041e">24 Datenbankmanagement mit JDBC</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_25_001.htm#mja2e217bf5724cc65eba184a2af8b79cf">25 Reflection und Annotationen</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_26_001.htm#mjb47dd6e0a309b7e78cad68f6b5de9319">26 Dienstprogramme für die Java-Umgebung</a></td>
</tr>
<tr>
<td><a class="navnav" href="javainsel_27_001.htm#mjf59db36d9280a70e0d3d196e9bf160f5">A Die Begleit-DVD</a></td>
</tr>
<tr>
<td><a class="navnav" href="stichwort.htm#_top">Stichwort</a></td>
</tr>
<tr>
<td><br><a href="http://download2.galileo-press.de/openbook/galileocomputing_javainsel9.zip" class="navnav"><strong>Download:</strong><br>- ZIP, ca. 20,5 MB</a></td>
</tr>
<tr>
<td><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV" class="navnav">Buch bestellen</a></td>
</tr>
<tr>
<td><a class="navnav" href="#kommentar">Ihre Meinung?</a><br><br></td>
</tr>
</table>
</td>
<td width="10"><img src="common/spacer10.gif" width="10" height="10" alt="Spacer"></td>
<td width="85%" valign="top" align="center"><div align="center">
<table width="98%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="javainsel_06_006.htm" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a href="http://www.galileocomputing.de/?GPP=opjiVIV" class="navnav">Galileo Computing /</a><a href="http://www.galileocomputing.de/katalog/openbook/?GPP=opjiVIV" class="navnav"> &lt;openbook&gt; /</a><a href="index.htm" class="navnav"> Java-Insel</a></div></td>
<td align="right" width="25%"><div align="right"><a href="javainsel_08_001.htm" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" valign="top"><table width="100%" border="0" cellpadding="10" cellspacing="0" class="box">
<tr>
<td colspan="2"><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV" class="buchtitel">Java ist auch eine Insel</a><span class="autor"> von Christian Ullenboom </span><br><span class="untertitel">Das umfassende Handbuch</span></td>
</tr>
<tr>
<td valign="top" width="211"><dl>
<dt><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV" class="navnav"><img src="common/9783836215060.gif" border="0" alt="Buch: Java ist auch eine Insel" title="Buch: Java ist auch eine Insel"></a></dt>
<dd><br><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV"><span class="autor"><strong>Java ist auch eine Insel</strong><br>geb., mit DVD<br>1482 S., 49,90 Euro<br>Galileo Computing<br>ISBN 978-3-8362-1506-0</span></a></dd>
</dl></td>
<td width="80%"><table border="0">
<tr>
<td valign="baseline"><img src="common/pfeil_u.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="3" class="kap"><strong><a href="#mjc4a1f6f3499a02fb64fe89046739edca" class="navh">7 Generics&lt;T&gt;</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="#mj7beeacfcbe8aa79787f2509efecf5a1b" class="navh">7.1 Einführung in Java Generics</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj8cbd77c5d4582195f57bc28809b47234" class="navh">7.1.1 Mensch versus Maschine: Typprüfung des Compilers und der Laufzeitumgebung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj77a859bfbd2c5d845502327f0b50cc45" class="navh">7.1.2 Taschen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj9078abc2bd800d30d4ced5d5411f280a" class="navh">7.1.3 Generische Typen deklarieren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjfc333abda2107ee14ec63487afa25170" class="navh">7.1.4 Generics nutzen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj5d85d543ac0fb35a508a28ad85c7336b" class="navh">7.1.5 Generische Schnittstellen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj560fb1fe667e8110ccf341254ccc7ad5" class="navh">7.1.6 Generische Methoden/Konstruktoren und Typ-Inferenz</a></strong></td>
</tr>
</table><br></td>
</tr>
</table>
<table width="100%" cellpadding="20" cellspacing="0" border="0" bgcolor="#eeeeee">
<tr>
<td><div class="main">
<p class="anleser"><em>»Zu mancher richtigen Entscheidung kam es nur, weil der Weg zur falschen gerade nicht frei war.«
&#8211; Hans Krailsheimer (1888&#8211;1958)</em></p><a id="mjc4a1f6f3499a02fb64fe89046739edca" name="mjc4a1f6f3499a02fb64fe89046739edca"></a><h1 class="t1"><span class="cfett">7</span> Generics&lt;T&gt;</h1><a id="mj7beeacfcbe8aa79787f2509efecf5a1b" name="mj7beeacfcbe8aa79787f2509efecf5a1b"></a><a name="t21"></a><a name="t2t31"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div>
<h2 class="t2"><span class="cfett">7.1</span> Einführung in Java Generics  <a href="#t2t32"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><img src="common/15x15leer.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></h2>
<p>Generics zählen zu den komplexesten Sprachkonstrukten in Java. Wir wollen uns Generics in zwei Schritten nähern: von der Seite des Nutzers und von der Seite des API-Designers. Das Nutzen von generisch deklarierten Typen ist deutlich einfacher, sodass wir diese niedrig hängende Frucht zuerst pflücken wollen. Das Java-Buch für Fortgeschrittene dokumentiert sehr detailliert Generics aus der Sicht des API-Designers; die gepflückten Früchte werden dann veredelt.</p><a id="mj8cbd77c5d4582195f57bc28809b47234" name="mj8cbd77c5d4582195f57bc28809b47234"></a><a name="t31"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t32"></a><h3 class="t3"><span class="cfett">7.1.1</span> Mensch versus Maschine: Typprüfung des Compilers und 
der Laufzeitumgebung  <a href="#t2t33"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t31"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Eine wichtige Eigenschaft von Java ist, dass der Compiler die Typen prüft und so weiß, welche Eigenschaften vorhanden sind und welche nicht. Hier unterscheidet sich Java von dynamischen Programmiersprachen wie Python oder PHP, die erst spät eine Prüfung zur Laufzeit vornehmen.</p>
<p>In Java gibt es zwei Instanzen, die die Typen prüfen, und diese sind unterschiedlich schlau. Wir haben die JVM mit der absoluten Typ-Intelligenz, die unsere Anwendung ausführt und als letzte Instanz prüft, ob wir ein Objekt nicht einem falschen Typ zuweisen. Dann haben wir noch den Compiler, der zwar gut prüft, aber teilweise etwas zu gutgläubig ist, und dem Entwickler folgt. Macht der Entwickler Fehler, kann dieser die JVM ins Verderben stürzen und zu einer <span class="clisting">Exception</span> führen. Alles hat mit der expliziten Typanpassung zu tun.</p>
<p>Ein zunächst unkompliziertes Beispiel:</p>
<div class="listing"><pre class="prettyprint">Object o = "String";
String s = (String) o;</pre></div>
<p>Dem Compiler wird über den expliziten Typecast das <span class="clisting">Object o</span> für ein <span class="clisting">String</span> verkauft. Das ist in Ordnung, weil ja <span class="clisting">o</span> tatsächlich ein <span class="clisting">String</span>-Objekt referenziert. Problematisch wird es, wenn der Typ <span class="ckursiv">nicht</span> auf String gebracht werden kann, wir dem Compiler aber eine Typanpassung anweisen:</p>
<div class="listing"><pre class="prettyprint">Object o = Interger.valueOf( 42 );       // oder mit Autoboxing: Object o = 42;
String s = (String) o;</pre></div>
<p>Der Compiler akzeptiert die Typanpassung, und es folgt kein Fehler zur Übersetzungszeit. Es ist jedoch klar, dass diese Anpassung von der JVM nicht durchgeführt werden kann &#8211; daher folgt zur Laufzeit eine <span class="clisting">ClassCastException</span>, da eben ein <span class="clisting">Integer</span> nicht auf <span class="clisting">String</span> gebracht werden kann.</p>
<p>Bei Generics geht es nun darum, dem Compiler mehr Informationen über die Typen zu geben und <span class="clisting">ClassCastException</span>-Fehler zu vermeiden.</p><a id="mj77a859bfbd2c5d845502327f0b50cc45" name="mj77a859bfbd2c5d845502327f0b50cc45"></a><a name="t32"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t33"></a><h3 class="t3"><span class="cfett">7.1.2</span> Taschen  <a href="#t2t34"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t32"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>In unseren vorangehenden Beispielen drehte sich alles um Spieler und in einem Raum platzierte Spielobjekte. Stellen wir uns vor, der Spieler hat eine Tasche (engl. <span class="ckursiv">»pocket«</span>), die etwas enthält. Da nicht bekannt ist, was genau er in der Tasche hat, müssen wir einen Basistyp nehmen, der alle möglichen Objekttypen repräsentiert. Das soll in unserem ersten Beispiel der allgemeinste Basistyp <span class="clisting">Object</span> sein, sodass der Benutzer alles in seiner Tasche tragen kann: [Primitive Datentypen können über Wrapper-Objekte gespeichert werden, was seit Java 5 dank Auto-boxing leicht möglich ist. Der nachfolgende Abschnitt 9.2, »Wrapper-Klassen und Autoboxing«, erklärt diese Eigenschaft genauer.
] </p>
<p class="tabunter"><strong>Listing 7.1    </strong>com/tutego/insel/nongeneric/Pocket.java, Pocket</p>
<div class="listing"><pre class="prettyprint">public class Pocket
{
  private<span class="cfett"> Object</span> value;

  public Pocket() {}

  public Pocket(<span class="cfett"> Object</span> value ) { this.value = value; }

  public void set(<span class="cfett"> Object</span> value ) { this.value = value; }

  public<span class="cfett"> Object</span> get() { return value; }

  public boolean isEmpty() { return value == null; }

  public void empty() { value = null; }
}</pre></div>
<p>Es gibt einen Standard- sowie einen parametrisierten Konstruktor. Mit <span class="clisting">set()</span> lassen sich Objekte in die Tasche setzen und über die Zugriffsmethode <span class="clisting">get()</span> wieder auslesen.</p>
<p>Geben wir einem Spieler eine rechte und eine linke Tasche:</p>
<p class="tabunter"><strong>Listing 7.2    </strong>com/tutego/insel/nongeneric/Player.java, Player</p>
<div class="listing"><pre class="prettyprint">public class Player
{
  public String name;
  public Pocket rightPocket;
  public Pocket leftPocket;
}</pre></div>
<p>Zusammen mit einem Spieler, der eine rechte und eine linke Tasche hat, ist ein Beispiel schnell geschrieben. Unser Spieler <span class="clisting">michael</span> soll sich in beide Taschen Zahlen legen. [Das ist unproblematischer als Diprivan und Demerol…
]  Dann wollen wir sehen, in welcher Tasche er die größere Zahl versteckt hat.</p>
<p class="tabunter"><strong>Listing 7.3    </strong>com/tutego/insel/nongeneric/PlayerPocketDemo.java, main()</p>
<div class="listing"><pre class="prettyprint">Player michael = new Player();
michael.name = "Omar Arnold";
Pocket pocket = new Pocket();<span class="cfett">
Long</span> aBigNumber = 11111111111111L;
pocket.set( aBigNumber );                      // (1)
michael.leftPocket  = pocket;
michael.rightPocket = new Pocket( 2222222222222222222L );

System.out.println( michael.name + " hat in den Taschen " +
                    michael.leftPocket.get() + " und " + michael.rightPocket.get() );

Long val1 =<span class="cfett"> (Long)</span> michael.leftPocket.get();   // (2)
Long val2 =<span class="cfett"> (Long)</span> michael.rightPocket.get();

System.out.println( val1.compareTo( val2 ) &gt; 0 ? "Links" : "Rechts" );</pre></div>
<p>Das Beispiel hat keine besonderen Fallen, allerdings fallen zwei Sachen auf, die prinzipiell unschön sind. Das hat damit zu tun, dass die Klasse <span class="clisting">Pocket</span> mit dem Typ <span class="clisting">Object</span> zum Speichern der Tascheninhalte sehr allgemein deklariert wurde und alles aufnehmen kann:</p>
<ul class="gp">
<li>Beim Initialisieren wäre es gut, zu sagen, dass die Tasche nur einen bestimmen Typ (etwa <span class="clisting">Long</span>) aufnehmen kann. Wäre eine solche Einschränkung möglich, dann lassen sich wie in Zeile <span class="clisting">(1)</span> auch wirklich nur <span class="clisting">Long</span>-Objekte in die Tasche setzen und nichts anderes, etwa <span class="clisting">Integer</span>-Objekte.</li>
</ul>
<ul class="gp">
<li>Beim Entnehmen <span class="clisting">(2)</span> des Tascheninhalts mit <span class="clisting">get()</span> müssen wir uns daran erinnern, was wir hineingelegt haben. Fordern Datenstrukturen besondere Typen, dann sollte dieses auch dokumentiert sein. Doch wenn der Compiler wüsste, dass in der Tasche auf jeden Fall ein <span class="clisting">Long</span> ist, dann könnte die Typanpassung wegfallen und der Programmcode wäre kürzer. Auch könnte uns der Compiler warnen, wenn wir versuchen würden, das <span class="clisting">Long</span> als <span class="clisting">Integer</span> aus der Tasche zu ziehen. Unser Wissen möchten wir gerne dem Compiler geben! Denn wenn in der Tasche ein <span class="clisting">Long</span>-Objekt ist, wir es aber als <span class="clisting">Integer</span> annehmen und eine explizite Typanpassung auf <span class="clisting">Integer</span> setzen, meldet der Compiler zwar keinen Fehler, aber zur Laufzeit gibt es eine böse <span class="clisting">ClassCastException</span>.</li>
</ul>
<p>Um es auf den Punkt zu bringen: Der Compiler berücksichtigt im oberen Beispiel die Typsicherheit nicht ausreichend. Explizite Typanpassungen sind in der Regel unschön und sollten vermieden werden. Aber wie können wir die Taschen typsicher machen? Eine Lösung wäre, eine neue Klasse für jeden in der Tasche zu speichernden Typ zu deklarieren, also einmal eine <span class="clisting">PocketLong</span>, dann vielleicht <span class="clisting">PocketInteger</span>, <span class="clisting">PocketString</span>, <span class="clisting">PocketGameObject</span> usw. Nun dürfte klar sein, dass dies keine vernünftige Lösung ist; wir können nicht für jeden Datentyp eine neue Klasse schreiben, und die Logik bleibt die gleiche. Wir wollen wenig schreiben, aber Typsicherheit beim Compilieren haben und nicht erst die Typsicherheit zur Laufzeit, wo uns vielleicht eine <span class="clisting">ClassCastException</span> überrascht. Es wäre gut, wenn wir den Typ bei der Deklaration frei, allgemein, also »generisch« halten können, und sobald wir die Tasche benutzen, den Compiler dazu bringen könnten, auf diesen dann angegebenen Typ zu achten und die Korrektheit der Nutzung sicherzustellen.</p>
<p>Die Lösung für dieses Problem heißt <span class="ckursiv">Generics</span><span class="ckursiv">. [</span>In C++ werden diese Typen von Klassen <span class="ckursiv">parametrisierte Klassen</span> oder <span class="ckursiv">Templates</span> (Schablonen) genannt.
]  Diese Technik wurde in Java 5 eingeführt. Sie bietet Entwicklern ganz neue Möglichkeiten, um Datenstrukturen und Algorithmen zu programmieren, die von einem Datentyp unabhängig, also <span class="ckursiv">generisch</span> sind.</p><a id="mj9078abc2bd800d30d4ced5d5411f280a" name="mj9078abc2bd800d30d4ced5d5411f280a"></a><a name="t33"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t34"></a><h3 class="t3"><span class="cfett">7.1.3</span> Generische Typen deklarieren  <a href="#t2t35"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t33"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Wollen wir <span class="clisting">Pocket</span> in einen <span class="ckursiv">generischen Typ</span> umbauen, so müssen wir an den Stellen, an denen <span class="clisting">Object</span> vorkam, einen Typstellvertreter, einen so genannten <span class="ckursiv">formalen Typparameter</span> einsetzen, der durch eine <span class="ckursiv">Typvariable</span> repräsentiert wird. Der Name der Typvariablen muss in der Klassendeklaration angegeben werden.</p>
<p>Die Syntax für den generischen Typ von <span class="clisting">Pocket</span> ist folgende:</p>
<p class="tabunter"><strong>Listing 7.4    </strong>com/tutego/insel/generic/Pocket.java, Pocket</p>
<div class="listing"><pre class="prettyprint">public class Pocket<span class="cfett">&lt;T&gt;</span>
{
  private<span class="cfett"> T</span> value;

  public Pocket() {}

  public Pocket(<span class="cfett"> T</span> value ) { this.value = value; }

  public void set(<span class="cfett"> T</span> value ) { this.value = value; }

  public<span class="cfett"> T</span> get() { return value; }

  public boolean isEmpty() { return value != null; }

  public void empty() { value = null; }
}</pre></div>
<p>Wir haben die Typvariable <span class="clisting">T</span> definiert und verwenden diese jetzt anstelle von <span class="clisting">Object</span> in der <span class="clisting">Pocket</span>-Klasse.</p>
<p>Bei generischen Typen steht die Angabe der Typvariable nur einmal zu Beginn der Klassendeklaration in spitzen Klammern hinter dem Klassennamen. Der Typparameter kann nun fast [<span class="clisting">T t = new T();</span> ist zum Beispiel nicht möglich.
]  überall dort genutzt werden, wo auch ein herkömmlicher Typ stand. In unserem Beispiel ersetzen wir direkt <span class="clisting">Object</span> durch <span class="clisting">T</span>, und fertig ist die generische Klasse.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Namenskonvention   </span>Formale Typparameter sind in der Regel einzelne Großbuchstaben wie <span class="clisting">T</span> (steht für Typ), <span class="clisting">E</span> (Element), <span class="clisting">K</span> (Key/Schlüssel), <span class="clisting">V</span> (Value/Wert). Sie sind nur Platzhalter und keine wirklichen Typen. Möglich wäre etwa auch Folgendes, doch davon ist absolut <span class="ckursiv">abzuraten</span>, da <span class="clisting">Dwarf</span> viel zu sehr nach einem echten Klassentyp als nach einem formalen Typparameter aussieht:</p>
<div class="listing"><pre class="prettyprint">public class Pocket&lt;<span class="cfett">Dwarf</span>&gt;
{
  private <span class="cfett">Dwarf</span> value;
  public void set( <span class="cfett">Dwarf</span> value ) { this.value = value;
  public <span class="cfett">Dwarf</span> get() { return value;
}</pre></div>
</td>
</tr>
</table><br><h4 class="t4">Wofür Generics noch gut ist</h4>
<p>Es gibt eine ganze Reihe von Beispielen, in denen Speicherstrukturen wie unsere Tasche nicht nur für einen Datentyp <span class="clisting">Long</span> sinnvoll sind, sondern grundsätzlich für alle Typen, wobei aber die Implementierung (relativ) unabhängig vom Typ der Elemente ist. Das gilt zum Beispiel für einen Sortieralgorithmus, der mit der Ordnung der Elemente arbeitet. Wenn zwei Elemente größer oder kleiner sein können, muss ein Algorithmus lediglich diese Eigenschaft nutzen können. Es ist dabei egal, ob es Zahlen vom Typ <span class="clisting">Long</span>, <span class="clisting">Double</span> oder auch Strings oder Kunden sind &#8211; der Algorithmus selbst ist davon nicht betroffen. Der häufigste Einsatz von Generics sind Container, die typsicher gestaltet werden sollen.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Die Idee, Generics in Java einzuführen, ist schon älter und geht auf das Projekt <span class="ckursiv">Pizza</span> beziehungsweise das Teilprojekt <span class="ckursiv">GJ</span> (A Generic Java Language Extension) von Martin Odersky (auch Schöpfer der Programmiersprache Scala), Gilad Bracha, David Stoutamire und Philip Wadler zurück. GJ wurde dann die Basis des JSR 14: Add Generic Types To The Java Programming Language.</p>
</td>
</tr>
</table><br><a id="mjfc333abda2107ee14ec63487afa25170" name="mjfc333abda2107ee14ec63487afa25170"></a><a name="t34"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t35"></a><h3 class="t3"><span class="cfett">7.1.4</span> Generics nutzen  <a href="#t2t36"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t34"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Um die neue <span class="clisting">Pocket</span>-Klasse nutzen zu können, müssen wir sie zusammen mit einem Typparameter angeben; es entsteht der <span class="ckursiv">parametrisierte Typ</span>:</p>
<p class="tabunter"><strong>Listing 7.5    </strong>com/tutego/insel/generic/PocketPlayer.java, main() Teil 1</p>
<div class="listing"><pre class="prettyprint">Pocket<span class="cfett">&lt;Integer&gt;</span>  intPocket     = new Pocket<span class="cfett">&lt;Integer&gt;</span>();
Pocket<span class="cfett">&lt;String&gt;</span>   stringPocket  = new Pocket<span class="cfett">&lt;String&gt;</span>();</pre></div>
<p>Der konkrete Typ steht immer hinter dem Klassen-/Schnittstellennamen in spitzen Klammern. [Dass auch XML in spitzen Klammern daherkommt und XML als groß und aufgebläht gilt, wollen wir nicht als Parallele zu Javas Generics sehen.
]  Die Tasche <span class="clisting">intPocket</span> ist eine Instanziierung eines generischen Typs mit dem konkreten Typargument <span class="clisting">Integer</span>. Diese Tasche kann jetzt offiziell nur <span class="clisting">Integer</span>-Werte enthalten, und die Tasche <span class="clisting">stringPocket</span> enthält nur Zeichenketten. Das prüft der Compiler auch, und wir benötigen keine Typanpassung mehr:</p>
<p class="tabunter"><strong>Listing 7.6    </strong>com/tutego/insel/generic/PocketPlayer.java, main() Teil 2</p>
<div class="listing"><pre class="prettyprint">intPocket.set( 1 );
int x = intPocket.get();
stringPocket.set( "Selbstzerstörungsauslösungsschalterhintergrundbeleuchtung" );
String s = stringPocket.get();</pre></div>
<p>Der Entwickler macht so im Programmcode sehr deutlich, dass die Taschen einen <span class="clisting">Integer</span> enthalten und nichts anderes. Da Programmcode häufiger gelesen als geschrieben wird, sollten Autoren immer so viele Informationen wie möglich über den Kontext in den Programmcode legen. Zwar leidet die Lesbarkeit etwas, da insbesondere der Typ sowohl rechts wie auch links angegeben werden muss und die Syntax bei geschachtelten Generics lang werden kann, doch wie wir später sehen werden, lässt sich das noch abkürzen.</p>
<p>Das Schöne für die Typsicherheit ist, dass nun alle Eigenschaften mit dem angegebenen Typ geprüft werden. Wenn wir etwa aus <span class="clisting">intPocket</span> mit <span class="clisting">get()</span> auf das Element zugreifen, ist es vom Typ <span class="clisting">Integer</span> (und durch Unboxing gleich <span class="clisting">int</span>), und <span class="clisting">set()</span> erlaubt auch nur ein <span class="clisting">Integer</span>. Das macht den Programmcode robuster und durch den Wegfall der Typanpassungen kürzer und lesbarer.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Keine Primitiven   </span>Typparameter können in Java nur Java-Typen, also etwa Klassennamen sein, aber keine primitiven Datentypen. Das schränkt die Möglichkeiten zwar ein, doch da es Autoboxing gibt, lässt sich damit leben. Und wenn <span class="clisting">null</span> in der <span class="clisting">Pocket&lt;Integer&gt;</span> liegt, führt ein Unboxing zur Laufzeit zur <span class="clisting">NullPointerException</span>.</p>
</td>
</tr>
</table><br><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 7.1    </strong>Zusammenfassung der bisherigen Generics-Begriffe</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">Begriff</span>
</td>
<td class="tabellenkopf"><span class="cfett">Beispiel</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p>generischer Typ (engl. <span class="ckursiv">generic type</span>)</p>
</td>
<td class="tabellentext">
<p><span class="clisting">Pocket&lt;T&gt;</span></p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p>Typvariable oder formaler Typparameter 
(engl. <span class="ckursiv">formal type parameter</span>)</p>
</td>
<td class="tabellentext">
<p><span class="clisting">T</span></p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p>parametrisierter Typ (engl. <span class="ckursiv">parameterized type</span>)</p>
</td>
<td class="tabellentext">
<p><span class="clisting">Pocket&lt;Long&gt;</span></p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p>Typparameter (engl. <span class="ckursiv">actual type parameter</span>)</p>
</td>
<td class="tabellentext">
<p><span class="clisting">Long</span></p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p>Originaltyp (engl. <span class="ckursiv">raw type</span>)</p>
</td>
<td class="tabellentext">
<p><span class="clisting">Pocket</span></p>
</td>
</tr>
</table><br><h4 class="t4">Geschachtelte Generics</h4>
<p>Ist ein generischer Typ wie <span class="clisting">Pocket&lt;T&gt;</span> gegeben, gibt es erst einmal keine Einschränkung für <span class="clisting">T</span>. So beschränkt sich <span class="clisting">T</span> nicht auf einfache Klassen- oder Schnittstellentypen, sondern kann auch wieder ein generischer Typ sein. Das ist logisch, denn jeder generische Typ ist ja ein eigenständiger Typ, der (fast) wie jeder andere Typ genutzt werden kann:</p>
<p class="tabunter"><strong>Listing 7.7    </strong>com/tutego/insel/generic/PocketPlayer.java, main() Teil 3</p>
<div class="listing"><pre class="prettyprint">Pocket&lt;<span class="cfett">Pocket&lt;String</span><span class="cfett">&gt;</span>&gt; pocketOfPockets = new Pocket&lt;<span class="cfett">Pocket&lt;String&gt;</span>&gt;();
pocketOfPockets.set( new Pocket&lt;String&gt;() );
pocketOfPockets.get().set( "Inner Pocket&lt;String&gt;" );
System.out.println( pocketOfPockets.get().get() ); // Inner Pocket&lt;String&gt;</pre></div>
<p>Hier enthält die Tasche eine Tasche, die eine Zeichenkette <span class="clisting">"Inner Pocket&lt;String&gt;"</span> speichert.</p>
<p>Bei Dingen wie diesen ist schnell offensichtlich, wie hilfreich Generics für den Compiler (und uns) sind. Ohne Generics sähen eben alle Taschen gleich aus.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 7.2    </strong>Übersichtlichkeit durch Generics</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">Präzise mit Generics</span>
</td>
<td class="tabellenkopf"><span class="cfett">Unpräzise ohne Generics</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">Pocket&lt;String&gt; stringPocket;</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">Pocket stringPocket;</span></p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">Pocket&lt;Integer&gt; intPocket;</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">Pocket intPocket;</span></p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">Pocket&lt;Pocket&lt;String&gt;&gt; pocketOfPockets;</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">Pocket pocketOfPockets;</span></p>
</td>
</tr>
</table><br><p>Nur ein gut gewählter Name und eine präzise Dokumentation können bei nicht-generisch deklarierten Variablen helfen. Vor Java 5 haben sich Entwickler damit geholfen, mithilfe eines Blockkommentars Generics anzudeuten, etwa in <span class="clisting">Pocket/*&lt;String&gt;*/ stringPocket</span>.</p><a id="mj5d85d543ac0fb35a508a28ad85c7336b" name="mj5d85d543ac0fb35a508a28ad85c7336b"></a><a name="t35"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t36"></a><h3 class="t3"><span class="cfett">7.1.5</span> Generische Schnittstellen  <a href="#t2t37"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t35"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Eine Schnittstelle kann genauso als generischer Typ deklariert werden wie eine Klasse. Werfen wir einen Blick auf die Schnittstellen <span class="clisting">java.lang.Comparable</span> und <span class="clisting">java.util.Set</span>, die beide seit Java 5 mit einer Typvariablen ausgestattet sind (das <span class="clisting">?</span> gestattet jeden Typparameter und soll uns in der Tabelle nicht irritieren).</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" rowspan="2">
<div class="listing"><pre class="prettyprint">public interface Comparable<span class="cfett">&lt;T&gt;</span>
{
 public int compareTo(<span class="cfett">T</span> o);
}</pre></div>
</td>
<td class="tabellentext" rowspan="2">
<div class="listing"><pre class="prettyprint">public interface Set<span class="cfett">&lt;E&gt;</span> extends Collection<span class="cfett">&lt;E&gt;</span>
{
 int size();
 boolean isEmpty();
 boolean contains(Object o);
 Iterator<span class="cfett">&lt;E&gt;</span> iterator();
 Object[] toArray();
 &lt;T&gt; T[] toArray(T[] a);
 boolean add(<span class="cfett">E</span> e);
 boolean remove(Object o);
 boolean containsAll(Collection&lt;?&gt; c);
 boolean addAll(Collection&lt;? extends<span class="cfett"> E</span>&gt; c);
 boolean retainAll(Collection&lt;?&gt; c);
 boolean removeAll(Collection&lt;?&gt; c);
 void clear();
 boolean equals(Object o);
 int hashCode();
}</pre></div>
</td>
</tr>
</table><br><p>Wie bekannt, greifen die Methoden auf die Typvariablen <span class="clisting">T</span> und <span class="clisting">E</span> zurück. Bei <span class="clisting">Set</span> ist weiterhin zu erkennen, dass sie selbst eine generisch deklarierte Schnittstelle erweitert.</p>
<p>Beim Einsatz von generischen Schnittstellen lassen sich die folgenden zwei Benutzungsmuster ableiten:</p>
<ul class="gp">
<li>Ein nicht-generischer Klassentyp löst Generics bei der Implementierung auf.</li>
</ul>
<ul class="gp">
<li>Ein generischer Klassentyp implementiert eine generische Schnittstelle und gibt die Parametervariable weiter.</li>
</ul>
<h4 class="t4">Nicht-generischer Klassentyp löst Generics bei der Implementierung auf</h4>
<p>Im ersten Fall implementiert eine Klasse die generisch deklarierte Schnittstelle und gibt einen konkreten Typ an. Alle numerischen Wrapper-Klassen implementieren zum Beispiel <span class="clisting">Comparable</span> und füllen den Typparameter genau mit dem Typ der Wrapper-Klasse:</p>
<div class="listing"><pre class="prettyprint">public final class Integer extends Number<span class="cfett"> implements Comparable&lt;Integer&gt;</span>
{
  public int compareTo( Integer anotherInteger ) { … }
  …</pre></div>
<p>Durch diese Nutzung wird für den Anwender die Klasse <span class="clisting">Integer</span> Generics-frei.</p>
<h4 class="t4">Generischer Klassentyp implementiert generische Schnittstelle und 
gibt die Parametervariable weiter</h4>
<p>Die Schnittstelle <span class="clisting">Set</span> schreibt Operationen für Mengen vor. Eine Klasse, die <span class="clisting">Set</span> implementiert, ist zum Beispiel <span class="clisting">HashSet</span>. Der Kopf der Typdeklaration ist folgender:</p>
<div class="listing"><pre class="prettyprint">public class HashSet<span class="cfett">&lt;E&gt;</span>
    extends AbstractSet&lt;E&gt;
   <span class="cfett"> implements Set&lt;E&gt;</span>, Cloneable, java.io.Serializable</pre></div>
<p>Es ist abzulesen, dass <span class="clisting">Set</span> eine Typvariable <span class="clisting">E</span> deklariert, die <span class="clisting">HashSet</span> nicht konkretisiert. Der Grund ist, dass die Datenstruktur <span class="clisting">Set</span> vom Anwender als parametrisierter Typ verwendet wird und nicht aufgelöst werden soll.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>In manchen Situationen wird auch <span class="clisting">Void</span> als Typparameter eingesetzt. Deklariert etwa <span class="clisting">interface I&lt;T&gt; { T foo(); }</span> eine Typvariable <span class="clisting">T</span>, doch gibt es bei der Implementierung von <span class="clisting">I</span> nichts zurückzugeben, dann kann der Typparameter <span class="clisting">Void</span> sein:</p>
<div class="listing"><pre class="prettyprint">class C implements I&lt;Void&gt;
  @Override public Void foo() { return null;
}</pre></div>
<p class="BStandard">Allerdings sind <span class="clisting">void</span> und <span class="clisting">Void</span> unterschiedlich, denn bei <span class="clisting">Void</span> muss es eine Rückgabe geben, was ein <span class="clisting">return null</span> notwendig macht.</p>
</td>
</tr>
</table><br><a id="mj560fb1fe667e8110ccf341254ccc7ad5" name="mj560fb1fe667e8110ccf341254ccc7ad5"></a><a name="t36"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t37"></a><h3 class="t3"><span class="cfett">7.1.6</span> Generische Methoden/Konstruktoren und Typ-Inferenz  <img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"><a href="#t2t36"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Die bisher genannten generischen Konstruktionen sahen im Kern wie folgt aus:</p>
<ul class="gp">
<li><span class="clisting">class C</span><span class="cfett">&lt;T&gt;</span> <span class="clisting">{</span> … <span class="clisting">}</span></li>
</ul>
<ul class="gp">
<li><span class="clisting">interface I</span><span class="cfett">&lt;T&gt;</span> <span class="clisting">{</span> … <span class="clisting">}</span></li>
</ul>
<p>Eine an der Klassen- oder Schnittstellendeklaration angegebene Typvariable gilt für alle nicht-statischen Methoden des Typs. Doch was machen wir, wenn</p>
<ul class="gp">
<li>statische Methoden eine eigene Typvariable nutzen wollen?</li>
</ul>
<ul class="gp">
<li>diese Typvariable zu »global« ist und unterschiedliche Methoden unterschiedliche Typ-variablen nutzen möchten?</li>
</ul>
<p>Eine Klasse kann auch ohne Generics deklariert werden, aber <span class="ckursiv">generische Methoden</span> besitzen. Ganz allgemein kann jeder Konstruktor, jede Objektmethode und jede Klassenmethode einen oder mehrere formale Typparameter deklarieren. Sie stehen dann nicht mehr an der Klasse, sondern an der Methoden-/Konstruktordeklaration und sind »lokal« für die Methode beziehungsweise den Konstruktor. Das allgemeine Format ist:</p>
<div class="listing"><pre class="prettyprint">Modifizierer &lt;<span class="cfett">Typvariable(n)</span>&gt; Rückgabetyp Methodenname(Parameter) throws-Klausel</pre></div>
<h4 class="t4">Ganz zufällig das eine oder andere Argument</h4>
<p>Interessant sind generische Methoden insbesondere für Utility-Klassen, die nur statische Methoden anbieten, aber selbst nicht als Objekt vorliegen. Das folgende Beispiel zeigt das anhand einer Methode <span class="clisting">random()</span>:</p>
<p class="tabunter"><strong>Listing 7.8    </strong>com/tutego/insel/generic/GenericMethods.java, GenericMethods</p>
<div class="listing"><pre class="prettyprint">public class GenericMethods
{
  public static<span class="cfett"> &lt;T&gt; T</span> random(<span class="cfett"> T</span> m,<span class="cfett"> T</span> n )
  {
    return Math.random() &gt; 0.5 ? m : n;
  }

  public static void main( String[] args )
  {
    String s = random( "Analogkäse", "Gel-Schinken" );
    System.out.println( s );
  }
}</pre></div>
<p>Es deklariert <span class="clisting">&lt;T&gt; T random(T m, T n)</span> eine generische Methode, wobei der Rückgabetyp und Parametertyp durch eine Typvariable <span class="clisting">T</span> bestimmt wird. Die Angabe von <span class="clisting">&lt;T&gt;</span> beim Klassennamen ist bei dieser Syntax entfallen, und auf die Deklaration der Methode verschoben.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Hinweis   </span>Natürlich kann eine Klasse als generischer Typ und eine darin enthaltene Methode als generische Methode mit unterschiedlichem Typ deklariert werden. In diesem Fall sollten die Typvariablen unterschiedlich benannt sein, um den Leser nicht zu verwirren. So bezieht sich im Folgenden <span class="clisting">T</span> bei <span class="clisting">sit()</span> eben <span class="ckursiv">nicht</span> auf die Parametervariable der Klasse <span class="clisting">Lupilu</span>, sondern auf die der Methode:</p>
<div class="listing"><pre class="prettyprint">class Lupilu&lt;<span class="cfett">T</span>&gt; { &lt;<span class="cfett">T</span>&gt; void sit( <span class="cfett">T</span> val ); }  // Verwirrend
class Lupilu&lt;<span class="cfett">T</span>&gt; { &lt;<span class="cfett">V</span>&gt; void sit( <span class="cfett">V</span> val ); }  // Besser</pre></div>
</td>
</tr>
</table><br><h4 class="t4">Der Compiler auf der Suche nach Gemeinsamkeiten</h4>
<p>Den Typ (der wichtig für die Rückgabe ist) leitet der Compiler also automatisch aus dem Kontext, das heißt aus den Argumenten, ab. Diese Eigenschaft nennt sich <span class="ckursiv">Typ-Inferenz</span> (engl <span class="ckursiv">type inference</span>) Das hat weitreichende Konsequenzen.</p>
<p>Bei der Deklaration <span class="clisting">&lt;T&gt; T random(T m, T n)</span> sieht es vielleicht auf den ersten Blick so aus, als ob die Variablentypen <span class="clisting">m</span> und <span class="clisting">n</span> absolut gleich sein müssen. Das stimmt aber nicht, denn bei den Typen geht der Compiler in der Typhierarchie so weit nach oben, bis er einen gemeinsamen Typ findet.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 7.3    </strong>Gemeinsame Basistypen</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">Aufruf</span>
</td>
<td class="tabellenkopf"><span class="cfett">Identifizierte Typen</span>
</td>
<td class="tabellenkopf"><span class="cfett">Gemeinsame Basistypen</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">random("Essen", 1)</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">String</span>, <span class="clisting">Integer</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">Object</span>, <span class="clisting">Serializable</span>, <span class="clisting">Comparable</span></p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">random(1L, 1D)</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">Long</span>, <span class="clisting">Double</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">Object, Number</span>, <span class="clisting">Comparable</span></p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">random(new Point(), new StringBuilder())</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">Point, StringBuffer</span></p>
</td>
<td class="tabellentext">
<p><span class="clisting">Object</span>, <span class="clisting">Serializable</span>, <span class="clisting">Cloneable</span></p>
</td>
</tr>
</table><br><p>Es fällt auf, aber überrascht nicht, dass <span class="clisting">Object</span> immer in die Gruppe gehört.</p>
<p>Die Schnittmenge der Typen bildet im Fall von <span class="clisting">random()</span> die gültigen Rückgabetypen. Erlaubt sind demnach für die Parametertypen <span class="clisting">String</span> und <span class="clisting">Integer</span>:</p>
<div class="listing"><pre class="prettyprint">Object       s1 = random( "Essen", 1 );
Serializable s2 = random( "Essen", 1 );
Comparable   s3 = random( "Essen", 1 );</pre></div>
<h4 class="t4">Generische Methoden mit explizitem Typparameter *</h4>
<p>Es gibt Situationen, in denen der Compiler nicht aus dem Kontext über Typ-Inferenz den richtigen Typ ableiten kann. Folgendes ist nicht möglich:</p>
<div class="listing"><pre class="prettyprint">boolean hasPocket = true;
Pocket&lt;String&gt; pocket = hasPocket ? Pocket.newInstance() : null;</pre></div>
<p>Der Eclipse-Compiler meldet "<span class="clisting">Type mismatch: cannot convert from Pocket&lt;Object&gt; to Pocket&lt;String&gt;</span>".</p>
<p>Die Lösung: Wir müssen bei <span class="clisting">Pocket.newInstance()</span> den Typparameter <span class="clisting">String</span> explizit angeben:</p>
<div class="listing"><pre class="prettyprint">Pocket&lt;String&gt; pocket = hasPocket ? Pocket.<span class="cfett">&lt;String&gt;</span>newInstance() : null;</pre></div>
<p>Die Syntax ist etwas gewöhnungsbedürftig, doch in der Praxis ist die explizite Angabe selten nötig.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="cfett">Beispiel   </span>Ist das Argument der statischen Methode <span class="clisting">Arrays.asList()</span> ein Feld, dann ist der explizite Typparameter nötig, da der Compiler nicht erkennen kann, ob das Feld selbst das eine Element der Rückgabe-<span class="clisting">List</span> ist oder ob das Feld die Vararg-Umsetzung ist und alle Elemente des Feldes in die Rückgabeliste kommen:</p>
<div class="listing"><pre class="prettyprint">List&lt;String&gt; list11 = Arrays.asList( new String[] { "A", "B" } );
List&lt;String&gt; list12 = Arrays.asList( "A", "B" );
System.out.println( list11 );   // [A, B]
System.out.println( list12 );   // [A, B]
List&lt;String&gt; list21 = Arrays.<span class="cfett">&lt;String&gt;</span>asList( new String[] { "A", "B" } );
List&lt;String&gt; list22 = Arrays.<span class="cfett">&lt;String&gt;</span>asList( "A", "B" );
System.out.println( list21 );   // [A, B]
System.out.println( list22 );   // [A, B]
List&lt;String[]&gt; list31 = Arrays.<span class="cfett">&lt;String[]&gt;</span>asList( new String[] { "A", "B" } );
// List&lt;String[]&gt; list32 = Arrays.<span class="cfett">&lt;String[]&gt;</span>asList( "A", "B" );
System.out.println( list31 );   // [[Ljava.lang.String;@69b332]</pre></div>
<p class="BStandard">Zunächst gilt es, festzuhalten, dass die Ergebnisse für <span class="clisting">list11</span>, <span class="clisting">list12</span>, <span class="clisting">list21</span> und <span class="clisting">list22</span> identisch sind. Der Compiler setzt ein Vararg automatisch als Feld um und übergibt das Feld der <span class="clisting">asList()</span>-Methode. Im Bytecode sehen daher die Aufrufe gleich aus (zur Wiederholung siehe Abschnitt 3.7.12, »Methode mit variabler Argumentanzahl (Vararg)«.)</p>
<p class="BStandard">Bei <span class="clisting">list21</span> und <span class="clisting">list22</span> ist der Typparameter jeweils explizit angegeben, aber nicht wirklich nötig, da ja das Ergebnis wie <span class="clisting">list11</span> bzw. <span class="clisting">list12</span> ist. Doch der Typparameter <span class="clisting">String</span> macht deutlich, dass die Elemente im Feld, also die Vararg-Argumente, Strings sind. Spannend wird es bei <span class="clisting">list31</span>. Zunächst zum Problem: Ist <span class="clisting">new String[]{"A", "B"}</span> das Argument einer Vararg-Methode, so ist das mehrdeutig, weil genau dieses Feld das erste Element des vom Compiler automatisch aufgebauten Varargs-Feldes sein könnte (dann wäre es ein Feld im Feld) oder &#8211; und das ist die interne Standardumsetzung &#8211; der Java-Compiler das übergebene Feld als die Vararg-Umsetzung interpretiert. Diese Doppeldeutigkeit löst <span class="clisting">&lt;String[]&gt;</span>, da in dem Fall klar ist, dass das von uns aufgebaute String-Feld das einzige Element eines neuen Varargs-Feldes sein muss. Und <span class="clisting">Arrays.&lt;String[]&gt;asList()</span> stellt heraus, dass der Typ der Feldelemente <span class="clisting">String[]</span> ist. Daher funktioniert auch die letzte Variablendeklaration nicht, denn bei <span class="clisting">asList("A", "B")</span> ist der Elementtyp <span class="clisting">String</span>, aber nicht <span class="clisting">String[]</span>.</p>
</td>
</tr>
</table><br><br><hr><a name="kommentar"></a><h3>Ihr Kommentar</h3>
                       Wie hat Ihnen das &lt;openbook&gt; gefallen? Wir freuen uns immer über Ihre freundlichen und kritischen Rückmeldungen.
                       <form action="http://www.galileo-press.de/feedback/openbook" method="post" style="text-align: center; margin-top: 10px;"><input type="hidden" name="openbookurl" value="javainsel9/.htm"><input type="hidden" name="buchtitel" value="Java ist auch eine Insel"><input type="hidden" name="Kapitel" value="7 Generics<T>"><table border="0">
<tr>
<td><label for="name">Name</label><br></td>
<td><input type="text" name="name" id="name" size="40"><br></td>
</tr>
<tr>
<td><label for="email">E-Mail</label><br></td>
<td><input type="text" name="email" id="email" size="40"><br></td>
</tr>
<tr>
<td valign="top"><label for="comment">Ihr Kommentar</label><br></td>
<td><textarea name="comment" id="comment" rows="10" cols="40"></textarea><br></td>
</tr>
<tr>
<td>
</td>
<td><input type="submit" value="Kommentar absenden"></td>
</tr>
</table>
</form>
</div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="javainsel_06_006.htm" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a class="navnav" href="#">&lt;top&gt;</a></div></td>
<td align="right" width="25%"><div align="right"><a href="javainsel_08_001.htm" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
</table>
</div></td>
<td width="10" valign="top">  </td>
<td width="160" valign="top">
<table border="0" cellpadding="0" cellspacing="0" width="160">
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2">
&nbsp;<a href="http://www.galileocomputing.de/katalog/buecher/?GPP=opjiVIV" class="autor">
<strong>Zum Katalog</strong></a>

</td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2">
<img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><a href="http://www.galileocomputing.de/2254?GPP=opjiVIV">
<img src="common/9783836215060_s.gif" width="119" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Java ist auch eine Insel" title="Zum Katalog: Java ist auch eine Insel">
<br><br><br><br><br><br><strong>Java ist auch eine Insel</strong><br><img src="common/pfeil_rechts5.gif" border="0" alt="">Jetzt bestellen</a><br /><br />
</td>
</tr>
</table>
</td>

</tr>
</table>
</td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2"><span class="autor"><strong>&nbsp;Ihre Meinung?</strong></a></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">

<table cellspacing="3">
<tr>
<td>Wie hat Ihnen das &lt;openbook&gt; gefallen?<br><a href="#kommentar"><img src="common/pfeil_rechts5.gif" border="0" alt="">Ihre Meinung</a>
<br><br></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>

<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>
<tr>
<td>
</td>
</tr>

<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2">&nbsp;<a href="http://www.galileocomputing.de/katalog/buecher/?GPP=opjiVIV" class="autor"><strong>Buchempfehlungen</strong></a></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2285?GPP=opjiVIV">
<img src="common/9783836215275_s.gif" width="102" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Computergeschichte(n) – nicht nur für Geeks" title="Zum Katalog: Computergeschichte(n) – nicht nur für Geeks"><br><br><br><br><br><br>&nbsp;Computergeschichte(n)<br>&nbsp;nicht nur für Geeks</a><br><br></td>
</tr>

<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/1949?GPP=opjiVIV">
<img src="common/9783836213080_s.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Java und XML" title="Zum Katalog: Java und XML"><br><br><br><br><br><br><br>&nbsp;Java und XML</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2346?GPP=opjiVIV">
<img src="common/9783836215688_s.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Einstieg in Java" title="Zum Katalog: Einstieg in Java"><br><br><br><br><br><br><br>&nbsp;Einstieg<br>&nbsp;in Java</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2051?GPP=opjiVIV">

<img src="common/9783836213677_s.gif" width="112" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Einstieg in XML" title="Zum Katalog: Einstieg in XML"><br><br><br><br><br><br><br>&nbsp;Einstieg<br>&nbsp;in XML</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2322?GPP=opjiVIV">
<img src="common/9783836215527_s.gif" width="112" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Visual C# 2010" title="Zum Katalog: Visual C# 2010"><br><br><br><br><br><br><br>&nbsp;Visual C# 2010</a><br><br></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2212?GPP=opjiVIV">
<img src="common/9783836214742_s.gif" width="119" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Professionell entwickeln mit Visual C# 2010" title="Zum Katalog: Professionell entwickeln mit Visual C# 2010"><br><br><br><br><br><br><br>&nbsp;Professionell<br>&nbsp;entwickeln mit<br>&nbsp;Visual C# 2010</a><br><br></td>
</tr>

<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2156?GPP=opjiVIV">
<img src="common/9783836214292_s.gif" width="108" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C++ von A bis Z" title="Zum Katalog: C++ von A bis Z"><br><br><br><br><br><br><br>&nbsp;C++ von A bis Z</a><br><br></td>
</tr>
</table></td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
</tr>

<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="start" height="20" colspan="2"><span class="autor"><strong>&nbsp;Shopping</strong></span></td>
</tr>
<tr>
<td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><b>Versandkostenfrei</b> bestellen in Deutschland und &Ouml;sterreich<br><a href="http://www.galileocomputing.de/hilfe/Shop/?GPP=opjiVIV"><img src="common/pfeil_rechts5.gif" border="0" alt="Info">Info</a><br><br></td>

</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table><br><br><hr width="70%" align="center">
<div align="center">
<p class="standard"><strong>Copyright © Galileo Press 2011</strong><br>
        Für Ihren privaten Gebrauch dürfen Sie die Online-Version natürlich ausdrucken.
        Ansonsten unterliegt das &lt;openbook&gt; denselben Bestimmungen, wie die
        gebundene Ausgabe: Das Werk einschließlich aller seiner Teile ist urheberrechtlich
        geschützt. Alle Rechte vorbehalten einschließlich der Vervielfältigung, Übersetzung,
        Mikroverfilmung sowie Einspeicherung und Verarbeitung in elektronischen Systemen.</p><br><a href="http://www.galileocomputing.de/">[Galileo Computing]</a><br><br>
      Galileo Press, Rheinwerkallee 4, 53227 Bonn, Tel.: 0228.42150.0, Fax 0228.42150.77, <a href="mailto:info@galileo-press.de">info@galileo-press.de</a></div><br><br></body>
</html>
